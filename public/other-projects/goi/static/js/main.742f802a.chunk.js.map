{"version":3,"sources":["components/NavBar.tsx","components/NewCard.tsx","components/ListView.tsx","components/DeckView.tsx","lib/utils.ts","lib/tokenizer.ts","ast/NODE.js","ast/CARD.ts","ast/DECK.ts","ast/TAG.ts","ast/TAGS.ts","ast/ATTRIBUTE.ts","ast/ATTRIBUTES.ts","ast/CREATE_DECK.ts","ast/PROGRAM.ts","lib/constants.ts","lib/highlighter.ts","lib/guesser.ts","model/constants.ts","lib/reconciler.ts","lib/getIintialData.ts","components/ErrorMessage.tsx","components/CardEditor.tsx","ast/SUBJECT.ts","ast/DECKS.ts","ast/SESSIONS.ts","ast/SUBJECT_MODIFIER.ts","ast/COMPLEX_COMMAND.ts","ast/HELP.ts","ast/LIST.ts","ast/EXPORT_DECKS.ts","ast/LOAD_DECKS.ts","ast/QUIT_TO_HOME.ts","ast/COMMAND.ts","components/CommandEditor.tsx","components/ProgressBar.tsx","components/SingleCard.tsx","components/CardFlip.tsx","model/query.ts","lib/sessionHelperFunctions.ts","components/Session.tsx","components/StatisticsTable.tsx","components/StatisticsOverview.tsx","components/Statistics.tsx","components/DeckViewDetails.tsx","components/PostSessionSummary.tsx","App.tsx","serviceWorker.js","model/schema.ts","model/Card.ts","model/Deck.ts","model/Session.ts","model/SessionCard.ts","model/Tag.ts","model/TagCard.ts","index.js"],"names":["NavBar","style","backgroundColor","useStyles","makeStyles","theme","createStyles","root","media","height","paddingTop","expand","transform","marginLeft","transition","transitions","create","duration","shortest","expandOpen","avatar","NewCard","props","classes","React","useState","expanded","setExpanded","marginTop","width","display","flexDirection","className","CardHeader","title","CardContent","Typography","paragraph","front","CardActions","disableSpacing","IconButton","clsx","onClick","aria-expanded","aria-label","Collapse","in","timeout","unmountOnExit","alignItems","back","Deck","Paper","margin","justifyItems","fontSize","console","log","name","dispatch","type","deckName","ListView","deckNames","map","idx","key","DeckView","program","decks","create_decks","cd","deck","length","textAlign","lastDeck","cards","color","gridTemplateColumns","debug","isDebugEnabled","debugDB","items","process","toLowerCase","shuffle","arr","sort","Math","random","createCardData","index","correct","incorrect","score","toString","indexString","createDeckData","count","createSessionData","startDate","endDate","decksString","join","dateString","Date","toLocaleDateString","year","month","day","hour","minute","randomize","subjects","shuffledCards","i","j","floor","temp","Tokenizer","content","literalsList","tokens","currentToken","literals","this","tokenize","tokenizedProgram","replace","forEach","s","re","RegExp","slicedArray","split","slice","t","trim","filter","token","regexp","checkNext","match","getNext","Error","theTokenizer","NODE","tokenizer","getTokenizer","CARD","cardNumber","getAndCheckToken","checkToken","parseInt","DECK","moreTokens","card","parse","push","TAG","tagName","TAGS","tags","tag","ATTRIBUTE","attribute","attributeType","value","currentAttribute","isNextTokenIsAttribute","nextToken","ATTRIBUTES","attributes","invalidNameTokens","CREATE_DECK","includes","nextAttributeOrTag","checkForAndParseTags","checkForAndParseAttributes","checkForAndParseDeck","PROGRAM","create_deck","validCardFilter","allTokens","deckCreationLiterals","highlight","editor","doc","getDoc","lines","ranges","line","lineNumber","literal","indexOf","charStart","charEnd","getHighlights","getValue","markText","ch","GuessType","guessCardActionInDeck","oldDeck","newDeck","oldDeckCards","newDeckCards","CopyPasteSingleDeck","Delete","oldCards","updatedCards","newCards","uc","CreateCard","guessNewCard","guessCardAction","oldDecks","newDecks","numDifferences","firstDifference","undefined","od","nd","compareDeckLengths","CopyPasteMultiDecks","singleDifference","UpdateCardBack","oldBack","newBack","UpdateCardFront","oldFront","newFront","Nothing","guessCardUpdate","guess","prev","curr","oldDeckNames","newDecksFound","CreateDeck","guessNewDeck","list2","differingNames","reduce","acc","deck1","deck2","cards1","cards2","find","c1","c2","haveSameCards","UpdateDeckName","oldDeckName","newDeckName","guessPossiblyRenamedDeck","TableName","updateDeckName","oldName","newName","db","a","collections","get","DECKS","action","query","Q","where","eq","fetch","foundDecks","update","createOrUpdateCard","subAction","addCard","CARDS","cardsQ","id","foundCards","createOrUpdateEntireDeck","createDeck","cardsCollection","fetchCount","cardFrontQ","cardsWithSameFront","cardBackQ","cardsWithSameBack","cardToUpdate","c","createOrUpdateAllDecks","guessedAction","defaultText","Alert","elevation","variant","spacing","ErrorMessage","message","severity","open","vertical","horizontal","state","setState","handleClose","Snackbar","anchorOrigin","onClose","handleSnackbar","thenUnix","lastOpenedUnix","now","flipSnackbarState","CardEditor","useDatabase","snackbarState","setSnackbarState","initialText","isInSession","processInput","localStorage","setItem","makeTokenizer","JSON","stringify","reconcile","then","catch","err","ActionType","CardEditorParseSuccess","options","mode","lineNumbers","editorDidMount","SetCardEditor","cardEditor","onChange","data","nowUnix","setTimeout","lastChange","getItem","SubjectType","SESSIONS","SUBJECT","subject","subjectType","Undefined","Sessions","Decks","Tags","parseInteractivePrompt","SUBJECT_MODIFIER","limit","selectCards","actionToken","isNaN","Number","round","constants","COMPLEX_COMMAND","subjectModfier","HELP","LIST","option","EXPORT_DECKS","dataString","fakeAnchor","document","createElement","href","encodeURIComponent","download","toISOString","click","LOAD_DECKS","QUIT_TO_HOME","COMMAND","command","evaluate","helpMsg","lineHeight","startSessionOrStats","CommandEditor","openHelp","setOpenHelp","text","setEditorState","handleCloseHelp","event","reason","newLines","oldLines","startsWith","userMadeInvalidChange","oldValue","position","setValue","setCursor","revertChange","table","endsWith","newValue","valueToParse","substr","isHelpCommand","listNode","List","listOption","QuitToHome","fakeInput","onchange","e","file","target","files","fileReader","FileReader","readAsText","onload","deckCreationDSL","result","LoadDecks","createDSLValue","isStartSessionOrShowStats","modifier","isTagsSubject","StartSession","ShowStats","isLimitAppliedToCards","tagNames","CommandNotFound","autoHideDuration","Fragment","size","ProgressBar","setNextCard","addCardDataToLocalStorage","currentCard","currentResult","setResult","useTheme","activeStep","setActiveStep","MobileStepper","steps","nextButton","Button","prevActiveStep","disabled","direction","backButton","StyledH2","styled","h2","alignment","StyledCard","Card","StyledCardContent","SingleCard","CardFlip","isFlipped","setIsFlipped","handleClick","preventDefault","curState","flipDirection","Filter","getSelectedDecks","decksCollection","oneOf","getDeckNameFromID","getUniqueDeckNamesFromSessions","session","deckIds","sessionCards","sessionCard","deck_id","deckId","concat","getCardsFromSelectedDecks","getAllSessions","sessionsCollection","getPastSessions","n","allSessions","b","started_at","getCardsFromSelectedSessions","allCards","sessions","uniqueCards","cardFilter","BEST","right","wrong","WORST","NEWEST","created_at","OLDEST","RANDOM","deckFilter","deckScoreMap","Map","calculateDeckScore","set","sessionFilter","sessionsScoreMap","getSessionScore","rightCount","wrongCount","sessionCardsCollection","SESSIONS_CARDS","totalCards","numberCorrect","is_correct","cardIds","Set","has","add","getValidDeckNames","requestedDeckNames","validDeckNames","deckNamesInProgram","dn","actualDeckName","Object","keys","selectedCreateDecks","selectedCards","cardWithDeck","getCardsFromDecksNoFilter","splice","getCardStatsFromDB","selectedCardsSet","cardsWithStats","createdAt","getCardsFromDecksWithFilter","card1","card2","decksFromDB","filteredDecks","filteredDecksSet","filteredCreateDecks","getCardsFromDecks","getCardsFromTags","createDeckTags","hasASelectedTag","getCardsFromSessions","deckIdToDeckName","flashCards","addTagsToFlashCard","getSessionMaterialsWithTags","complexCommandParams","getSessionMaterials","sessionMaterials","flashCard","filteredDeckNamesSet","nextCardIndex","gotCorrect","cardDataArray","sessionDataObject","newSessionDataObject","sessionData","currentCardID","cardData","card_id","card_index","alreadyAdded","o","alreadyAddedIndex","sessionsTable","cardTable","deckTable","sessionCardTable","deckNameToDeckModel","ended_at","createdSession","matchedCards","deckModel","cardModel","cm","last_tested_at","session_id","addEndTimeToSessionDataInLocalStorage","endedAt","currentSessionData","saveSessionDataToDB","Session","isDone","setIsDone","setNextCardIndex","setSessionMaterials","isLoading","setIsLoading","error","setError","useEffect","sessionCommandErr","activeDeckNames","matchedDeckNames","findIndex","possibleTags","giveError","checkSessionCommandError","nowString","initialData","initialDataString","_getSessionMaterials","PostSession","CircularProgress","initialTime","Minutes","Seconds","Subject","deckname","numPastSessionsString","showDecksOrPastSessionsHeader","alt","src","marginRight","ColumnType","container","maxHeight","cardColumns","label","minWidth","align","summaryColumns","deckColumns","sessionColumns","StatisticsTable","rows","columnType","page","setPage","rowsPerPage","setRowsPerPage","columns","CARD_COLUMNS","SUMMARY_COLUMNS","DECK_COLUMNS","SESSION_COLUMNS","TableContainer","Table","stickyHeader","TableHead","TableRow","column","TableCell","TableBody","row","hover","role","tabIndex","TablePagination","rowsPerPageOptions","component","onChangePage","newPage","onChangeRowsPerPage","StatsOverview","View","overview","overviewKey","renderHeaderRow","values","overviewValue","renderValueRow","Statistics","initialState","view","LOADING","database","createStatsObject","getDetails","highestScore","lowestScore","averageScore","details","getColumnType","NaN","retrievedCards","filteredCards","totalScore","toFixed","retrievedDecks","sum","retrievedSessions","filteredSessions","statsObject","READY","ERROR","setStatsObject","StatisticsOverview","DeckViewDetails","PostSessionSummary","sessionDataString","endedAtObj","createdAtObj","totalTimeInMS","getTime","totalMinutes","totalSeconds","isCorrect","results","tagsString","createSummaryData","getSessionCards","cardArray","numerator","accumulator","currentValue","denominator","isAllCorrect","CustomListView","reducer","SESSION","STATS","POST_SESSION","DECK_DETAIL","deckToViewDetail","App","savedText","lastAstJsonStr","isFirstTimeUser","initialProgram","getInitialData","subjectToList","useReducer","removeItem","d","showView","Boolean","window","location","hostname","columnSchema","isIndexed","appSchema","version","tables","tableSchema","TAGS_CARDS","date","field","Model","associations","foreignKey","children","lazy","on","SessionCard","Tag","TagCard","adapter","LokiJSAdapter","schema","useWebWorker","useIncrementalIndexedDB","Database","modelClasses","actionsEnabled","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.742f802a.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nexport default function NavBar() {\r\n  return (\r\n    <>\r\n      <div style={{ backgroundColor: \"white\" }}>\r\n        <h1>Goi</h1>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles, Theme, createStyles } from \"@material-ui/core/styles\";\r\nimport clsx from \"clsx\";\r\nimport Card from \"@material-ui/core/Card\";\r\nimport CardHeader from \"@material-ui/core/CardHeader\";\r\n// import CardMedia from '@material-ui/core/CardMedia';\r\nimport CardContent from \"@material-ui/core/CardContent\";\r\nimport CardActions from \"@material-ui/core/CardActions\";\r\nimport Collapse from \"@material-ui/core/Collapse\";\r\n// import Avatar from '@material-ui/core/Avatar';\r\nimport IconButton from \"@material-ui/core/IconButton\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\n// import { red } from '@material-ui/core/colors';\r\n// import FavoriteIcon from '@material-ui/icons/Favorite';\r\n// import ShareIcon from '@material-ui/icons/Share';\r\nimport ExpandMoreIcon from \"@material-ui/icons/ExpandMore\";\r\n// import MoreVertIcon from '@material-ui/icons/MoreVert';\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n  createStyles({\r\n    root: {\r\n      // maxWidth: 345,\r\n    },\r\n    media: {\r\n      height: 0,\r\n      paddingTop: \"56.25%\", // 16:9\r\n    },\r\n    expand: {\r\n      transform: \"rotate(0deg)\",\r\n      marginLeft: \"auto\",\r\n      transition: theme.transitions.create(\"transform\", {\r\n        duration: theme.transitions.duration.shortest,\r\n      }),\r\n    },\r\n    expandOpen: {\r\n      transform: \"rotate(180deg)\",\r\n    },\r\n    avatar: {\r\n      backgroundColor: \"red\",\r\n    },\r\n  })\r\n);\r\n\r\ntype Props = { style?: {}; front: string; back: string };\r\n\r\nexport default function NewCard(props: Props) {\r\n  const classes = useStyles();\r\n  const [expanded, setExpanded] = React.useState(false);\r\n\r\n  const handleExpandClick = () => {\r\n    setExpanded(!expanded);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Card\r\n        style={{\r\n          marginTop: \"2em\",\r\n          width: \"23em\",\r\n          display: \"flex\",\r\n          flexDirection: \"column\",\r\n        }}\r\n        className={classes.root}\r\n      >\r\n        <CardHeader title=\"\" />\r\n        <CardContent>\r\n          <div style={{ height: \"3em\", marginTop: \"3em\" }}>\r\n            <Typography paragraph style={{}}>\r\n              {props.front}\r\n            </Typography>\r\n          </div>\r\n        </CardContent>\r\n        <CardActions disableSpacing>\r\n          <IconButton\r\n            className={clsx(classes.expand, {\r\n              [classes.expandOpen]: expanded,\r\n            })}\r\n            onClick={handleExpandClick}\r\n            aria-expanded={expanded}\r\n            aria-label=\"show more\"\r\n          >\r\n            <ExpandMoreIcon />\r\n          </IconButton>\r\n        </CardActions>\r\n        <Collapse in={expanded} timeout=\"auto\" unmountOnExit>\r\n          <CardContent\r\n            style={{\r\n              marginTop: \"4em\",\r\n            }}\r\n          >\r\n            <div style={{ height: \"5em\", alignItems: \"center\" }}>\r\n              <Typography paragraph>{props.back}</Typography>\r\n            </div>\r\n          </CardContent>\r\n        </Collapse>\r\n      </Card>\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { Paper } from \"@material-ui/core\";\r\n\r\ntype DeckProps = { name: string; dispatch?; key: number };\r\ntype ListProps = { deckNames: string[]; dispatch? };\r\n\r\nfunction Deck(props: DeckProps) {\r\n  return (\r\n    <Paper\r\n      style={{\r\n        margin: \"2em\",\r\n        width: \"20vw\",\r\n        height: \"12vw\",\r\n        justifyItems: \"center\",\r\n        display: \"flex\",\r\n        fontSize: \"1.5em\",\r\n      }}\r\n      onClick={() => {\r\n        console.log(props.name);\r\n        props.dispatch({ type: \"view deck detail\", deckName: props.name });\r\n      }}\r\n    >\r\n      <div style={{ margin: \"auto\" }}>{props.name}</div>\r\n    </Paper>\r\n  );\r\n}\r\n\r\nexport default function ListView(props: ListProps) {\r\n  return (\r\n    <>\r\n      {props.deckNames.map((deckName, idx) => (\r\n        <Deck key={idx} name={deckName} dispatch={props.dispatch}></Deck>\r\n      ))}\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport NewCard from \"./NewCard\";\r\nimport ListView from \"./ListView\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\nimport DECK from \"../ast/DECK\";\r\n\r\nexport default function DeckView({\r\n  program,\r\n  dispatch,\r\n}: {\r\n  program: PROGRAM;\r\n  dispatch: Function;\r\n}) {\r\n  const decks: DECK[] = program?.create_decks?.map((cd) => cd.deck);\r\n  if (!decks || decks.length === 0) {\r\n    return (\r\n      <div style={{ textAlign: \"center\" }}>\r\n        <h2>You have no deck! 🙀 Enter something in the editor!</h2>\r\n      </div>\r\n    );\r\n  }\r\n  const lastDeck = decks[decks.length - 1];\r\n  const { front, back } = lastDeck.cards[lastDeck.cards.length - 1];\r\n\r\n  return (\r\n    <>\r\n      <div className=\"card-view-container\">\r\n        <div className=\"card-view\">\r\n          <h1 style={{ color: \"#333333\" }}>\r\n            Deck: {program.create_decks[program.create_decks.length - 1].name}\r\n          </h1>\r\n          <NewCard front={front} back={back}></NewCard>\r\n          <div\r\n            style={{\r\n              marginTop: \"2em\",\r\n              display: \"grid\",\r\n              gridTemplateColumns: \"1fr 1fr\",\r\n            }}\r\n          >\r\n            <ListView\r\n              deckNames={program.create_decks.map((cd) => cd.name)}\r\n              dispatch={dispatch}\r\n            ></ListView>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","export function debug(...items: any): void {\r\n  if (isDebugEnabled()) {\r\n    console.log(...items);\r\n  }\r\n}\r\n\r\nexport function debugDB(...items: any): void {\r\n  debug(\"🍉 \", ...items);\r\n}\r\n\r\nfunction isDebugEnabled(): boolean {\r\n  return (\r\n    process.env.REACT_APP_DEBUG &&\r\n    process.env.REACT_APP_DEBUG.toLowerCase() === \"on\"\r\n  );\r\n}\r\n\r\nexport function shuffle<T>(arr: Array<T>): Array<T> {\r\n  return arr.sort(() => Math.random() - 0.5);\r\n}\r\n\r\nexport function createCardData(\r\n  index: number,\r\n  front: string,\r\n  back: string,\r\n  correct: number,\r\n  incorrect: number,\r\n  deck: string\r\n) {\r\n  const score = correct.toString() + \"/\" + (incorrect + correct).toString();\r\n  const indexString = index.toString() + \".)\";\r\n  return { indexString, front, back, score, deck };\r\n}\r\n\r\nexport function createSummaryData(\r\n  index: number,\r\n  front: string,\r\n  back: string,\r\n  isCorrect: boolean,\r\n  deck: string,\r\n  tags?: string[]\r\n) {\r\n  let results;\r\n  if (isCorrect === undefined) {\r\n    results = \"skipped\";\r\n  } else {\r\n    results = isCorrect ? \"correct\" : \"incorrect\";\r\n  }\r\n\r\n  let tagsString;\r\n  if (tags && tags.length > 0) {\r\n    tagsString = tags.join(\", \");\r\n  } else {\r\n    tagsString = \"none\";\r\n  }\r\n  const indexString = index.toString() + \".)\";\r\n  return { indexString, front, back, results, deck, tagsString };\r\n}\r\n\r\nexport function createDeckData(\r\n  index: number,\r\n  name: string,\r\n  count: number,\r\n  score: number\r\n) {\r\n  const indexString = index.toString() + \".)\";\r\n  return { indexString, name, count, score };\r\n}\r\n\r\nexport function createSessionData(\r\n  index: number,\r\n  count: number,\r\n  correct: number,\r\n  startDate: number,\r\n  endDate: number,\r\n  decks: string[]\r\n) {\r\n  const score = correct.toString() + \"/\" + count.toString();\r\n  const decksString = decks.join(\", \");\r\n  const indexString = index.toString() + \".)\";\r\n  const duration = (endDate - startDate) / 1000;\r\n  const date = new Date(startDate);\r\n  const options = {\r\n    year: \"2-digit\",\r\n    month: \"2-digit\",\r\n    day: \"2-digit\",\r\n    hour: \"numeric\",\r\n    minute: \"numeric\",\r\n  };\r\n\r\n  const dateString = date.toLocaleDateString(\"en-US\", options);\r\n\r\n  return { indexString, dateString, count, score, duration, decksString };\r\n}\r\n\r\n// shuffle function from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function randomize(subjects: any[]): any[] {\r\n  let shuffledCards = subjects;\r\n  for (let i = shuffledCards.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    const temp = shuffledCards[i];\r\n    shuffledCards[i] = shuffledCards[j];\r\n    shuffledCards[j] = temp;\r\n  }\r\n  return shuffledCards;\r\n}\r\n","import { debug } from \"./utils\";\r\n\r\n// Tokenizer is modified from in-class example\r\nclass Tokenizer {\r\n  private static program: string;\r\n  private static literals: Array<string>;\r\n  private tokens: Array<string>;\r\n  private currentToken: number;\r\n  private static theTokenizer: Tokenizer;\r\n\r\n  private constructor(content: string, literalsList: Array<string>) {\r\n    Tokenizer.program = content;\r\n    Tokenizer.literals = literalsList;\r\n    this.tokens = [];\r\n    this.currentToken = 0;\r\n\r\n    this.tokenize();\r\n  }\r\n\r\n  tokenize(): void {\r\n    let tokenizedProgram = Tokenizer.program;\r\n    tokenizedProgram = tokenizedProgram.replace(/\\n/g, \"_\");\r\n    debug(Tokenizer.program);\r\n\r\n    Tokenizer.literals.forEach((s) => {\r\n      debug(\"string: \", s);\r\n      const re = new RegExp(s, \"ig\");\r\n      debug(\"regexp: \", re);\r\n      tokenizedProgram = tokenizedProgram.replace(re, `_${s}_`);\r\n      debug(tokenizedProgram);\r\n    });\r\n    tokenizedProgram = tokenizedProgram.replace(/__/g, \"_\");\r\n    debug(tokenizedProgram);\r\n    const temparray = tokenizedProgram.split(\"_\");\r\n    const slicedArray = temparray.slice(1);\r\n    this.tokens = slicedArray.map((t) => t.trim()).filter((t) => t !== \"\");\r\n    debug(this.tokens);\r\n  }\r\n\r\n  checkNext(): string {\r\n    let token = \"\";\r\n\r\n    if (this.currentToken < this.tokens.length) {\r\n      token = this.tokens[this.currentToken];\r\n    } else {\r\n      token = \"NO_MORE_TOKENS\";\r\n    }\r\n\r\n    return token;\r\n  }\r\n\r\n  getNext(): string {\r\n    let token = \"\";\r\n\r\n    if (this.currentToken < this.tokens.length) {\r\n      token = this.tokens[this.currentToken];\r\n      this.currentToken++;\r\n    } else {\r\n      token = \"NULLTOKEN\";\r\n    }\r\n\r\n    return token;\r\n  }\r\n\r\n  checkToken(regexp: string): boolean {\r\n    const s = this.checkNext();\r\n    const re = new RegExp(regexp);\r\n    debug(`comparing: |${s}|  to  |${regexp}|`);\r\n    return !!s.match(re);\r\n  }\r\n\r\n  getAndCheckToken(regexp: string): string {\r\n    const s = this.getNext();\r\n    const re = new RegExp(regexp);\r\n\r\n    if (!s.match(re)) {\r\n      throw Error(\r\n        `Unexpected next token for Parsing! Expected something matching: ${regexp} but got: ${s}`\r\n      );\r\n    }\r\n    debug(`matched: ${s}  to  ${regexp}`);\r\n    return s;\r\n  }\r\n\r\n  moreTokens(): boolean {\r\n    return this.currentToken < this.tokens.length;\r\n  }\r\n\r\n  static makeTokenizer(content: string, literals: Array<string>): void {\r\n    this.theTokenizer = new Tokenizer(content, literals);\r\n  }\r\n\r\n  static getTokenizer(): Tokenizer {\r\n    return this.theTokenizer;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n","import Tokenizer from \"../lib/tokenizer\";\r\n\r\nexport default class NODE {\r\n  tokenizer = Tokenizer.getTokenizer();\r\n  parse() {\r\n    throw new Error(\"parse not implemented\");\r\n  }\r\n  evaluate() {\r\n    throw new Error(\"evaluate not implemented\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class CARD extends NODE {\r\n  cardNumber: number = 0;\r\n  front: string = \"\";\r\n  back: string = \"\";\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"\\\\(\");\r\n    const isIntString = this.tokenizer.checkToken(\"^[1-9]+[0-9]*$\");\r\n    if (isIntString) {\r\n      this.cardNumber = parseInt(this.tokenizer.getNext());\r\n      this.tokenizer.getAndCheckToken(\"\\\\)\");\r\n      this.front = this.tokenizer.getNext();\r\n      this.tokenizer.getAndCheckToken(\":\");\r\n      this.back = this.tokenizer.getNext();\r\n    } else {\r\n      throw new Error(\"Card number incorrect in Card\");\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport CARD from \"./CARD\";\r\n\r\nexport default class DECK extends NODE {\r\n  cards: CARD[] = [];\r\n  parse() {\r\n    while (\r\n      this.tokenizer.moreTokens() &&\r\n      !this.tokenizer.checkToken(\"add color\") &&\r\n      !this.tokenizer.checkToken(\"add direction\") &&\r\n      !this.tokenizer.checkToken(\"add alignment\") &&\r\n      !this.tokenizer.checkToken(\"add tags\") &&\r\n      !this.tokenizer.checkToken(\"create deck\")\r\n    ) {\r\n      let card = new CARD();\r\n      card.parse();\r\n      this.cards.push(card);\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class TAG extends NODE {\r\n  tagName: string = \"\";\r\n  parse() {\r\n    this.tagName = this.tokenizer.getNext();\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport TAG from \"./TAG\";\r\n\r\nexport default class TAGS extends NODE {\r\n  tags: TAG[] = [];\r\n  type = \"tags\";\r\n\r\n  parseInteractivePrompt() {\r\n    this.tokenizer.getAndCheckToken(\"tags:\");\r\n    while (this.tokenizer.moreTokens()) {\r\n      let tag = new TAG();\r\n      tag.parse();\r\n      this.tags.push(tag);\r\n      if (this.tokenizer.checkNext() === \",\") {\r\n        this.tokenizer.getNext();\r\n      }\r\n    }\r\n  }\r\n\r\n  parse() {\r\n    const nextToken = this.tokenizer.checkNext().toLowerCase();\r\n    if (nextToken === \"add tags\") {\r\n      this.tokenizer.getNext();\r\n    }\r\n    this.tokenizer.getAndCheckToken(\":\");\r\n    while (\r\n      this.tokenizer.moreTokens() &&\r\n      !this.tokenizer.checkToken(\"add color\") &&\r\n      !this.tokenizer.checkToken(\"add direction\") &&\r\n      !this.tokenizer.checkToken(\"add alignment\") &&\r\n      !this.tokenizer.checkToken(\"\\\\(\")\r\n    ) {\r\n      if (this.tokenizer.checkNext() === \",\") {\r\n        this.tokenizer.getNext();\r\n      }\r\n      let tag = new TAG();\r\n      tag.parse();\r\n      this.tags.push(tag);\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\ninterface AttributeObj {\r\n  attributeType: string;\r\n  value: string;\r\n}\r\n\r\nexport default class ATTRIBUTE extends NODE {\r\n  attribute: AttributeObj = { attributeType: \"\", value: \"\" };\r\n\r\n  parse() {\r\n    const currentAttribute = this.tokenizer.getNext().toLowerCase();\r\n    this.tokenizer.getAndCheckToken(\":\");\r\n    switch (currentAttribute) {\r\n      case \"add alignment\":\r\n        this.attribute.attributeType = \"alignment\";\r\n        if (this.tokenizer.checkToken(\"center|right|left\")) {\r\n          this.attribute.value = this.tokenizer.getNext();\r\n        } else {\r\n          throw new Error(\"Alignment Attribute is not valid\");\r\n        }\r\n        break;\r\n      case \"add direction\":\r\n        this.attribute.attributeType = \"direction\";\r\n        if (this.tokenizer.checkToken(\"horizontal|vertical\")) {\r\n          this.attribute.value = this.tokenizer.getNext();\r\n        } else {\r\n          throw new Error(\"Direction Attribute is not valid\");\r\n        }\r\n        break;\r\n      case \"add color\":\r\n        this.attribute.attributeType = \"color\";\r\n        if (\r\n          this.tokenizer.checkToken(\"red|blue|yellow|purple|green|grey|brown\")\r\n        ) {\r\n          this.attribute.value = this.tokenizer.getNext();\r\n        } else {\r\n          throw new Error(\"Color Attribute is not valid\");\r\n        }\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport ATTRIBUTE from \"./ATTRIBUTE\";\r\nimport Tokenizer from \"../lib/tokenizer\";\r\n\r\nexport function isNextTokenIsAttribute(): boolean {\r\n  const tokenizer = Tokenizer.getTokenizer();\r\n  const nextToken = tokenizer.checkNext().toLowerCase();\r\n  return (\r\n    nextToken === \"add color\" ||\r\n    nextToken === \"add alignment\" ||\r\n    nextToken === \"add direction\"\r\n  );\r\n}\r\nexport default class ATTRIBUTES extends NODE {\r\n  attributes: ATTRIBUTE[] = [];\r\n  parse() {\r\n    if (isNextTokenIsAttribute()) {\r\n      while (\r\n        this.tokenizer.moreTokens() &&\r\n        !this.tokenizer.checkToken(\"add tags\") &&\r\n        !this.tokenizer.checkToken(\"\\\\(\")\r\n      ) {\r\n        let attribute = new ATTRIBUTE();\r\n        attribute.parse();\r\n        this.attributes.push(attribute);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport DECK from \"./DECK\";\r\nimport TAGS from \"./TAGS\";\r\nimport ATTRIBUTES, { isNextTokenIsAttribute } from \"./ATTRIBUTES\";\r\n\r\nconst invalidNameTokens = [\":\", \"(\", \")\", \",\", \"NULLTOKEN\"];\r\n\r\nexport default class CREATE_DECK extends NODE {\r\n  tags: TAGS | null = null;\r\n  attributes: ATTRIBUTES | null = null;\r\n  deck: DECK | null = null;\r\n  name: string = \"\";\r\n\r\n  checkForAndParseTags() {\r\n    const nextToken = this.tokenizer.checkNext().toLowerCase();\r\n    if (nextToken === \"add tags\") {\r\n      this.tags = new TAGS();\r\n      this.tags.parse();\r\n    }\r\n  }\r\n\r\n  checkForAndParseAttributes() {\r\n    if (isNextTokenIsAttribute()) {\r\n      this.attributes = new ATTRIBUTES();\r\n      this.attributes.parse();\r\n    }\r\n  }\r\n\r\n  checkForAndParseDeck() {\r\n    if (this.tokenizer.checkToken(\"\\\\(\")) {\r\n      this.deck = new DECK();\r\n      this.deck.parse();\r\n    }\r\n  }\r\n\r\n  parse() {\r\n    //parse deck\r\n    this.tokenizer.getAndCheckToken(\"create deck\");\r\n    const name = this.tokenizer.getNext();\r\n    if (invalidNameTokens.includes(name)) {\r\n      throw new Error(\"invalid deck name\");\r\n    }\r\n    this.name = name;\r\n    this.tokenizer.getAndCheckToken(\":\");\r\n    let nextAttributeOrTag = true;\r\n    while (this.tokenizer.moreTokens() && nextAttributeOrTag) {\r\n      this.checkForAndParseTags();\r\n      this.checkForAndParseAttributes();\r\n      nextAttributeOrTag =\r\n        isNextTokenIsAttribute() ||\r\n        this.tokenizer.checkNext().toLowerCase() === \"add tags\";\r\n    }\r\n    if (this.tokenizer.moreTokens()) {\r\n      this.checkForAndParseDeck();\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport CREATE_DECK from \"./CREATE_DECK\";\r\n\r\nexport default class PROGRAM extends NODE {\r\n  create_decks: CREATE_DECK[] = [];\r\n  parse() {\r\n    while (this.tokenizer.moreTokens()) {\r\n      if (this.tokenizer.checkToken(\"create deck\")) {\r\n        let create_deck = new CREATE_DECK();\r\n        create_deck.parse();\r\n        this.create_decks.push(create_deck);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n","export const keywords = [\r\n  \"show stats for\",\r\n  \"start session from\",\r\n  \"help\",\r\n  \"list\",\r\n  \"export decks\",\r\n  \"load decks\",\r\n  \"quit\",\r\n  \"back to home\",\r\n  \",\",\r\n  \"cards from\",\r\n];\r\nexport const validCardFilter = [\"best\", \"worst\", \"random\", \"oldest\", \"newest\"];\r\nexport const subjectKeywords = [\"decks:\", \"tags:\", \"past sessions\"];\r\n\r\nexport const allTokens = [...validCardFilter, ...keywords, ...subjectKeywords];\r\n\r\nexport const deckCreationLiterals = [\"create deck\", \":\", \"\\\\(\", \"\\\\)\", \",\"];\r\n","export type Range = { lineNumber: number; charStart: number; charEnd: number };\r\n\r\n/**\r\n * Applies syntax highlighting to a CodeMirror editor\r\n * Should be called onChange\r\n *\r\n * @param editor The CodeMirror Editor instance\r\n * @param literals lower case strings for exact matching\r\n * @param className CSS classname (optional)\r\n */\r\nexport function highlight(\r\n  editor: CodeMirror.Editor,\r\n  literals: string[],\r\n  className?: string\r\n) {\r\n  const doc = editor.getDoc();\r\n  const value = doc.getValue();\r\n  const highlights = getHighlights(value, literals);\r\n  highlights.forEach((highlight) => {\r\n    doc.markText(\r\n      { line: highlight.lineNumber, ch: highlight.charStart },\r\n      { line: highlight.lineNumber, ch: highlight.charEnd },\r\n      { className: className || \"syntax-highlight\" }\r\n    );\r\n  });\r\n}\r\n\r\nfunction getHighlights(program: string, literals: string[]): Range[] {\r\n  program = program.toLowerCase();\r\n  const lines = program.split(\"\\n\");\r\n  const ranges: Range[] = [];\r\n  lines.forEach((line, lineNumber) => {\r\n    literals.forEach((literal) => {\r\n      const idx = line.indexOf(literal);\r\n      if (idx !== -1) {\r\n        ranges.push({\r\n          lineNumber,\r\n          charStart: idx,\r\n          charEnd: idx + literal.length,\r\n        });\r\n      }\r\n    });\r\n  });\r\n  return ranges;\r\n}\r\n","import PROGRAM from \"../ast/PROGRAM\";\r\nimport CREATE_DECK from \"../ast/CREATE_DECK\";\r\nimport CARD from \"../ast/CARD\";\r\n\r\nexport enum GuessType {\r\n  CreateDeck = \"create deck\",\r\n  CreateCard = \"create card\",\r\n  UpdateDeckName = \"update deck name\",\r\n  UpdateCardFront = \"update card front\",\r\n  UpdateCardBack = \"update card back\",\r\n  CopyPasteMultiDecks = \"copy paste multi decks\",\r\n  CopyPasteSingleDeck = \"copy paste single deck\",\r\n  Delete = \"deleted something\",\r\n  Nothing = \"nothing\",\r\n}\r\n\r\nexport type Guess =\r\n  | {\r\n      type: GuessType.CreateDeck;\r\n      deckName: string;\r\n    }\r\n  | {\r\n      type: GuessType.UpdateDeckName;\r\n      oldDeckName: string;\r\n      newDeckName: string;\r\n    }\r\n  | {\r\n      type: GuessType.CreateCard;\r\n      deckName: string;\r\n      front: string;\r\n      back: string;\r\n    }\r\n  | {\r\n      type: GuessType.UpdateCardFront;\r\n      deckName: string;\r\n      oldFront: string;\r\n      newFront: string;\r\n      back: string;\r\n    }\r\n  | {\r\n      type: GuessType.UpdateCardBack;\r\n      deckName: string;\r\n      front: string;\r\n      oldBack: string;\r\n      newBack: string;\r\n    }\r\n  | {\r\n      type:\r\n        | GuessType.CopyPasteMultiDecks // Massively create if doesn't exist\r\n        | GuessType.Nothing\r\n        | GuessType.Delete; // Do nothing\r\n    }\r\n  | {\r\n      type: GuessType.CopyPasteSingleDeck;\r\n      deckName: string;\r\n    };\r\n\r\nfunction guessNewDeck(oldDecks: CREATE_DECK[], newDecks: CREATE_DECK[]): Guess {\r\n  // we have more new decks than old decks\r\n  const oldDeckNames = {};\r\n  oldDecks.forEach((od) => {\r\n    oldDeckNames[od.name] = true;\r\n  });\r\n  const newDecksFound = [];\r\n  newDecks.forEach((nd, idx) => {\r\n    if (!oldDeckNames[nd.name]) {\r\n      newDecksFound.push({ name: nd.name, idx });\r\n    }\r\n  });\r\n  if (newDecksFound.length === 1) {\r\n    const { name, idx } = newDecksFound[0];\r\n    const hasCards = newDecks[idx].deck.cards?.length > 1;\r\n    if (!hasCards) {\r\n      return {\r\n        type: GuessType.CreateDeck,\r\n        deckName: name,\r\n      };\r\n    } else {\r\n      return {\r\n        // Gained some cards along with a new deck, so user must have copy pasted\r\n        type: GuessType.CopyPasteSingleDeck,\r\n        deckName: name,\r\n      };\r\n    }\r\n  }\r\n  // More than 1 new deck found\r\n\r\n  return {\r\n    type: GuessType.CopyPasteMultiDecks,\r\n  };\r\n}\r\n\r\n// list1 and list2 have the same number of elements\r\nfunction numberOfDifferingNames(\r\n  list1: CREATE_DECK[],\r\n  list2: CREATE_DECK[]\r\n): number {\r\n  return list1.reduce(\r\n    (acc, deck1, i) => (deck1.name !== list2[i].name ? acc + 1 : acc),\r\n    0\r\n  );\r\n}\r\n\r\nfunction haveSameCards(deck1: CREATE_DECK, deck2: CREATE_DECK): boolean {\r\n  if (deck1.deck?.cards?.length !== deck2.deck?.cards?.length) {\r\n    return false;\r\n  }\r\n  if (deck1.deck?.cards == null || deck2.deck?.cards == null) {\r\n    // only one is null or undefined so they are not the same deck\r\n    return false;\r\n  }\r\n\r\n  // same length and neither is null undefined, so check the cards\r\n  const cards1 = deck1.deck.cards;\r\n  const cards2 = deck2.deck.cards;\r\n  // attempt to find a difference\r\n  return !cards1.find((c1, idx) => {\r\n    const c2 = cards2[idx];\r\n    return (\r\n      c1.cardNumber !== c2.cardNumber ||\r\n      c1.front !== c2.front ||\r\n      c1.back !== c2.back\r\n    );\r\n  });\r\n}\r\n\r\nfunction guessPossiblyRenamedDeck(\r\n  oldDecks: CREATE_DECK[],\r\n  newDecks: CREATE_DECK[]\r\n): Guess {\r\n  // find index of deck with different name\r\n  let idx = 0;\r\n  while (idx < oldDecks.length) {\r\n    if (oldDecks[idx].name !== newDecks[idx].name) {\r\n      break;\r\n    }\r\n    ++idx;\r\n  }\r\n\r\n  // check if they have card differences\r\n  const od = oldDecks[idx];\r\n  const nd = newDecks[idx];\r\n\r\n  if (haveSameCards(od, nd)) {\r\n    return {\r\n      type: GuessType.UpdateDeckName,\r\n      oldDeckName: od.name,\r\n      newDeckName: nd.name,\r\n    };\r\n  } else {\r\n    return {\r\n      // A new deck was copypasted and an old one was deleted but we don't care about deletion\r\n      type: GuessType.CopyPasteSingleDeck,\r\n      deckName: nd.name,\r\n    };\r\n  }\r\n}\r\n\r\nfunction compareDeckLengths(oldDecks: CREATE_DECK[], newDecks: CREATE_DECK[]) {\r\n  let numDifferences = 0;\r\n  let firstDifference = undefined;\r\n  oldDecks.forEach((od, idx) => {\r\n    const nd = newDecks[idx];\r\n    if (od.deck?.cards?.length !== nd.deck?.cards?.length) {\r\n      ++numDifferences;\r\n      if (numDifferences === 1) {\r\n        firstDifference = idx;\r\n      }\r\n    }\r\n  });\r\n  return { numDifferences, firstDifference };\r\n}\r\n\r\nfunction guessNewCard(\r\n  oldCards: CARD[],\r\n  updatedCards: CARD[],\r\n  deckName: string\r\n): Guess {\r\n  const newCards: CARD[] = [];\r\n  for (let i = 0; i < oldCards.length; ++i) {\r\n    const { front, back } = oldCards[i];\r\n    const uc = updatedCards[i];\r\n    if (uc.front !== front || uc.back !== back) {\r\n      newCards.push(uc);\r\n    }\r\n  }\r\n\r\n  if (newCards.length === 0) {\r\n    const { front, back } = updatedCards[updatedCards.length - 1];\r\n    // the last card is the new card\r\n    return {\r\n      type: GuessType.CreateCard,\r\n      deckName,\r\n      front,\r\n      back,\r\n    };\r\n  }\r\n\r\n  if (newCards.length === 1) {\r\n    const { front, back } = newCards[0];\r\n    return {\r\n      type: GuessType.CreateCard,\r\n      deckName,\r\n      front,\r\n      back,\r\n    };\r\n  }\r\n\r\n  // More than 1\r\n  return {\r\n    type: GuessType.CopyPasteSingleDeck,\r\n    deckName,\r\n  };\r\n}\r\n\r\n// oldDeckCards and newDeckCards don't have the same length but may individually be null or undefined\r\nfunction guessCardActionInDeck(\r\n  oldDeck: CREATE_DECK,\r\n  newDeck: CREATE_DECK\r\n): Guess {\r\n  const oldDeckCards = oldDeck.deck?.cards;\r\n  const newDeckCards = newDeck.deck?.cards;\r\n  if (oldDeckCards == null) {\r\n    return {\r\n      type: GuessType.CopyPasteSingleDeck,\r\n      deckName: newDeck.name,\r\n    };\r\n  }\r\n  if (newDeckCards == null) {\r\n    return {\r\n      type: GuessType.Delete,\r\n    };\r\n  }\r\n  // both exist\r\n  if (oldDeckCards.length > newDeckCards.length) {\r\n    // Unhandled edge case: random copy paste, can change this to type: CopyPasteSingleDeck\r\n    return {\r\n      type: GuessType.Delete,\r\n    };\r\n  } else {\r\n    // newDeck has more cards\r\n    if (newDeckCards.length === oldDeckCards.length + 1) {\r\n      // exactly 1 new card. So compare the cards\r\n      return guessNewCard(oldDeckCards, newDeckCards, oldDeck.name);\r\n    } else {\r\n      // More than 1 card added, so it was a copy paste\r\n      return {\r\n        type: GuessType.CopyPasteSingleDeck,\r\n        deckName: newDeck.name,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nfunction guessCardUpdate(\r\n  oldDecks: CREATE_DECK[],\r\n  newDecks: CREATE_DECK[]\r\n): Guess {\r\n  let singleDifference: Guess = undefined; // stores the necessary information for a CRUD action\r\n  for (let i = 0; i < oldDecks.length; ++i) {\r\n    const oldCards = oldDecks[i].deck?.cards;\r\n    const newCards = newDecks[i].deck?.cards;\r\n    if (oldCards && newCards) {\r\n      for (let j = 0; j < oldCards.length; ++j) {\r\n        if (\r\n          oldCards[j].front === newCards[j].front &&\r\n          oldCards[j].back === newCards[j].back\r\n        ) {\r\n          continue;\r\n        }\r\n        if (\r\n          oldCards[j].front === newCards[j].front &&\r\n          oldCards[j].back !== newCards[j].back\r\n        ) {\r\n          if (singleDifference) {\r\n            // Found 2 differences -- guess a copy paste\r\n            return {\r\n              type: GuessType.CopyPasteMultiDecks,\r\n            };\r\n          }\r\n\r\n          singleDifference = {\r\n            type: GuessType.UpdateCardBack,\r\n            deckName: oldDecks[i].name,\r\n            front: oldCards[j].front,\r\n            oldBack: oldCards[j].back,\r\n            newBack: newCards[j].back,\r\n          };\r\n        } else if (\r\n          oldCards[j].front !== newCards[j].front &&\r\n          oldCards[j].back === newCards[j].back\r\n        ) {\r\n          if (singleDifference) {\r\n            // Found 2 differences -- guess a copy paste\r\n            return {\r\n              type: GuessType.CopyPasteMultiDecks,\r\n            };\r\n          }\r\n\r\n          singleDifference = {\r\n            type: GuessType.UpdateCardFront,\r\n            deckName: oldDecks[i].name,\r\n            oldFront: oldCards[j].front,\r\n            newFront: newCards[j].front,\r\n            back: oldCards[j].back,\r\n          };\r\n        } else {\r\n          // guess copy paste\r\n          return {\r\n            type: GuessType.CopyPasteMultiDecks,\r\n          };\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!singleDifference) {\r\n    // User did nothing special, the ASTs are the same\r\n    return {\r\n      type: GuessType.Nothing,\r\n    };\r\n  }\r\n\r\n  return singleDifference;\r\n}\r\n\r\nfunction guessCardAction(\r\n  oldDecks: CREATE_DECK[],\r\n  newDecks: CREATE_DECK[]\r\n): Guess {\r\n  const { numDifferences, firstDifference } = compareDeckLengths(\r\n    oldDecks,\r\n    newDecks\r\n  );\r\n  if (numDifferences > 1) {\r\n    return {\r\n      type: GuessType.CopyPasteMultiDecks,\r\n    };\r\n  }\r\n  if (numDifferences === 1) {\r\n    // Possible creation of new card\r\n    const oldDeck = oldDecks[firstDifference];\r\n    const newDeck = newDecks[firstDifference];\r\n    return guessCardActionInDeck(oldDeck, newDeck);\r\n  }\r\n\r\n  // The decks have same length, so find the single difference if there is one\r\n  return guessCardUpdate(oldDecks, newDecks);\r\n}\r\n\r\n/** Guess the user's CRUD action by comparing previous and current ASTs (`PROGRAM`)\r\n * - Allows DB to respond appropriately upon certain user actions in the editor such as a change in deck name,\r\n * which cannot be determined without analyzing the AST changes\r\n * - Worst case `O(c)` where `c` is the total number of cards\r\n * - `O(d)` where `d` is the total number of decks for cases where a deck has been renamed\r\n *\r\n * @param prev the previous `PROGRAM`\r\n * @param curr the newly parsed `PROGRAM` to reconcile against the previous\r\n * @returns a guess at what the user just did (change deck name, update card front, copy paste a chunk, etc),\r\n * containing enough information to appropriate CRUD commands (such as renaming deck rather than add all the\r\n * cards as new cards when no cards have changed)\r\n */\r\nexport default function guess(prev: PROGRAM, curr: PROGRAM): Guess {\r\n  const oldDecks = prev.create_decks;\r\n  const newDecks = curr.create_decks;\r\n  if (oldDecks.length > newDecks.length) {\r\n    return {\r\n      type: GuessType.Delete,\r\n    };\r\n  }\r\n  if (oldDecks.length < newDecks.length) {\r\n    if (oldDecks.length === newDecks.length - 1) {\r\n      return guessNewDeck(oldDecks, newDecks);\r\n    } else {\r\n      // More than 1 new deck\r\n      return {\r\n        type: GuessType.CopyPasteMultiDecks,\r\n      };\r\n    }\r\n  }\r\n\r\n  // equal deck counts\r\n  const differingNames = numberOfDifferingNames(oldDecks, newDecks);\r\n  if (differingNames > 1) {\r\n    return {\r\n      type: GuessType.CopyPasteMultiDecks,\r\n    };\r\n  }\r\n  if (differingNames === 1) {\r\n    return guessPossiblyRenamedDeck(oldDecks, newDecks);\r\n  }\r\n\r\n  // No difference in deck names, possibly CRUD on single card\r\n  return guessCardAction(oldDecks, newDecks);\r\n}\r\n","export enum TableName {\r\n  DECKS = \"decks\",\r\n  CARDS = \"cards\",\r\n  SESSIONS = \"sessions\",\r\n  SESSIONS_CARDS = \"sessions_cards\",\r\n  TAGS = \"tags\",\r\n  TAGS_CARDS = \"tags_cards\",\r\n}\r\n","import PROGRAM from \"../ast/PROGRAM\";\r\nimport guess, { GuessType, Guess } from \"./guesser\";\r\nimport { Database, Q } from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"../model/constants\";\r\nimport Deck from \"../model/Deck\";\r\nimport { debugDB } from \"./utils\";\r\nimport Card from \"../model/Card\";\r\nimport CREATE_DECK from \"../ast/CREATE_DECK\";\r\n\r\nasync function updateDeckName(oldName: string, newName: string, db: Database) {\r\n  debugDB(`Attempting to update deck name ${oldName} -> ${newName}`);\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n    await db.action(async () => {\r\n      const foundDecks = (await decks\r\n        .query(Q.where(\"name\", Q.eq(oldName)))\r\n        .fetch()) as Deck[];\r\n      if (foundDecks.length === 1) {\r\n        const oldDeck = foundDecks[0];\r\n        await oldDeck.update((deck) => {\r\n          deck.name = newName;\r\n        });\r\n        debugDB(`Success! Updated deck name ${oldName} -> ${newName}`);\r\n      } else {\r\n        throw new Error(\r\n          `reconciler::updateDeckName -- found ${foundDecks.length} decks with the name ${oldName}!`\r\n        );\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debugDB(err);\r\n  }\r\n}\r\n\r\nasync function createOrUpdateCard(guess: Guess, db: Database): Promise<void> {\r\n  if (\r\n    guess.type !== GuessType.UpdateCardFront &&\r\n    guess.type !== GuessType.UpdateCardBack &&\r\n    guess.type !== GuessType.CreateCard\r\n  ) {\r\n    debugDB(\"Unexpected input to reconciler::createOrUpdateCard\");\r\n    return;\r\n  }\r\n  debugDB(`Attempting to create or update card in deck ${guess.deckName}`);\r\n\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n\r\n    await db.action(async () => {\r\n      const foundDecks = (await decks\r\n        .query(Q.where(\"name\", Q.eq(guess.deckName)))\r\n        .fetch()) as Deck[];\r\n      if (foundDecks.length === 1) {\r\n        debugDB(`Corresponding deck found!`);\r\n        const deck = foundDecks[0];\r\n        if (guess.type === GuessType.CreateCard) {\r\n          debugDB(\r\n            `Attempting to add new card. Front: ${guess.front} | Back: ${guess.back}`\r\n          );\r\n          // https://nozbe.github.io/WatermelonDB/Actions.html#calling-actions-from-actions\r\n          await deck.subAction(() => deck.addCard(guess.front, guess.back));\r\n          debugDB(\r\n            `Successfully added card! Front: ${guess.front} | Back: ${guess.back}`\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Update card front or back\r\n        const cards = db.collections.get(TableName.CARDS);\r\n\r\n        if (guess.type === GuessType.UpdateCardFront) {\r\n          const cardsQ = cards.query(\r\n            Q.where(\"back\", Q.eq(guess.back)),\r\n            Q.where(\"front\", Q.eq(guess.oldFront)),\r\n            Q.where(\"deck_id\", Q.eq(deck.id))\r\n          );\r\n          const foundCards = (await cardsQ.fetch()) as Card[];\r\n          if (foundCards.length === 1) {\r\n            debugDB(`Corresponding card found!`);\r\n            const card = foundCards[0];\r\n            await card.update((card) => {\r\n              card.front = guess.newFront;\r\n            });\r\n            debugDB(`Successfully updated card front!`);\r\n          } else {\r\n            throw new Error(\r\n              `reconciler::createOrUpdateCard -- found ${foundCards.length} cards with the same deck, front and back when attempting to update card!`\r\n            );\r\n          }\r\n        } else if (guess.type === GuessType.UpdateCardBack) {\r\n          const cardsQ = cards.query(\r\n            Q.where(\"back\", Q.eq(guess.oldBack)),\r\n            Q.where(\"front\", Q.eq(guess.front)),\r\n            Q.where(\"deck_id\", Q.eq(deck.id))\r\n          );\r\n          const foundCards = (await cardsQ.fetch()) as Card[];\r\n          if (foundCards.length === 1) {\r\n            debugDB(`Corresponding card found!`);\r\n            const card = foundCards[0];\r\n            await card.update((card) => {\r\n              card.back = guess.newBack;\r\n            });\r\n            debugDB(`Successfully updated card back!`);\r\n          } else {\r\n            throw new Error(\r\n              `reconciler::createOrUpdateCard -- found ${foundCards.length} cards with the same deck, front and back when attempting to update card!`\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `reconciler::createOrUpdateCard -- found ${foundDecks.length} decks with the name ${guess.deckName}!`\r\n        );\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debugDB(\"createOrUpdateCard\", err);\r\n  }\r\n}\r\n\r\n// Note: handling GuessType.CreateDeck with createOrUpdateDeck instead\r\nasync function createDeck(deckName: string, db: Database): Promise<void> {\r\n  debugDB(`Attempting to create new deck: ${deckName}`);\r\n  debugDB(`Searching for existence of ${deckName}`);\r\n  // Check if there is a deck with this name\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n    await db.action(async () => {\r\n      const count = await decks\r\n        .query(Q.where(\"name\", Q.eq(deckName)))\r\n        .fetchCount();\r\n      if (count === 1) {\r\n        debugDB(`DB already has this deck, so not going to add it`);\r\n        return;\r\n      }\r\n      if (count > 1) {\r\n        debugDB(`DB has ${count} decks with this name already`);\r\n        return;\r\n      }\r\n      debugDB(`Found 0 decks with this name.`);\r\n      await decks.create((deck: Deck) => {\r\n        deck.name = deckName;\r\n      });\r\n      debugDB(`Successfully created new deck: ${deckName}!`);\r\n    });\r\n  } catch (err) {\r\n    debugDB(\"createDeck\", err);\r\n  }\r\n}\r\n\r\nasync function createOrUpdateEntireDeck(createDeck: CREATE_DECK, db: Database) {\r\n  const name = createDeck.name;\r\n  const cards = createDeck.deck?.cards;\r\n  debugDB(`Reconciling entire deck ${name} with DB...`);\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n    await db.action(async () => {\r\n      const foundDecks = (await decks\r\n        .query(Q.where(\"name\", Q.eq(name)))\r\n        .fetch()) as Deck[];\r\n      if (foundDecks.length === 0) {\r\n        debugDB(`DB has no deck with this name. Creating...`);\r\n        const newDeck = (await decks.create((deck: Deck) => {\r\n          deck.name = name;\r\n        })) as Deck;\r\n        debugDB(`Created!`);\r\n        if (cards) {\r\n          for (const card of cards) {\r\n            debugDB(\r\n              `Creating new card (Front: ${card.front}, Back: ${card.back})`\r\n            );\r\n            // https://nozbe.github.io/WatermelonDB/Actions.html#calling-actions-from-actions\r\n            await newDeck.subAction(() =>\r\n              newDeck.addCard(card.front, card.back)\r\n            );\r\n          }\r\n          debugDB(`Finished adding its cards to the DB!`);\r\n        }\r\n        debugDB(`Done adding deck ${name} to the DB!`);\r\n        return;\r\n      }\r\n      if (foundDecks.length === 1) {\r\n        debugDB(\r\n          `Found 1 deck with this name already in the DB. Reconciling its cards now...`\r\n        );\r\n        const deck = foundDecks[0];\r\n        if (cards) {\r\n          const cardsCollection = db.collections.get(TableName.CARDS);\r\n          for (const card of cards) {\r\n            // Look for an identical card in the deck\r\n            debugDB(\r\n              `Looking for card in deck (Front: ${card.front}, Back: ${card.back})`\r\n            );\r\n            const cardsQ = cardsCollection.query(\r\n              Q.where(\"deck_id\", Q.eq(deck.id)),\r\n              Q.where(\"front\", Q.eq(card.front)),\r\n              Q.where(\"back\", Q.eq(card.back))\r\n            );\r\n            const count = await cardsQ.fetchCount();\r\n            if (count === 1) {\r\n              debugDB(\r\n                `Card already exists in deck (Front: ${card.front}, Back: ${card.back})`\r\n              );\r\n              continue;\r\n            }\r\n            if (count > 1) {\r\n              debugDB(\r\n                `Unexpected: ${count} copies of card exists in deck (Front: ${card.front}, Back: ${card.back})`\r\n              );\r\n              continue;\r\n            }\r\n            // Look for a card in deck with the same front\r\n            debugDB(`Not found. Looking for card with just same front...`);\r\n            const cardFrontQ = cardsCollection.query(\r\n              Q.where(\"deck_id\", Q.eq(deck.id)),\r\n              Q.where(\"front\", Q.eq(card.front))\r\n            );\r\n            const cardsWithSameFront = await cardFrontQ.fetch();\r\n            if (cardsWithSameFront.length === 0) {\r\n              // Look for a card in deck with the same back\r\n              debugDB(`Not found. Looking for card with same back...`);\r\n              const cardBackQ = cardsCollection.query(\r\n                Q.where(\"deck_id\", Q.eq(deck.id)),\r\n                Q.where(\"back\", Q.eq(card.back))\r\n              );\r\n              const cardsWithSameBack = await cardBackQ.fetch();\r\n              if (cardsWithSameBack.length === 0) {\r\n                // Create a new card\r\n                debugDB(\r\n                  `Creating new card (Front: ${card.front}, Back: ${card.back})`\r\n                );\r\n                await deck.subAction(() => deck.addCard(card.front, card.back));\r\n                debugDB(`Done creating new card.`);\r\n                continue;\r\n              }\r\n              if (cardsWithSameBack.length === 1) {\r\n                // Update its front\r\n                const cardToUpdate = cardsWithSameBack[0];\r\n                debugDB(\r\n                  `Found a single card with matching back, so updating front.`\r\n                );\r\n                await cardToUpdate.update((c: Card) => {\r\n                  c.front = card.front;\r\n                });\r\n                debugDB(`Done updating front of card.`);\r\n                continue;\r\n              }\r\n              if (cardsWithSameBack.length > 1) {\r\n                debugDB(\r\n                  `Unexpected: found ${cardsWithSameBack.length} cards in deck have the same back (${card.back})`\r\n                );\r\n                continue;\r\n              }\r\n            }\r\n            if (cardsWithSameFront.length === 1) {\r\n              // Update its back\r\n              const cardToUpdate = cardsWithSameFront[0];\r\n              debugDB(\r\n                `Found a single card with matching front, so updating back.`\r\n              );\r\n              await cardToUpdate.update((c: Card) => {\r\n                c.back = card.back;\r\n              });\r\n              debugDB(`Done updating back of card.`);\r\n              continue;\r\n            }\r\n            if (cardsWithSameFront.length > 1) {\r\n              debugDB(\r\n                `Unexpected: found ${cardsWithSameFront.length} cards in deck have the same front (${card.front})`\r\n              );\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error(`Found ${foundDecks.length} decks with the same name,`);\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debugDB(\"createOrUpdateEntireDeck Error: \", err);\r\n  }\r\n}\r\n\r\nexport async function createOrUpdateAllDecks(program: PROGRAM, db: Database) {\r\n  debugDB(\"Beginning to process what is guessed to be a multi-deck copy paste\");\r\n  try {\r\n    for (const cd of program.create_decks) {\r\n      await createOrUpdateEntireDeck(cd, db);\r\n    }\r\n    debugDB(\r\n      \"Finished processing what is guessed to be a multi-deck copy paste!\"\r\n    );\r\n  } catch (err) {\r\n    debugDB(\"createOrUpdateAllDecks Error: \", err);\r\n  }\r\n}\r\n\r\n/** Reconciles the newly parsed AST with the DB\r\n * - Takes the previous and current AST and issues background CRUD actions\r\n * - Enables preservation of stats during minor card or deck modifications\r\n *\r\n * @param prev the old AST, which should already be in the DB\r\n * @param curr the newly parsed AST\r\n * @param db WatermelonDB instance\r\n */\r\nexport default async function reconcile(\r\n  prev: PROGRAM,\r\n  curr: PROGRAM,\r\n  db: Database\r\n): Promise<void> {\r\n  const guessedAction = guess(prev, curr);\r\n  debugDB(\"Guessed action:\", guessedAction);\r\n\r\n  switch (guessedAction.type) {\r\n    case GuessType.Nothing:\r\n    case GuessType.Delete:\r\n      return;\r\n    case GuessType.UpdateDeckName:\r\n      const { oldDeckName, newDeckName } = guessedAction;\r\n      await updateDeckName(oldDeckName, newDeckName, db);\r\n      return;\r\n    case GuessType.UpdateCardFront:\r\n    case GuessType.UpdateCardBack:\r\n    case GuessType.CreateCard:\r\n      await createOrUpdateCard(guessedAction, db);\r\n      return;\r\n    case GuessType.CopyPasteSingleDeck:\r\n    case GuessType.CreateDeck:\r\n      const { deckName } = guessedAction;\r\n      const deck = curr.create_decks.find((cd) => cd.name === deckName);\r\n      await createOrUpdateEntireDeck(deck, db);\r\n      return;\r\n    case GuessType.CopyPasteMultiDecks:\r\n      await createOrUpdateAllDecks(curr, db);\r\n      return;\r\n  }\r\n}\r\n","import Tokenizer from \"./tokenizer\";\r\nimport { deckCreationLiterals } from \"./constants\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\n\r\n// Local storage keys\r\nexport const astStrKey = \"programAST\";\r\nexport const cardEditorStrKey = \"cardEditorStrKey\";\r\n\r\n// Change here to\r\nconst defaultText = `Create Deck Practice Final:\r\n(1) Foo : Bar\r\n(2) Bill : Gates\r\n(3) Steve : Jobs\r\n(4) Justin : Trudeau \r\n(5) Evan : You\r\n`;\r\n\r\ntype InitialData = {\r\n  isFirstTimeUser: boolean;\r\n  initialText: string;\r\n  initialProgram: PROGRAM;\r\n};\r\n\r\n/**\r\n * @returns initial data for the card editor\r\n */\r\nexport function getInitialData(): InitialData {\r\n  const savedText = localStorage.getItem(cardEditorStrKey);\r\n  const lastAstJsonStr = localStorage.getItem(astStrKey);\r\n  if (savedText) {\r\n    return {\r\n      isFirstTimeUser: false,\r\n      initialText: savedText,\r\n      initialProgram: JSON.parse(lastAstJsonStr),\r\n    };\r\n  } else {\r\n    // Parse the example into an AST\r\n    Tokenizer.makeTokenizer(defaultText, deckCreationLiterals);\r\n    const program = new PROGRAM();\r\n    program.parse();\r\n    localStorage.setItem(cardEditorStrKey, defaultText);\r\n    localStorage.setItem(astStrKey, JSON.stringify(program));\r\n    return {\r\n      isFirstTimeUser: true,\r\n      initialText: defaultText,\r\n      initialProgram: program,\r\n    };\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport Snackbar, { SnackbarOrigin } from \"@material-ui/core/Snackbar\";\r\nimport MuiAlert, { AlertProps, Color } from \"@material-ui/lab/Alert\";\r\nimport { makeStyles, Theme } from \"@material-ui/core/styles\";\r\n\r\nfunction Alert(props: AlertProps) {\r\n  return <MuiAlert elevation={6} variant=\"filled\" {...props} />;\r\n}\r\nexport interface State extends SnackbarOrigin {\r\n  open: boolean;\r\n}\r\n\r\nconst useStyles = makeStyles((theme: Theme) => ({\r\n  root: {\r\n    width: \"100%\",\r\n    \"& > * + *\": {\r\n      marginTop: theme.spacing(2),\r\n    },\r\n  },\r\n}));\r\n\r\ntype Props = {\r\n  message: string;\r\n  severity?: Color;\r\n};\r\n\r\nexport default function ErrorMessage({ message, severity }: Props) {\r\n  const classes = useStyles();\r\n  const [state, setState] = React.useState<State>({\r\n    open: true,\r\n    vertical: \"top\",\r\n    horizontal: \"center\",\r\n  });\r\n  const { vertical, horizontal, open } = state;\r\n  const handleClose = () => {\r\n    setState({ ...state, open: false });\r\n  };\r\n\r\n  if (!severity) {\r\n    // error by default\r\n    severity = \"error\";\r\n  }\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <Snackbar\r\n        anchorOrigin={{ vertical, horizontal }}\r\n        open={open}\r\n        onClose={handleClose}\r\n      >\r\n        <Alert onClose={handleClose} severity={severity}>\r\n          {message}\r\n        </Alert>\r\n      </Snackbar>\r\n    </div>\r\n  );\r\n}\r\n","import React, { useState } from \"react\";\r\nimport \"codemirror/lib/codemirror.css\";\r\nimport \"codemirror/theme/ayu-mirage.css\";\r\nimport \"codemirror/mode/xml/xml\";\r\nimport { UnControlled as CodeMirror } from \"react-codemirror2\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\nimport Tokenizer from \"../lib/tokenizer\";\r\nimport { deckCreationLiterals } from \"../lib/constants\";\r\nimport { highlight } from \"../lib/highlighter\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\nimport reconcile from \"../lib/reconciler\";\r\nimport { debug, debugDB } from \"../lib/utils\";\r\nimport { astStrKey, cardEditorStrKey } from \"../lib/getIintialData\";\r\nimport { Action, ActionType } from \"../App\";\r\nimport ErrorMessage from \"./ErrorMessage\";\r\nimport { Color } from \"@material-ui/lab/Alert\";\r\n\r\nconst inputProcessLocalStorageKey = \"CARD_EDITOR_LAST_UPDATED\";\r\nconst inputProcessDelayMillis = 2000;\r\n\r\n// for syntax highlighting\r\nconst literals = [\r\n  \"create deck\",\r\n  \"(\",\r\n  \":\",\r\n  \")\",\r\n  \"add\",\r\n  \"tags\",\r\n  \"color\",\r\n  \"direction\",\r\n  \"alignment\",\r\n];\r\ntype Props = {\r\n  dispatch: React.Dispatch<Action>;\r\n  initialText: string;\r\n  isInSession: boolean;\r\n  program: PROGRAM;\r\n};\r\n\r\nconst debounceMillis = 5000; // for snackbar message\r\n\r\nfunction enoughTimeHasPassedSince(thenUnix: number): boolean {\r\n  return Date.now() - thenUnix > debounceMillis;\r\n}\r\n\r\nconst successMessage = \"Hooray!\";\r\n\r\ntype SnackbarState =\r\n  | {\r\n      open: false;\r\n      lastOpenedUnix: number;\r\n    }\r\n  | {\r\n      open: true;\r\n      severity: Color;\r\n      message: string;\r\n      lastOpenedUnix: number;\r\n    };\r\n\r\nfunction flipSnackbarState(\r\n  setState: React.Dispatch<React.SetStateAction<SnackbarState>>,\r\n  message: string,\r\n  severity: Color\r\n) {\r\n  const lastOpenedUnix = Date.now();\r\n  setState({\r\n    open: false,\r\n    lastOpenedUnix,\r\n  });\r\n  setState({\r\n    open: true,\r\n    lastOpenedUnix,\r\n    message,\r\n    severity,\r\n  });\r\n}\r\n\r\nfunction handleSnackbar(\r\n  state: SnackbarState,\r\n  setState: React.Dispatch<React.SetStateAction<SnackbarState>>,\r\n  message: string,\r\n  severity: Color\r\n) {\r\n  if (enoughTimeHasPassedSince(state.lastOpenedUnix)) {\r\n    flipSnackbarState(setState, message, severity);\r\n  }\r\n}\r\n\r\nexport default function CardEditor(props: Props) {\r\n  const db = useDatabase();\r\n\r\n  const [snackbarState, setSnackbarState] = useState<SnackbarState>({\r\n    open: false,\r\n    lastOpenedUnix: 0,\r\n  });\r\n\r\n  const { initialText, isInSession } = props;\r\n\r\n  function processInput(value: string) {\r\n    localStorage.setItem(cardEditorStrKey, value);\r\n    // Parse it\r\n    try {\r\n      Tokenizer.makeTokenizer(value, deckCreationLiterals);\r\n      const program = new PROGRAM();\r\n      program.parse();\r\n      // Check if the last deck in the program is null\r\n      if (\r\n        program.create_decks.length !== 0 &&\r\n        program.create_decks[program.create_decks.length - 1].deck === null\r\n      ) {\r\n        debug(\"last deck is null, not sending dispatch\");\r\n\r\n        handleSnackbar(\r\n          snackbarState,\r\n          setSnackbarState,\r\n          \"Add some cards to your deck like this: '(1) front : back'\",\r\n          \"info\"\r\n        );\r\n      } else {\r\n        if (snackbarState.open && snackbarState.severity !== \"success\") {\r\n          setSnackbarState({\r\n            lastOpenedUnix: Date.now(),\r\n            message: successMessage,\r\n            severity: \"success\",\r\n            open: true,\r\n          });\r\n        } else {\r\n          handleSnackbar(\r\n            snackbarState,\r\n            setSnackbarState,\r\n            successMessage,\r\n            \"success\"\r\n          );\r\n        }\r\n        localStorage.setItem(astStrKey, JSON.stringify(program));\r\n        // Trigger background reconciliation with DB\r\n        reconcile(props.program, program, db)\r\n          .then(() => debugDB(\"Background DB update complete!\"))\r\n          .catch((err) => debugDB(\"Error during reconciliation!\", err));\r\n        props.dispatch({ type: ActionType.CardEditorParseSuccess, program });\r\n      }\r\n    } catch (err) {\r\n      debug(err);\r\n      handleSnackbar(\r\n        snackbarState,\r\n        setSnackbarState,\r\n        \"Double check your input! Perhaps you're missing a colon (:)\",\r\n        \"info\"\r\n      );\r\n    }\r\n  }\r\n\r\n  const handleChange = (editor: CodeMirror.Editor, data, value) => {\r\n    highlight(editor, literals);\r\n\r\n    // Change it after a delay, but cancel previously queued changes\r\n    const nowUnix = Date.now();\r\n    localStorage.setItem(inputProcessLocalStorageKey, nowUnix.toString());\r\n    setTimeout(() => {\r\n      console.log(\"marco\");\r\n      const lastChange = localStorage.getItem(inputProcessLocalStorageKey);\r\n      if (nowUnix.toString() === lastChange) {\r\n        console.log(\"polo\");\r\n        processInput(value);\r\n      }\r\n    }, inputProcessDelayMillis);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"card-editor\">\r\n        {isInSession ? (\r\n          <div className=\"card-editor-codemirror card-hider\">{initialText}</div>\r\n        ) : (\r\n          <CodeMirror\r\n            value={initialText}\r\n            options={{\r\n              mode: \"xml\",\r\n              theme: \"ayu-mirage\",\r\n              lineNumbers: true,\r\n            }}\r\n            editorDidMount={(editor, value) => {\r\n              highlight(editor, literals);\r\n              props.dispatch({\r\n                type: ActionType.SetCardEditor,\r\n                cardEditor: editor,\r\n              });\r\n            }}\r\n            onChange={handleChange}\r\n            className=\"card-editor-codemirror\"\r\n          />\r\n        )}\r\n      </div>\r\n      {snackbarState.open && (\r\n        <ErrorMessage\r\n          message={snackbarState.message}\r\n          severity={snackbarState.severity}\r\n        ></ErrorMessage>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n","import NODE from \"./NODE\";\r\nimport TAGS from \"./TAGS\";\r\nimport DECKS from \"./DECKS\";\r\nimport SESSIONS from \"./SESSIONS\";\r\n\r\nexport enum SubjectType {\r\n  Decks = \"decks\",\r\n  Sessions = \"sessions\",\r\n  Tags = \"tags\", // not supported yet\r\n  Undefined = \"undefined\",\r\n}\r\n\r\nexport default class SUBJECT extends NODE {\r\n  subject: TAGS | DECKS | SESSIONS | null = null;\r\n  subjectType: SubjectType = SubjectType.Undefined;\r\n\r\n  parse() {\r\n    const nextToken = this.tokenizer.checkNext();\r\n    if (nextToken === \"past sessions\") {\r\n      this.subject = new SESSIONS();\r\n      this.subjectType = SubjectType.Sessions;\r\n    } else if (nextToken === \"decks:\") {\r\n      this.subject = new DECKS();\r\n      this.subjectType = SubjectType.Decks;\r\n    } else if (nextToken === \"tags:\") {\r\n      this.subject = new TAGS();\r\n      this.subjectType = SubjectType.Tags;\r\n    } else {\r\n      throw new Error(\r\n        \"Invalid Subject, must be 'Decks:', 'Tags:', or 'Past Sessions'\"\r\n      );\r\n    }\r\n    this.subject.parseInteractivePrompt();\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class DECKS extends NODE {\r\n  decks: string[] = [];\r\n  type = \"decks\";\r\n\r\n  parseInteractivePrompt() {\r\n    this.tokenizer.getAndCheckToken(\"decks:\");\r\n    while (this.tokenizer.moreTokens()) {\r\n      this.decks.push(this.tokenizer.getNext());\r\n      if (this.tokenizer.checkNext() === \",\") {\r\n        this.tokenizer.getNext();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class SESSIONS extends NODE {\r\n  type = \"sessions\";\r\n  parseInteractivePrompt() {\r\n    this.tokenizer.getAndCheckToken(\"past sessions\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport * as constants from \"../lib/constants\";\r\n\r\nexport default class SUBJECT_MODIFIER extends NODE {\r\n  type: string = \"\";\r\n  filter: string = \"newest\";\r\n  limit: number = 100;\r\n  selectCards: boolean = false;\r\n\r\n  parse() {\r\n    const actionToken = this.tokenizer.getNext();\r\n    if (actionToken === \"show stats for\") {\r\n      this.type = \"show stats\";\r\n    } else if (actionToken === \"start session from\") {\r\n      this.type = \"start session\";\r\n    } else {\r\n      throw new Error(\r\n        \"Command must either start with 'Show stats for' or 'Start Session from'\"\r\n      );\r\n    }\r\n    let nextToken = this.tokenizer.checkNext();\r\n    if (!isNaN(Number(nextToken))) {\r\n      this.limit = Math.round(Number(this.tokenizer.getNext()));\r\n      nextToken = this.tokenizer.checkNext();\r\n    }\r\n    if (constants.validCardFilter.includes(nextToken)) {\r\n      this.filter = this.tokenizer.getNext();\r\n      nextToken = this.tokenizer.checkNext();\r\n    }\r\n    if (nextToken === \"cards from\") {\r\n      this.selectCards = true;\r\n      this.tokenizer.getNext();\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport SUBJECT from \"./SUBJECT\";\r\nimport SUBJECT_MODIFIER from \"./SUBJECT_MODIFIER\";\r\n\r\nexport default class COMPLEX_COMMAND extends NODE {\r\n  subjectModfier: SUBJECT_MODIFIER | null = null;\r\n  subject: SUBJECT | null = null;\r\n  parse() {\r\n    this.subjectModfier = new SUBJECT_MODIFIER();\r\n    this.subjectModfier.parse();\r\n\r\n    this.subject = new SUBJECT();\r\n    this.subject.parse();\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class HELP extends NODE {\r\n  type: string = \"\";\r\n  parse() {\r\n    this.type = \"help\";\r\n    this.tokenizer.getAndCheckToken(\"help\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class LIST extends NODE {\r\n  option: string = \"\";\r\n\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"list\");\r\n    this.option = this.tokenizer.getNext();\r\n    if (this.option !== \"tags\" && this.option !== \"decks\") {\r\n      throw new Error(\"Invalid list option\");\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class EXPORT_DECKS extends NODE {\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"export decks\");\r\n  }\r\n\r\n  evaluate() {\r\n    const dataString = localStorage.getItem(\"cardEditorStrKey\");\r\n    let fakeAnchor = document.createElement(\"a\");\r\n    fakeAnchor.href =\r\n      \"data:text/plain;charset=utf-8,\" + encodeURIComponent(dataString);\r\n    fakeAnchor.download = `${new Date().toISOString()}.txt`;\r\n    fakeAnchor.click();\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class LOAD_DECKS extends NODE {\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"load decks\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class QUIT_TO_HOME extends NODE {\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"^quit$|^back to home$\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport COMPLEX_COMMAND from \"./COMPLEX_COMMAND\";\r\nimport HELP from \"./HELP\";\r\nimport LIST from \"./LIST\";\r\nimport EXPORT_DECKS from \"./EXPORT_DECKS\";\r\nimport LOAD_DECKS from \"./LOAD_DECKS\";\r\nimport QUIT_TO_HOME from \"./QUIT_TO_HOME\";\r\n\r\nexport default class COMMAND extends NODE {\r\n  type: string = \"\";\r\n  command:\r\n    | COMPLEX_COMMAND\r\n    | HELP\r\n    | LIST\r\n    | EXPORT_DECKS\r\n    | LOAD_DECKS\r\n    | QUIT_TO_HOME\r\n    | null = null;\r\n\r\n  parse() {\r\n    const nextToken = this.tokenizer.checkNext();\r\n    if (nextToken === \"help\") {\r\n      this.command = new HELP();\r\n      this.type = \"help\";\r\n    } else if (nextToken === \"list\") {\r\n      this.command = new LIST();\r\n      this.type = \"list\";\r\n    } else if (nextToken === \"export decks\") {\r\n      this.command = new EXPORT_DECKS();\r\n      this.type = \"export decks\";\r\n    } else if (nextToken === \"load decks\") {\r\n      this.command = new LOAD_DECKS();\r\n      this.type = \"load decks\";\r\n    } else if (nextToken === \"quit\" || nextToken === \"back to home\") {\r\n      this.command = new QUIT_TO_HOME();\r\n      this.type = \"quit to home\";\r\n    } else {\r\n      this.command = new COMPLEX_COMMAND();\r\n      this.type = \"complex command\";\r\n    }\r\n    if (this.command === null) {\r\n      throw new Error(\"Invalid command specified\");\r\n    }\r\n    this.command.parse();\r\n  }\r\n\r\n  evaluate() {\r\n    this.command.evaluate();\r\n  }\r\n}\r\n","import React, { useState } from \"react\";\r\nimport { highlight } from \"../lib/highlighter\";\r\nimport \"codemirror/lib/codemirror.css\";\r\nimport \"codemirror/theme/yonce.css\";\r\nimport { UnControlled as CodeMirror } from \"react-codemirror2\";\r\nimport Tokenizer from \"../lib/tokenizer\";\r\nimport { allTokens as literals } from \"../lib/constants\";\r\nimport COMMAND from \"../ast/COMMAND\";\r\nimport COMPLEX_COMMAND from \"../ast/COMPLEX_COMMAND\";\r\nimport { Snackbar, IconButton } from \"@material-ui/core\";\r\nimport CloseIcon from \"@material-ui/icons/Close\";\r\nimport SUBJECT_MODIFIER from \"../ast/SUBJECT_MODIFIER\";\r\nimport DECKS from \"../ast/DECKS\";\r\nimport { Action, ActionType } from \"../App\";\r\nimport { SubjectType as Subject } from \"../ast/SUBJECT\";\r\nimport LIST from \"../ast/LIST\";\r\nimport { Filter } from \"../model/query\";\r\nimport TAGS from \"../ast/TAGS\";\r\n\r\nconst helpMsg = (\r\n  <div\r\n    style={{\r\n      fontSize: \"13px\",\r\n      lineHeight: \"15px\",\r\n    }}\r\n  >\r\n    <h4>To start a session from decks, tags or past sessions:</h4>\r\n    Enter “start session from [enter a number][choose one of ”best\" | \"worst\" |\r\n    \"random\" | \"oldest\" | \"newest\" ] cards from [“decks” | “tags” | “past\r\n    sessions”]: [enter a list of deck or tag names]” <br></br>Or “start session\r\n    from [enter a number][choose one of ”best\" | \"worst\" | \"random\" | \"oldest\" |\r\n    \"newest\" ] decks: [enter a list of deck names]”\r\n    <h4>To show stats from decks, tags or past sessions:</h4>\r\n    Enter “show stats for [enter a number][choose one of ”best\" | \"worst\" |\r\n    \"random\" | \"oldest\" | \"newest\" ] cards from [“decks” | “tags” | “past\r\n    sessions”]: [enter a list of deck or tag names]” <br></br>Or “show stats for\r\n    [enter a number][choose one of ”best\" | \"worst\" | \"random\" | \"oldest\" |\r\n    \"newest\" ] decks: [enter a list of deck names]”\r\n    <h4>To download your decks:</h4> Enter 'export decks'\r\n    <h4>To load decks from your computer:</h4> Enter 'load decks'\r\n    <h4>To go back to Home:</h4> Enter 'quit' or 'back to home'\r\n  </div>\r\n);\r\n\r\ntype Props = { dispatch: React.Dispatch<Action> };\r\n\r\nlet startSessionOrStats: string = \"\";\r\nfunction isStartSessionOrShowStats(command: COMMAND): boolean {\r\n  if (\r\n    ((command.command as COMPLEX_COMMAND).subjectModfier as SUBJECT_MODIFIER)\r\n      .type === \"start session\"\r\n  ) {\r\n    startSessionOrStats = \"start session\";\r\n    return true;\r\n  } else if (\r\n    ((command.command as COMPLEX_COMMAND).subjectModfier as SUBJECT_MODIFIER)\r\n      .type === \"show stats\"\r\n  ) {\r\n    startSessionOrStats = \"show stats\";\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction userMadeInvalidChange(\r\n  oldLines: string[],\r\n  newLines: string[]\r\n): boolean {\r\n  if (\r\n    newLines.length < oldLines.length ||\r\n    newLines.length > oldLines.length + 1\r\n  ) {\r\n    // User changed something they're not supposed to\r\n    return true;\r\n  }\r\n  for (let i = 0; i < oldLines.length - 1; ++i) {\r\n    if (oldLines[i] !== newLines[i]) {\r\n      return true;\r\n    }\r\n  }\r\n  // Ensure latest line starts with indicator \"> \"\r\n  if (newLines.length > oldLines.length) {\r\n    return newLines[newLines.length - 1] !== \"\";\r\n  } else {\r\n    return !newLines[newLines.length - 1].startsWith(\"> \");\r\n  }\r\n}\r\n\r\nfunction revertChange(\r\n  editor: CodeMirror.Editor,\r\n  oldValue: string,\r\n  position: CodeMirror.Position\r\n) {\r\n  console.log(\"reverting change\");\r\n  // Set the lines in the editor\r\n  editor.getDoc().setValue(oldValue);\r\n  editor.getDoc().setCursor(position);\r\n}\r\n\r\nexport default function CommandEditor(props: Props) {\r\n  const [openHelp, setOpenHelp] = useState(false);\r\n  const [{ text, lines }, setEditorState] = useState({\r\n    text: \"> \",\r\n    lines: [\"> \"],\r\n  });\r\n\r\n  const handleCloseHelp = (\r\n    event: React.SyntheticEvent | React.MouseEvent,\r\n    reason?: string\r\n  ) => {\r\n    if (reason === \"clickaway\") {\r\n      return;\r\n    }\r\n\r\n    setOpenHelp(false);\r\n  };\r\n\r\n  const handleCommandChange = (\r\n    editor: CodeMirror.Editor,\r\n    data,\r\n    value: string\r\n  ) => {\r\n    const newLines = value.split(\"\\n\");\r\n\r\n    if (userMadeInvalidChange(lines, newLines)) {\r\n      console.log(\"invalid.\");\r\n      // Revert the user's change in the editor\r\n      revertChange(editor, text, {\r\n        line: lines.length - 1,\r\n        ch: lines[lines.length - 1].length,\r\n      });\r\n      return;\r\n    }\r\n\r\n    highlight(editor, literals);\r\n\r\n    console.log(value);\r\n    console.table(newLines);\r\n\r\n    if (value.endsWith(\"\\n\")) {\r\n      console.log(\"last line ended with newline\");\r\n      const newValue = value + \"> \";\r\n      setEditorState({\r\n        text: newValue,\r\n        lines: newValue.split(\"\\n\"),\r\n      });\r\n      editor.getDoc().setValue(newValue);\r\n      editor.getDoc().setCursor({ line: newLines.length - 1, ch: 2 });\r\n\r\n      const valueToParse = newLines[newLines.length - 2].substr(2);\r\n      console.log(\"value to parse: \", valueToParse);\r\n\r\n      let isHelpCommand = false;\r\n      //after user hits enter, reset the cursor\r\n      // Parse the value\r\n      try {\r\n        Tokenizer.makeTokenizer(valueToParse, literals);\r\n        const command = new COMMAND();\r\n        command.parse(); //commands = COMPLEX_COMMAND | HELP | LIST\r\n        console.log(command.command);\r\n        if (command.type === \"list\") {\r\n          const listNode = command.command as LIST;\r\n          if (listNode.option === \"decks\") {\r\n            props.dispatch({ type: ActionType.List, listOption: \"decks\" });\r\n          } else if (listNode.option === \"tags\") {\r\n            props.dispatch({ type: ActionType.List, listOption: \"tags\" }); // not implemented\r\n          } else {\r\n            console.log(\"Unexpected list option: \", listNode.option);\r\n          }\r\n        } else if (command.type === \"help\") {\r\n          isHelpCommand = true;\r\n        } else if (command.type === \"export decks\") {\r\n          command.evaluate();\r\n        } else if (command.type === \"quit to home\") {\r\n          props.dispatch({ type: ActionType.QuitToHome });\r\n        } else if (command.type === \"load decks\") {\r\n          const fakeInput = document.createElement(\"input\");\r\n          fakeInput.type = \"file\";\r\n\r\n          fakeInput.onchange = (e: any) => {\r\n            const file = e.target.files[0];\r\n            const fileReader = new FileReader();\r\n            fileReader.readAsText(file, \"UTF-8\");\r\n\r\n            fileReader.onload = (e) => {\r\n              const deckCreationDSL = e.target.result as string;\r\n              props.dispatch({\r\n                type: ActionType.LoadDecks,\r\n                createDSLValue: deckCreationDSL,\r\n              });\r\n            };\r\n          };\r\n          fakeInput.click();\r\n        } else if (isStartSessionOrShowStats(command)) {\r\n          const modifier = (command.command as COMPLEX_COMMAND)\r\n            .subjectModfier as SUBJECT_MODIFIER;\r\n          if (modifier) {\r\n            const isTagsSubject =\r\n              (command.command as COMPLEX_COMMAND).subject.subjectType ===\r\n              \"tags\";\r\n            props.dispatch({\r\n              type:\r\n                startSessionOrStats === \"start session\"\r\n                  ? ActionType.StartSession\r\n                  : ActionType.ShowStats,\r\n              limit: modifier.limit,\r\n              filter: modifier.filter as Filter,\r\n              isLimitAppliedToCards: modifier.selectCards,\r\n              deckNames:\r\n                !isTagsSubject &&\r\n                ((command.command as COMPLEX_COMMAND).subject.subject as DECKS)\r\n                  .decks,\r\n              subject: (command.command as COMPLEX_COMMAND).subject.subjectType,\r\n              tagNames:\r\n                isTagsSubject &&\r\n                ((command.command as COMPLEX_COMMAND).subject\r\n                  .subject as TAGS).tags.map((t) => t.tagName),\r\n            });\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.log(err);\r\n        props.dispatch({\r\n          type: ActionType.CommandNotFound,\r\n        });\r\n      }\r\n      if (isHelpCommand) {\r\n        setOpenHelp(true);\r\n      }\r\n      // editor.getDoc().setValue(\"> \");\r\n      // editor.getDoc().setCursor(2);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"command-editor\">\r\n        <CodeMirror\r\n          value={\"> Help\"}\r\n          options={{\r\n            mode: \"xml\",\r\n            theme: \"yonce\",\r\n            lineNumbers: true,\r\n          }}\r\n          editorDidMount={(editor, value) => {\r\n            highlight(editor, literals);\r\n          }}\r\n          onChange={handleCommandChange}\r\n        />\r\n      </div>\r\n      <Snackbar\r\n        anchorOrigin={{\r\n          vertical: \"bottom\",\r\n          horizontal: \"right\",\r\n        }}\r\n        open={openHelp}\r\n        autoHideDuration={180000}\r\n        onClose={handleCloseHelp}\r\n        message={helpMsg}\r\n        action={\r\n          <React.Fragment>\r\n            <IconButton\r\n              size=\"small\"\r\n              aria-label=\"close\"\r\n              color=\"inherit\"\r\n              onClick={handleCloseHelp}\r\n            >\r\n              <CloseIcon fontSize=\"small\" />\r\n            </IconButton>\r\n          </React.Fragment>\r\n        }\r\n      />\r\n    </>\r\n  );\r\n}\r\n","import React, { useState } from \"react\";\r\nimport { makeStyles, useTheme } from \"@material-ui/core/styles\";\r\nimport MobileStepper from \"@material-ui/core/MobileStepper\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport KeyboardArrowLeft from \"@material-ui/icons/KeyboardArrowLeft\";\r\nimport KeyboardArrowRight from \"@material-ui/icons/KeyboardArrowRight\";\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    width: \"100%\",\r\n  },\r\n});\r\n\r\nexport default function ProgressBar({\r\n  cards,\r\n  dispatch,\r\n  setNextCard,\r\n  addCardDataToLocalStorage,\r\n  currentCard,\r\n  currentResult,\r\n  setResult,\r\n}) {\r\n  const classes = useStyles();\r\n  const theme = useTheme();\r\n  const [activeStep, setActiveStep] = React.useState(0);\r\n\r\n  const handleNext = () => {\r\n    setActiveStep((prevActiveStep) => prevActiveStep + 1);\r\n    setNextCard(activeStep + 1);\r\n    if (activeStep == cards.length - 1) {\r\n      dispatch(true);\r\n    }\r\n    if (!currentResult) {\r\n      addCardDataToLocalStorage(currentCard, activeStep, undefined);\r\n    } else {\r\n      setResult(\"\");\r\n    }\r\n  };\r\n\r\n  const handleBack = () => {\r\n    setActiveStep((prevActiveStep) => prevActiveStep - 1);\r\n    setNextCard(activeStep - 1);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <MobileStepper\r\n        variant=\"text\"\r\n        steps={cards.length}\r\n        position=\"static\"\r\n        activeStep={activeStep}\r\n        className={classes.root}\r\n        nextButton={\r\n          <Button\r\n            size=\"small\"\r\n            onClick={handleNext}\r\n            disabled={activeStep === cards.length}\r\n          >\r\n            Next\r\n            {theme.direction === \"rtl\" ? (\r\n              <KeyboardArrowLeft />\r\n            ) : (\r\n              <KeyboardArrowRight />\r\n            )}\r\n          </Button>\r\n        }\r\n        backButton={\r\n          <Button size=\"small\" onClick={handleBack} disabled={activeStep === 0}>\r\n            {theme.direction === \"rtl\" ? (\r\n              <KeyboardArrowRight />\r\n            ) : (\r\n              <KeyboardArrowLeft />\r\n            )}\r\n            Back\r\n          </Button>\r\n        }\r\n      />\r\n      <MobileStepper\r\n        variant=\"progress\"\r\n        steps={cards.length}\r\n        position=\"static\"\r\n        activeStep={activeStep}\r\n        className={classes.root}\r\n        nextButton={null}\r\n        backButton={null}\r\n      />\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Card from \"@material-ui/core/Card\";\r\nimport CardContent from \"@material-ui/core/CardContent\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport styled from \"styled-components\";\r\n\r\nconst StyledH2 = styled.h2`\r\n  font-weight: normal;\r\n  color: ${(props) => props.color || \"black\"} !important;\r\n  width: ${(props) => (props.direction === \"vertical\" ? \"\" : \"100%\")};\r\n  height: ${(props) => (props.direction === \"vertical\" ? \"100%\" : \"\")};\r\n  text-align: ${(props) => {\r\n    if (props.direction === \"vertical\") {\r\n      return \"left\";\r\n    } else if (\r\n      props.alignment === \"left\" ||\r\n      (props.alignment === \"right\" && props.direction === \"horizontal\")\r\n    ) {\r\n      return props.alignment;\r\n    } else return \"center\";\r\n  }};\r\n  padding: 15px;\r\n`;\r\n\r\n// will be horizontal if direction is undefined\r\nconst StyledCard = styled(Card)`\r\n  width: ${(props) => (props.direction === \"vertical\" ? \"15em\" : \"25em\")};\r\n  height: ${(props) => (props.direction === \"vertical\" ? \"25em\" : \"15em\")};\r\n  writing-mode: ${(props) =>\r\n    props.direction === \"vertical\" ? \"vertical-rl\" : \"\"};\r\n`;\r\n\r\nconst StyledCardContent = styled(CardContent)`\r\n  height: 100%;\r\n  width: 100%;\r\n  padding: 0;\r\n  display: flex;\r\n  align-items: ${(props) => {\r\n    if (props.direction === \"vertical\" && props.alignment === \"right\") {\r\n      return \"flex-start\";\r\n    } else if (props.direction === \"vertical\" && props.alignment === \"left\") {\r\n      return \"flex-end\";\r\n    } else return \"center\";\r\n  }};\r\n`;\r\n\r\nexport default function SingleCard(props) {\r\n  let color = \"\";\r\n  let direction = \"\";\r\n  let alignment = \"\";\r\n  if (props.attributes) {\r\n    props.attributes.forEach((a) => {\r\n      const attributeType = a.attributeType;\r\n      switch (attributeType) {\r\n        case \"color\":\r\n          color = a.value;\r\n          break;\r\n        case \"direction\":\r\n          direction = a.value;\r\n          break;\r\n        case \"alignment\":\r\n          alignment = a.value;\r\n          break;\r\n      }\r\n    });\r\n  }\r\n  return (\r\n    <StyledCard direction={direction}>\r\n      <StyledCardContent alignment={alignment} direction={direction}>\r\n        <StyledH2 color={color} alignment={alignment} direction={direction}>\r\n          {props.content}\r\n        </StyledH2>\r\n      </StyledCardContent>\r\n    </StyledCard>\r\n  );\r\n}\r\n","import ReactCardFlip from \"react-card-flip\";\r\nimport React, { useState } from \"react\";\r\nimport { makeStyles } from \"@material-ui/core\";\r\nimport SingleCard from \"./SingleCard\";\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    marginTop: \"1em\",\r\n    textAlign: \"center\",\r\n    margin: \"0 auto\",\r\n    // paddingTop: \"3.5em\",\r\n  },\r\n});\r\n\r\ntype Props = {\r\n  front: string;\r\n  back: string;\r\n  attributes?: Array<{ attributeType: string; value: string }>;\r\n};\r\n\r\nexport default function CardFlip(props: Props) {\r\n  const [isFlipped, setIsFlipped] = useState(false);\r\n  const classes = useStyles();\r\n  const { front, back, attributes } = props;\r\n  const handleClick = (e) => {\r\n    e.preventDefault();\r\n    setIsFlipped((curState) => {\r\n      return !curState;\r\n    });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className={classes.root}>\r\n        <ReactCardFlip isFlipped={isFlipped} flipDirection=\"vertical\">\r\n          <div onClick={handleClick}>\r\n            <SingleCard content={front} attributes={attributes}></SingleCard>\r\n          </div>\r\n\r\n          <div onClick={handleClick}>\r\n            <SingleCard\r\n              content={back}\r\n              onClick={handleClick}\r\n              attributes={attributes}\r\n            ></SingleCard>\r\n          </div>\r\n        </ReactCardFlip>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import { Database, Q } from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"./constants\";\r\nimport Session from \"./Session\";\r\nimport Deck from \"./Deck\";\r\nimport Card from \"./Card\";\r\nimport Tag from \"./Tag\";\r\nimport { shuffle } from \"../lib/utils\";\r\nimport SessionCard from \"./SessionCard\";\r\n\r\nexport enum Filter {\r\n  BEST = \"best\",\r\n  WORST = \"worst\",\r\n  RANDOM = \"random\",\r\n  OLDEST = \"oldest\",\r\n  NEWEST = \"newest\",\r\n}\r\n\r\nexport async function getAllDecks(db: Database): Promise<Array<Deck>> {\r\n  const decksCollection = db.collections.get(TableName.DECKS);\r\n  return (await decksCollection.query().fetch()) as Array<Deck>;\r\n}\r\n\r\nexport async function getSelectedDecks(\r\n  db: Database,\r\n  deckNames: Array<string>\r\n): Promise<Array<Deck>> {\r\n  const decksCollection = db.collections.get(TableName.DECKS);\r\n  return (await decksCollection\r\n    .query(Q.where(\"name\", Q.oneOf(deckNames)))\r\n    .fetch()) as Array<Deck>;\r\n}\r\n\r\nexport async function getDeckNameFromID(\r\n  db: Database,\r\n  id: number\r\n): Promise<string> {\r\n  // TODO: Add caching\r\n  const decksCollection = db.collections.get(TableName.DECKS);\r\n  const decks = (await decksCollection\r\n    .query(Q.where(\"id\", id))\r\n    .fetch()) as Array<Deck>;\r\n  if (decks.length < 1) {\r\n    throw new Error(`Unable to retrieve deck name for ID ${id}`);\r\n  }\r\n  return decks[0].name;\r\n}\r\n\r\nexport async function getUniqueDeckNamesFromSessions(\r\n  db: Database,\r\n  session: Session\r\n): Promise<Array<string>> {\r\n  let deckIds = [];\r\n  const sessionCards: Array<Card> = (await session.cards) as Array<Card>;\r\n  for (let sessionCard of sessionCards) {\r\n    if (!deckIds[sessionCard.deck_id]) {\r\n      deckIds[sessionCard.deck_id] = true;\r\n      deckIds.push(sessionCard.deck_id);\r\n    }\r\n  }\r\n  let deckNames: Array<string> = [];\r\n  for (let deckId of deckIds) {\r\n    deckNames = deckNames.concat(await getDeckNameFromID(db, deckId));\r\n  }\r\n  return deckNames;\r\n}\r\n\r\nexport async function getCardsFromSelectedDecks(\r\n  db: Database,\r\n  deckNames: Array<string>\r\n): Promise<Array<Card>> {\r\n  let result = [];\r\n  const decks = await getSelectedDecks(db, deckNames);\r\n  for (let deckId of decks) {\r\n    result = result.concat(await deckId.cards.fetch());\r\n  }\r\n  return result;\r\n}\r\n\r\nexport async function getAllTags(db: Database): Promise<Array<Tag>> {\r\n  const tagsCollection = db.collections.get(TableName.TAGS);\r\n  return (await tagsCollection.query().fetch()) as Array<Tag>;\r\n}\r\n\r\nexport async function getSelectedTags(\r\n  db: Database,\r\n  tagNames: Array<string>\r\n): Promise<Array<Tag>> {\r\n  const tagsCollection = db.collections.get(TableName.TAGS);\r\n  return (await tagsCollection\r\n    .query(Q.where(\"name\", Q.oneOf(tagNames)))\r\n    .fetch()) as Array<Tag>;\r\n}\r\n\r\nexport async function getCardsFromSelectedTags(\r\n  db: Database,\r\n  tagNames: Array<string>\r\n): Promise<Array<Card>> {\r\n  let allCards: Array<Card> = [];\r\n  const cardIds = new Set();\r\n  const tags = await getSelectedTags(db, tagNames);\r\n\r\n  for (const tag of tags) {\r\n    const cards = await tag.cards;\r\n    allCards.concat(cards as Array<Card>);\r\n  }\r\n\r\n  return uniqueCards(allCards);\r\n}\r\n\r\nexport async function getAllSessions(db: Database): Promise<Array<Session>> {\r\n  const sessionsCollection = db.collections.get(TableName.SESSIONS);\r\n  return (await sessionsCollection.query().fetch()) as Array<Session>;\r\n}\r\n\r\nexport async function getPastSessions(\r\n  db: Database,\r\n  n: number = 5\r\n): Promise<Array<Session>> {\r\n  const allSessions = await getAllSessions(db);\r\n  return allSessions.sort((a, b) => b.started_at - a.started_at).slice(0, n);\r\n}\r\n\r\nexport async function getCardsFromSelectedSessions(\r\n  db: Database,\r\n  n: number = 5\r\n): Promise<Array<Card>> {\r\n  let allCards: Array<Card> = [];\r\n  const sessions = await getPastSessions(db, n);\r\n\r\n  for (const session of sessions) {\r\n    const cards = await session.cards;\r\n    allCards.concat(cards as Array<Card>);\r\n  }\r\n\r\n  return uniqueCards(allCards);\r\n}\r\n\r\nexport function cardFilter(\r\n  cards: Array<Card>,\r\n  filter: Filter,\r\n  n: number = 1\r\n): Array<Card> {\r\n  let result = [];\r\n\r\n  switch (filter) {\r\n    case Filter.BEST:\r\n      result = cards\r\n        .sort((a, b) => b.right - b.wrong - (a.right - a.wrong))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.WORST:\r\n      result = cards\r\n        .sort((a, b) => a.right - a.wrong - (b.right - b.wrong))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.NEWEST:\r\n      result = cards.sort((a, b) => b.created_at - a.created_at).slice(0, n);\r\n      break;\r\n    case Filter.OLDEST:\r\n      result = cards.sort((a, b) => a.created_at - b.created_at).slice(0, n);\r\n      break;\r\n    case Filter.RANDOM:\r\n      result = shuffle(cards).slice(0, n);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown CARD_MODIFIER: ${filter}`);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport async function deckFilter(\r\n  decks: Array<Deck>,\r\n  filter: Filter,\r\n  n: number = 1\r\n): Promise<Array<Deck>> {\r\n  let result = [];\r\n  let deckScoreMap = new Map();\r\n  for (let deck of decks) {\r\n    const cards = await deck.cards.fetch();\r\n    const score = calculateDeckScore(cards);\r\n    deckScoreMap.set(deck.id, score);\r\n  }\r\n\r\n  switch (filter) {\r\n    case Filter.BEST:\r\n      result = decks\r\n        .sort((a, b) => deckScoreMap.get(b.id) - deckScoreMap.get(a.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.WORST:\r\n      result = decks\r\n        .sort((a, b) => deckScoreMap.get(a.id) - deckScoreMap.get(b.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.NEWEST:\r\n      result = decks.sort((a, b) => b.created_at - a.created_at).slice(0, n);\r\n      break;\r\n    case Filter.OLDEST:\r\n      result = decks.sort((a, b) => a.created_at - b.created_at).slice(0, n);\r\n      break;\r\n    case Filter.RANDOM:\r\n      result = shuffle(decks).slice(0, n);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown CARD_MODIFIER: ${filter}`);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport async function sessionFilter(\r\n  db: Database,\r\n  sessions: Array<Session>,\r\n  filter: Filter,\r\n  n: number = 1\r\n): Promise<Array<Session>> {\r\n  let result = [];\r\n  let sessionsScoreMap = new Map();\r\n\r\n  for (const session of sessions) {\r\n    let score = await getSessionScore(db, session);\r\n    score = isNaN(score) ? 0 : score;\r\n    sessionsScoreMap.set(session.id, score);\r\n  }\r\n\r\n  switch (filter) {\r\n    case Filter.BEST:\r\n      result = sessions\r\n        .sort((a, b) => sessionsScoreMap.get(b.id) - sessionsScoreMap.get(a.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.WORST:\r\n      result = sessions\r\n        .sort((a, b) => sessionsScoreMap.get(a.id) - sessionsScoreMap.get(b.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.NEWEST:\r\n      result = sessions.sort((a, b) => b.started_at - a.started_at).slice(0, n);\r\n      break;\r\n    case Filter.OLDEST:\r\n      result = sessions.sort((a, b) => a.started_at - b.started_at).slice(0, n);\r\n      break;\r\n    case Filter.RANDOM:\r\n      result = shuffle(sessions).slice(0, n);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown CARD_MODIFIER: ${filter}`);\r\n  }\r\n\r\n  console.log(result);\r\n  return result;\r\n}\r\n\r\nexport function calculateDeckScore(cards: Array<Card>): number {\r\n  let rightCount = 0;\r\n  let wrongCount = 0;\r\n  cards.forEach((card) => {\r\n    rightCount += card.right;\r\n    wrongCount += card.wrong;\r\n  });\r\n  return rightCount / (rightCount + wrongCount);\r\n}\r\n\r\nexport async function getSessionScore(\r\n  db: Database,\r\n  session: Session\r\n): Promise<number> {\r\n  const sessionCardsCollection = db.collections.get(TableName.SESSIONS_CARDS);\r\n  const sessionCards = (await sessionCardsCollection\r\n    .query(Q.where(\"session_id\", session.id))\r\n    .fetch()) as Array<SessionCard>;\r\n  const totalCards = sessionCards.length;\r\n  let numberCorrect = 0;\r\n  sessionCards.forEach((c) => {\r\n    numberCorrect += c.is_correct ? 1 : 0;\r\n  });\r\n\r\n  return numberCorrect / totalCards;\r\n}\r\n\r\nexport function uniqueCards(cards: Array<Card>): Array<Card> {\r\n  let result = [];\r\n  const cardIds = new Set();\r\n  for (const card of cards) {\r\n    if (!cardIds.has(card.id)) {\r\n      result.push(card);\r\n      cardIds.add(card.id);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n","import PROGRAM from \"../ast/PROGRAM\";\r\nimport { ComplexCommandParams } from \"../App\";\r\nimport {\r\n  Filter,\r\n  getSelectedDecks,\r\n  deckFilter,\r\n  getPastSessions,\r\n  getAllSessions,\r\n  sessionFilter,\r\n  getCardsFromSelectedSessions,\r\n  uniqueCards,\r\n  cardFilter,\r\n} from \"../model/query\";\r\nimport { Database, Collection } from \"@nozbe/watermelondb\";\r\nimport {\r\n  SessionMaterials,\r\n  FlashCard,\r\n  SessionMaterialsWithTags,\r\n  FlashCardWithTags,\r\n} from \"../components/Session\";\r\nimport { randomize, shuffle } from \"./utils\";\r\nimport FILTER from \"../ast/FILTER\";\r\nimport CREATE_DECK from \"../ast/CREATE_DECK\";\r\nimport { TableName } from \"../model/constants\";\r\nimport Session from \"../model/Session\";\r\nimport Card from \"../model/Card\";\r\nimport Deck from \"../model/Deck\";\r\nimport { Q } from \"@nozbe/watermelondb\";\r\n\r\ntype SessionCommandError = {\r\n  message: string;\r\n};\r\n\r\nconst deckSelectionErrorMessage =\r\n  \"Please select one or more of the decks on the card editor\";\r\n\r\nconst tagSelectionErrorMessage =\r\n  \"Please select one or more of the tags on the card editor\";\r\n\r\n/**\r\n * Checks whether the user's complex command makes sense (currently checks the deck names), add more logic here\r\n *\r\n * @returns either false if there's no error, or an error message\r\n */\r\nexport function checkSessionCommandError(\r\n  program: PROGRAM,\r\n  complexCommandParams: ComplexCommandParams\r\n): SessionCommandError | false {\r\n  const {\r\n    subject,\r\n    deckNames: requestedDeckNames,\r\n    tagNames,\r\n  } = complexCommandParams;\r\n\r\n  if (subject === \"decks\") {\r\n    if (!requestedDeckNames) {\r\n      return {\r\n        message: deckSelectionErrorMessage,\r\n      };\r\n    }\r\n    const activeDeckNames = program.create_decks.map((cd) => cd.name);\r\n    const matchedDeckNames = new Set<string>();\r\n    requestedDeckNames.forEach((name) => {\r\n      if (\r\n        activeDeckNames.findIndex(\r\n          (deckName) => name.toLowerCase() === deckName.toLowerCase()\r\n        ) !== -1\r\n      ) {\r\n        matchedDeckNames.add(name);\r\n      }\r\n    });\r\n    if (matchedDeckNames.size === 0) {\r\n      return {\r\n        message: deckSelectionErrorMessage,\r\n      };\r\n    }\r\n  } else if (subject === \"tags\") {\r\n    if (tagNames.length === 0) {\r\n      return {\r\n        message: tagSelectionErrorMessage,\r\n      };\r\n    }\r\n    let possibleTags = [];\r\n    program.create_decks.forEach((cd) => {\r\n      cd.tags && cd.tags.tags.forEach((t) => possibleTags.push(t.tagName));\r\n    });\r\n    let giveError = false;\r\n    tagNames.forEach((t) => {\r\n      if (!possibleTags.includes(t)) {\r\n        giveError = true;\r\n      }\r\n    });\r\n    if (giveError) {\r\n      return {\r\n        message: tagSelectionErrorMessage,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Add more checks here as we add features, for instance, of tags\r\n  return false;\r\n}\r\n\r\n/*\r\n * Returns a list of case sensitive deck names matching the requested deck names, removing duplicates\r\n */\r\n\r\nfunction getValidDeckNames(\r\n  program: PROGRAM,\r\n  requestedDeckNames: string[]\r\n): string[] {\r\n  const validDeckNames: { [key: string]: boolean } = {}; // a set\r\n  const deckNamesInProgram: { [key: string]: string } = {}; // mapping of lower case name -> case sensitive name\r\n  program.create_decks.forEach((cd) => {\r\n    if (cd.deck?.cards?.length > 0) {\r\n      deckNamesInProgram[cd.name.toLowerCase()] = cd.name;\r\n    }\r\n  });\r\n  requestedDeckNames.forEach((dn) => {\r\n    const actualDeckName = deckNamesInProgram[dn.toLowerCase()];\r\n    if (actualDeckName) {\r\n      validDeckNames[actualDeckName] = true;\r\n    }\r\n  });\r\n  return Object.keys(validDeckNames);\r\n}\r\n\r\nfunction getCardsFromSelectedDecks(selectedCreateDecks: CREATE_DECK[]) {\r\n  let selectedCards: FlashCard[] = [];\r\n  for (const cd of selectedCreateDecks) {\r\n    const deckName = cd.name;\r\n    for (const card of cd.deck.cards) {\r\n      const cardWithDeck = { front: card.front, back: card.back, deckName };\r\n      selectedCards.push(cardWithDeck);\r\n    }\r\n  }\r\n  return selectedCards;\r\n}\r\n\r\nasync function getCardsFromDecksNoFilter(\r\n  deckNames: string[],\r\n  selectedCreateDecks: CREATE_DECK[],\r\n  limit: number,\r\n  isLimitAppliedToCards?: boolean\r\n): Promise<SessionMaterials> {\r\n  if (!isLimitAppliedToCards) {\r\n    randomize(selectedCreateDecks);\r\n    if (limit < selectedCreateDecks.length) {\r\n      selectedCreateDecks.splice(limit);\r\n    }\r\n  }\r\n\r\n  let selectedCards = getCardsFromSelectedDecks(selectedCreateDecks);\r\n\r\n  selectedCards = randomize(selectedCards);\r\n  if (isLimitAppliedToCards) {\r\n    randomize(selectedCards);\r\n    if (limit < selectedCards.length) {\r\n      selectedCards.splice(limit);\r\n    }\r\n  }\r\n  return {\r\n    deckNames: deckNames,\r\n    cards: selectedCards,\r\n  };\r\n}\r\n\r\ntype CardWithStats = {\r\n  front: string;\r\n  back: string;\r\n  deckName: string;\r\n  right: number;\r\n  wrong: number;\r\n  createdAt: number; // UNIX timestamp\r\n};\r\n\r\nasync function getCardStatsFromDB(\r\n  db: Database,\r\n  deckNames: string[],\r\n  selectedCards: FlashCard[]\r\n): Promise<CardWithStats[]> {\r\n  const selectedCardsSet: { [key: string]: boolean } = {}; // selectedCards.deckName:front:back\r\n  selectedCards.forEach(({ deckName, front, back }) => {\r\n    selectedCardsSet[`${deckName}:${front}:${back}`] = true;\r\n  });\r\n\r\n  const cardsWithStats: CardWithStats[] = [];\r\n\r\n  const decks = await getSelectedDecks(db, deckNames);\r\n  for (const deck of decks) {\r\n    const cardsFromDB = await deck.cards.fetch();\r\n    cardsFromDB.forEach(\r\n      ({ front, back, right, wrong, created_at: createdAt }) => {\r\n        if (selectedCardsSet[`${deck.name}:${front}:${back}`]) {\r\n          // take its stats\r\n          cardsWithStats.push({\r\n            deckName: deck.name,\r\n            front,\r\n            back,\r\n            right,\r\n            wrong,\r\n            createdAt,\r\n          });\r\n        }\r\n      }\r\n    );\r\n  }\r\n  return cardsWithStats;\r\n}\r\n\r\nasync function getCardsFromDecksWithFilter(\r\n  db: Database,\r\n  validDeckNames: string[],\r\n  selectedCreateDecks: CREATE_DECK[],\r\n  filter: Filter,\r\n  limit: number,\r\n  isLimitAppliedToCards?: boolean\r\n): Promise<SessionMaterials> {\r\n  // if limit is not less than what's available in selectedCreateDecks, directly return it without DB trip\r\n  let selectedCards = getCardsFromSelectedDecks(selectedCreateDecks);\r\n  randomize(selectedCards);\r\n  if (!isLimitAppliedToCards) {\r\n    if (limit >= selectedCreateDecks.length) {\r\n      return {\r\n        deckNames: validDeckNames,\r\n        cards: selectedCards,\r\n      };\r\n    }\r\n  } else {\r\n    if (limit >= selectedCards.length) {\r\n      return {\r\n        deckNames: validDeckNames,\r\n        cards: selectedCards,\r\n      };\r\n    }\r\n  }\r\n  //if  limit is less than what's available\r\n  if (isLimitAppliedToCards) {\r\n    const cardsWithStats = await getCardStatsFromDB(\r\n      db,\r\n      validDeckNames,\r\n      selectedCards\r\n    );\r\n    switch (filter) {\r\n      case Filter.BEST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return -(card1.right - card1.wrong - (card2.right - card2.wrong));\r\n        });\r\n      }\r\n      case Filter.WORST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return card1.right - card1.wrong - (card2.right - card2.wrong);\r\n        });\r\n      }\r\n      case Filter.OLDEST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return card1.createdAt - card2.createdAt;\r\n        });\r\n      }\r\n      case Filter.NEWEST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return -(card1.createdAt - card2.createdAt);\r\n        });\r\n      }\r\n    }\r\n    cardsWithStats.splice(limit);\r\n    randomize(cardsWithStats);\r\n    return {\r\n      deckNames: validDeckNames,\r\n      cards: cardsWithStats,\r\n    };\r\n  } else {\r\n    // e.g. best 5 decks\r\n    const decksFromDB = await getSelectedDecks(db, validDeckNames);\r\n    const filteredDecks = await deckFilter(decksFromDB, filter, limit);\r\n    const filteredDecksSet: { [key: string]: boolean } = {};\r\n    filteredDecks.forEach((deck) => {\r\n      filteredDecksSet[deck.name] = true;\r\n    });\r\n    const filteredCreateDecks = selectedCreateDecks.filter(\r\n      (cd) => filteredDecksSet[cd.name]\r\n    );\r\n    const cards = getCardsFromSelectedDecks(filteredCreateDecks);\r\n    randomize(cards);\r\n    return {\r\n      deckNames: validDeckNames,\r\n      cards: cards,\r\n    };\r\n  }\r\n}\r\n\r\nasync function getCardsFromDecks(\r\n  db: Database,\r\n  program: PROGRAM,\r\n  requestedDeckNames: string[],\r\n  filter?: Filter,\r\n  isLimitAppliedToCards?: boolean,\r\n  limit: number = 5\r\n): Promise<SessionMaterials> {\r\n  const validDeckNames = getValidDeckNames(program, requestedDeckNames);\r\n  const selectedCreateDecks = program.create_decks.filter((cd) => {\r\n    return validDeckNames.includes(cd.name);\r\n  });\r\n\r\n  if (!filter || filter === Filter.RANDOM) {\r\n    return getCardsFromDecksNoFilter(\r\n      validDeckNames,\r\n      selectedCreateDecks,\r\n      limit,\r\n      isLimitAppliedToCards\r\n    );\r\n  } else {\r\n    return await getCardsFromDecksWithFilter(\r\n      db,\r\n      validDeckNames,\r\n      selectedCreateDecks,\r\n      filter,\r\n      limit,\r\n      isLimitAppliedToCards\r\n    );\r\n  }\r\n}\r\n\r\nasync function getCardsFromTags(\r\n  db: Database,\r\n  program: PROGRAM,\r\n  tagNames: string[],\r\n  filter?: Filter,\r\n  isLimitAppliedToCards?: boolean,\r\n  limit?: number\r\n): Promise<SessionMaterials> {\r\n  const selectedCreateDecks = program.create_decks.filter((cd) => {\r\n    const createDeckTags = cd.tags && cd.tags.tags.map((t) => t.tagName);\r\n    let hasASelectedTag = false;\r\n    if (createDeckTags) {\r\n      createDeckTags.forEach((t) => {\r\n        if (tagNames.includes(t)) {\r\n          hasASelectedTag = true;\r\n        }\r\n      });\r\n    }\r\n    return hasASelectedTag;\r\n  });\r\n  // TODO implement filtering for tags\r\n  const deckNames = selectedCreateDecks.map((cd) => cd.name);\r\n  return await getCardsFromDecksNoFilter(\r\n    deckNames,\r\n    selectedCreateDecks,\r\n    limit,\r\n    isLimitAppliedToCards\r\n  );\r\n}\r\n\r\nasync function getCardsFromSessions(\r\n  db: Database,\r\n  filter?: Filter,\r\n  isLimitAppliedToCards?: boolean,\r\n  limit: number = 5\r\n): Promise<SessionMaterials> {\r\n  let sessions: Session[];\r\n\r\n  if (isLimitAppliedToCards) {\r\n    sessions = await getAllSessions(db);\r\n  } else {\r\n    if (filter) {\r\n      sessions = await getAllSessions(db);\r\n      sessions = await sessionFilter(db, sessions, filter, limit);\r\n    } else {\r\n      sessions = await getPastSessions(db, limit);\r\n    }\r\n  }\r\n\r\n  let cards: Array<Card> = [];\r\n  for (const session of sessions) {\r\n    const cards = await session.cards;\r\n    cards.concat(cards as Array<Card>);\r\n  }\r\n\r\n  cards = uniqueCards(cards);\r\n\r\n  if (isLimitAppliedToCards && cards.length > limit) {\r\n    if (filter) {\r\n      cards = cardFilter(cards, filter, limit);\r\n    } else {\r\n      cards = shuffle(cards).splice(limit);\r\n    }\r\n  }\r\n\r\n  shuffle(cards);\r\n\r\n  const decks: Collection<Deck> = db.collections.get(TableName.DECKS);\r\n  const deckIdToDeckName: { [key: string]: string } = {}; // deck id -> deck name (watermelonDB ids are strings)\r\n  const flashCards: FlashCard[] = [];\r\n  for (const card of cards) {\r\n    if (!deckIdToDeckName[card.deck_id]) {\r\n      deckIdToDeckName[card.deck_id] = (\r\n        await decks.query(Q.where(\"id\", Q.eq(card.deck_id))).fetch()\r\n      )[0].name;\r\n    }\r\n    const deckName = deckIdToDeckName[card.deck_id];\r\n    flashCards.push({\r\n      deckName,\r\n      front: card.front,\r\n      back: card.back,\r\n    });\r\n  }\r\n\r\n  return { cards: flashCards };\r\n}\r\n\r\nfunction addTagsToFlashCard(program: PROGRAM, card: FlashCard) {\r\n  const cd: CREATE_DECK = program.create_decks.find(\r\n    (cd) => cd.name === card.deckName\r\n  );\r\n  card.tags = cd.tags && cd.tags.tags.map((t) => t && t.tagName);\r\n  card.attributes =\r\n    cd.attributes &&\r\n    cd.attributes.attributes.map((a) => {\r\n      return a\r\n        ? {\r\n            attributeType: a.attribute.attributeType,\r\n            value: a.attribute.value,\r\n          }\r\n        : null;\r\n    });\r\n}\r\n\r\n/**\r\n * Returns the necessary information to start a session\r\n * (Currently not implementing tags with filtering)\r\n */\r\nexport async function getSessionMaterialsWithTags(\r\n  program: PROGRAM,\r\n  complexCommandParams: ComplexCommandParams,\r\n  db: Database\r\n): Promise<SessionMaterialsWithTags> {\r\n  const sessionMaterials = await getSessionMaterials(\r\n    program,\r\n    complexCommandParams,\r\n    db\r\n  );\r\n  sessionMaterials.cards.forEach((flashCard) => {\r\n    return addTagsToFlashCard(program, flashCard);\r\n  });\r\n\r\n  // Bug fix to remove filtered out deckNames (replaces sessionMaterials.deckNames with filtered deck names)\r\n  if (sessionMaterials.deckNames) {\r\n    const filteredDeckNamesSet: { [key: string]: boolean } = {};\r\n    sessionMaterials.cards.forEach((card) => {\r\n      filteredDeckNamesSet[card.deckName] = true;\r\n    });\r\n    // set sessionMaterials.deckNames\r\n    sessionMaterials.deckNames = Object.keys(filteredDeckNamesSet);\r\n  }\r\n\r\n  return sessionMaterials as SessionMaterialsWithTags;\r\n}\r\n\r\n// Do not export (use getSessionMaterialsWithTags instead)\r\nasync function getSessionMaterials(\r\n  program: PROGRAM,\r\n  complexCommandParams: ComplexCommandParams,\r\n  db: Database\r\n): Promise<SessionMaterials> {\r\n  const {\r\n    subject,\r\n    filter,\r\n    isLimitAppliedToCards,\r\n    limit,\r\n    deckNames: requestedDeckNames,\r\n    tagNames,\r\n  } = complexCommandParams;\r\n\r\n  if (subject === \"decks\") {\r\n    return await getCardsFromDecks(\r\n      db,\r\n      program,\r\n      requestedDeckNames,\r\n      filter,\r\n      isLimitAppliedToCards,\r\n      limit\r\n    );\r\n  } else if (subject === \"tags\") {\r\n    return await getCardsFromTags(\r\n      db,\r\n      program,\r\n      tagNames,\r\n      filter,\r\n      isLimitAppliedToCards,\r\n      limit\r\n    );\r\n  } else if (subject === \"sessions\") {\r\n    return await getCardsFromSessions(db, filter, isLimitAppliedToCards, limit);\r\n  } else {\r\n    throw new Error(\"Not supported!\");\r\n  }\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport ProgressBar from \"./ProgressBar\";\r\nimport CardFlip from \"./CardFlip\";\r\n\r\nimport Timer from \"react-compound-timer\";\r\nimport { Action, ActionType, ComplexCommandParams } from \"../App\";\r\nimport { SubjectType as Subject } from \"../ast/SUBJECT\";\r\nimport {\r\n  checkSessionCommandError,\r\n  getSessionMaterialsWithTags,\r\n} from \"../lib/sessionHelperFunctions\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\nimport { CircularProgress } from \"@material-ui/core\";\r\nimport ErrorMessage from \"./ErrorMessage\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\nimport { Database, Collection } from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"../model/constants\";\r\nimport SessionModel from \"../model/Session\";\r\nimport CardModel from \"../model/Card\";\r\nimport DeckModel from \"../model/Deck\";\r\nimport { Q } from \"@nozbe/watermelondb\";\r\nimport SessionCard from \"../model/SessionCard\";\r\nimport { debug } from \"../lib/utils\";\r\n\r\nconst WrongBtn = \"https://daranguyen.com/assets/wrong_btn.svg\";\r\nconst CorrectBtn = \"https://daranguyen.com/assets/correct_btn.svg\";\r\n\r\ntype Props = {\r\n  complexCommandParams: ComplexCommandParams;\r\n  program: PROGRAM;\r\n  dispatch: React.Dispatch<Action>;\r\n};\r\n\r\nexport type FlashCard = {\r\n  front: string;\r\n  back: string;\r\n  deckName: string;\r\n  tags?: string[];\r\n  attributes?: Array<{ attributeType: string; value: string }>;\r\n};\r\n\r\nexport type FlashCardWithTags = {\r\n  front: string;\r\n  back: string;\r\n  deckName: string;\r\n  tags: string[];\r\n};\r\n\r\n/**\r\n * A list of cards, and optionally, a list of deck names\r\n */\r\nexport type SessionMaterials = {\r\n  deckNames?: string[];\r\n  cards: FlashCard[];\r\n};\r\n\r\nexport type SessionMaterialsWithTags = {\r\n  deckNames?: string[];\r\n  cards: FlashCardWithTags[];\r\n};\r\n\r\nfunction addCardDataToLocalStorage(\r\n  card: any,\r\n  nextCardIndex: number,\r\n  gotCorrect: boolean\r\n) {\r\n  const sessionData = localStorage.getItem(\"sessionData\");\r\n  let cardDataArray;\r\n  let sessionDataObject;\r\n  let newSessionDataObject;\r\n  if (sessionData) {\r\n    sessionDataObject = JSON.parse(sessionData);\r\n    cardDataArray = sessionDataObject[\"cardDataArray\"];\r\n    if (!cardDataArray) cardDataArray = [];\r\n    const currentCardID = `${card.deckName}_${card.front}_${card.back}`;\r\n    const cardData = {\r\n      card_id: currentCardID,\r\n      front: card.front,\r\n      back: card.back,\r\n      is_correct: gotCorrect,\r\n      card_index: nextCardIndex,\r\n      deck: card.deckName,\r\n      tags: card.tags,\r\n    };\r\n    const alreadyAdded = cardDataArray.filter(\r\n      (o) => o.card_id === currentCardID\r\n    )[0];\r\n    const alreadyAddedIndex = cardDataArray.indexOf(alreadyAdded);\r\n    if (alreadyAdded) {\r\n      cardDataArray[alreadyAddedIndex] = cardData;\r\n    } else {\r\n      cardDataArray.push(cardData);\r\n    }\r\n    newSessionDataObject = {\r\n      ...sessionDataObject,\r\n      cardDataArray: cardDataArray,\r\n    };\r\n    localStorage.setItem(\"sessionData\", JSON.stringify(newSessionDataObject));\r\n  }\r\n}\r\n\r\ntype SessionDataType = {\r\n  created_at: string;\r\n  sessionId: string;\r\n  cardDataArray: LocalCardFromSession[];\r\n  ended_at: string;\r\n};\r\n\r\ntype LocalCardFromSession = {\r\n  card_id: string;\r\n  deck: string;\r\n  front: string;\r\n  back: string;\r\n  is_correct?: boolean;\r\n};\r\nasync function saveSessionDataToDB(\r\n  data: SessionDataType,\r\n  db: Database\r\n): Promise<void> {\r\n  const sessionsTable: Collection<SessionModel> = db.collections.get(\r\n    TableName.SESSIONS\r\n  );\r\n\r\n  const cardTable: Collection<CardModel> = db.collections.get(TableName.CARDS);\r\n  const deckTable: Collection<DeckModel> = db.collections.get(TableName.DECKS);\r\n  const sessionCardTable: Collection<SessionCard> = db.collections.get(\r\n    TableName.SESSIONS_CARDS\r\n  );\r\n\r\n  //any db modification needs to be wrapped in action\r\n  await db.action(async () => {\r\n    //get cards in session from db\r\n    const deckNameToDeckModel = {}; // deck name -> deck Model\r\n    //put new session in db\r\n    const createdSession = await sessionsTable.create((session) => {\r\n      session.started_at = new Date(data.created_at);\r\n      session.ended_at = new Date(data.ended_at);\r\n    });\r\n    for (const c of data.cardDataArray) {\r\n      if (c.is_correct === true || c.is_correct === false) {\r\n        // if card was not skipped\r\n        //save deckId from deckname in session, used to find the cards\r\n        if (!deckNameToDeckModel[c.deck]) {\r\n          deckNameToDeckModel[c.deck] = (\r\n            await deckTable.query(Q.where(\"name\", Q.eq(c.deck))).fetch()\r\n          )[0];\r\n        }\r\n        const deckId = deckNameToDeckModel[c.deck].id;\r\n        //find card in db which matches session card\r\n        const matchedCards = await cardTable\r\n          .query(\r\n            Q.where(\"deck_id\", Q.eq(deckId)),\r\n            Q.where(\"front\", Q.eq(c.front)),\r\n            Q.where(\"back\", Q.eq(c.back))\r\n          )\r\n          .fetch();\r\n        //get matched cards from db\r\n        let cardModel: CardModel;\r\n        if (matchedCards.length === 0) {\r\n          //if cards were not saved properly, save it to cards\r\n          const deckModel: DeckModel = deckNameToDeckModel[c.deck];\r\n          //use subaction to run an action inside an action\r\n          await deckModel.subAction(async () => {\r\n            cardModel = (await deckModel.addCard(c.front, c.back)) as CardModel;\r\n          });\r\n        } else {\r\n          //if card is found in db, save in cardModel (should be a single card)\r\n          cardModel = matchedCards[0];\r\n        }\r\n        //update the card with its stat obtained from session\r\n        await cardModel.update((cm) => {\r\n          if (c.is_correct) {\r\n            cm.right++;\r\n          } else {\r\n            cm.wrong++;\r\n          }\r\n          cm.last_tested_at = new Date(data.ended_at);\r\n        });\r\n\r\n        //add card to join table of cards and sessions\r\n        await sessionCardTable.create((sessionCard) => {\r\n          sessionCard.card_id = cardModel.id;\r\n          sessionCard.session_id = createdSession.id;\r\n          sessionCard.is_correct = c.is_correct;\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction addEndTimeToSessionDataInLocalStorage(db: Database) {\r\n  const sessionData = localStorage.getItem(\"sessionData\");\r\n  let endedAt;\r\n  let currentSessionData;\r\n  if (sessionData) {\r\n    currentSessionData = JSON.parse(sessionData);\r\n    endedAt = currentSessionData[\"ended_at\"];\r\n  }\r\n  if (currentSessionData && !endedAt) {\r\n    const data = { ...currentSessionData, ended_at: new Date().toString() };\r\n    saveSessionDataToDB(data, db);\r\n    const dataString = JSON.stringify(data);\r\n    localStorage.setItem(\"sessionData\", dataString);\r\n  }\r\n}\r\n\r\nexport default function Session(props: Props) {\r\n  const db = useDatabase();\r\n  const [result, setResult] = useState(\"\");\r\n  const [isDone, setIsDone] = useState(false);\r\n  const [nextCardIndex, setNextCardIndex] = useState(0);\r\n  const [sessionMaterials, setSessionMaterials] = useState<SessionMaterials>(\r\n    null\r\n  );\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<Error>(null);\r\n\r\n  useEffect(() => {\r\n    const sessionCommandErr = checkSessionCommandError(\r\n      props.program,\r\n      props.complexCommandParams\r\n    );\r\n    if (sessionCommandErr) {\r\n      setError(new Error(sessionCommandErr.message));\r\n      return;\r\n    }\r\n\r\n    const _getSessionMaterials = async () => {\r\n      try {\r\n        const sessionMaterials = await getSessionMaterialsWithTags(\r\n          props.program,\r\n          props.complexCommandParams,\r\n          db\r\n        );\r\n        debug(sessionMaterials);\r\n        const nowString = new Date().toString();\r\n        const initialData = { created_at: nowString, session_id: nowString }; // redundant :/\r\n        const initialDataString = JSON.stringify(initialData);\r\n        localStorage.setItem(\"sessionData\", initialDataString);\r\n\r\n        setSessionMaterials(sessionMaterials);\r\n        setIsLoading(false);\r\n        setError(null);\r\n      } catch (err) {\r\n        debug(err);\r\n        setError(err);\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    _getSessionMaterials();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (isDone) {\r\n      addEndTimeToSessionDataInLocalStorage(db);\r\n      props.dispatch({ type: ActionType.PostSession });\r\n    }\r\n  }, [isDone]);\r\n\r\n  const showDecksOrPastSessionsHeader = () => {\r\n    if (\r\n      props.complexCommandParams.subject === Subject.Decks ||\r\n      props.complexCommandParams.subject === Subject.Tags\r\n    ) {\r\n      return (\r\n        <>\r\n          <h3 className=\"decks\">DECKS: </h3>\r\n          <br></br>\r\n          <p className=\"deckNames\">\r\n            {sessionMaterials.deckNames.map((deckname) => {\r\n              if (\r\n                deckname ===\r\n                sessionMaterials.deckNames[\r\n                  sessionMaterials.deckNames.length - 1\r\n                ]\r\n              ) {\r\n                return <span key={deckname}>{deckname} </span>;\r\n              }\r\n              return <span key={deckname}>{deckname}, </span>;\r\n            })}\r\n          </p>\r\n        </>\r\n      );\r\n    } else if (props.complexCommandParams.subject === Subject.Sessions) {\r\n      let numPastSessionsString = props.complexCommandParams.limit?.toString();\r\n      if (!numPastSessionsString) {\r\n        numPastSessionsString = \"5\"; // TODO use a global constant for default number\r\n      }\r\n      return (\r\n        <>\r\n          <h3 className=\"decks\">Past Sessions</h3>\r\n          <br></br>\r\n          <p className=\"deckNames\">{numPastSessionsString}</p>\r\n        </>\r\n      );\r\n    }\r\n  };\r\n\r\n  if (error) {\r\n    return <ErrorMessage message={error.message}></ErrorMessage>;\r\n  }\r\n\r\n  if (isDone) {\r\n    return <CircularProgress></CircularProgress>;\r\n  }\r\n  if (!isLoading) {\r\n    return (\r\n      <>\r\n        {!isDone && (\r\n          <div className=\"session-container\">\r\n            <h1>Session</h1>\r\n\r\n            <div className=\"session-duration\">\r\n              <h3 className=\"duration\">DURATION: </h3>\r\n              <br></br>\r\n              <Timer initialTime={1000}>\r\n                {() => (\r\n                  <React.Fragment>\r\n                    <div className=\"timer\">\r\n                      <Timer.Minutes /> mins <Timer.Seconds /> secs\r\n                    </div>\r\n                  </React.Fragment>\r\n                )}\r\n              </Timer>\r\n              {showDecksOrPastSessionsHeader()}\r\n            </div>\r\n            <ProgressBar\r\n              cards={sessionMaterials.cards}\r\n              dispatch={setIsDone}\r\n              setNextCard={setNextCardIndex}\r\n              addCardDataToLocalStorage={addCardDataToLocalStorage}\r\n              currentCard={sessionMaterials.cards[nextCardIndex]}\r\n              currentResult={result}\r\n              setResult={setResult}\r\n            ></ProgressBar>\r\n            <CardFlip\r\n              front={sessionMaterials.cards[nextCardIndex].front}\r\n              back={sessionMaterials.cards[nextCardIndex].back}\r\n              attributes={sessionMaterials.cards[nextCardIndex].attributes}\r\n            ></CardFlip>\r\n            <div style={{ textAlign: \"center\", marginTop: \"3em\" }}>\r\n              <input\r\n                alt=\"correct\"\r\n                type=\"image\"\r\n                src={CorrectBtn}\r\n                style={{ width: \"3em\", marginRight: \"4em\" }}\r\n                onClick={() => {\r\n                  setResult(\"Correct!\");\r\n                  addCardDataToLocalStorage(\r\n                    { ...sessionMaterials.cards[nextCardIndex], nextCardIndex },\r\n                    nextCardIndex,\r\n                    true\r\n                  );\r\n                }}\r\n              />\r\n              <input\r\n                alt=\"wrong\"\r\n                type=\"image\"\r\n                src={WrongBtn}\r\n                style={{ width: \"3em\" }}\r\n                onClick={() => {\r\n                  setResult(\"Try again!\");\r\n                  debug(result);\r\n                  addCardDataToLocalStorage(\r\n                    { ...sessionMaterials.cards[nextCardIndex], nextCardIndex },\r\n                    nextCardIndex,\r\n                    false\r\n                  );\r\n                }}\r\n              />\r\n            </div>\r\n            <h2>{result}</h2>\r\n          </div>\r\n        )}\r\n      </>\r\n    );\r\n  } else {\r\n    return <CircularProgress></CircularProgress>;\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport Paper from \"@material-ui/core/Paper\";\r\nimport Table from \"@material-ui/core/Table\";\r\nimport TableBody from \"@material-ui/core/TableBody\";\r\nimport TableCell from \"@material-ui/core/TableCell\";\r\nimport TableContainer from \"@material-ui/core/TableContainer\";\r\nimport TableHead from \"@material-ui/core/TableHead\";\r\nimport TablePagination from \"@material-ui/core/TablePagination\";\r\nimport TableRow from \"@material-ui/core/TableRow\";\r\n\r\nexport enum ColumnType {\r\n  CARD_COLUMNS,\r\n  SUMMARY_COLUMNS,\r\n  DECK_COLUMNS,\r\n  SESSION_COLUMNS,\r\n}\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    width: \"100%\",\r\n  },\r\n  container: {\r\n    maxHeight: 520,\r\n  },\r\n});\r\n\r\nconst cardColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"front\", label: \"Front\", minWidth: 80, align: \"center\" },\r\n  { id: \"back\", label: \"Back\", minWidth: 80, align: \"center\" },\r\n  { id: \"score\", label: \"Score\", minWidth: 80, align: \"center\" },\r\n  { id: \"deck\", label: \"Deck\", minWidth: 80, align: \"center\" },\r\n];\r\n\r\nconst summaryColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"front\", label: \"Front\", minWidth: 80, align: \"center\" },\r\n  { id: \"back\", label: \"Back\", minWidth: 80, align: \"center\" },\r\n  { id: \"results\", label: \"Results\", minWidth: 80, align: \"center\" },\r\n  { id: \"deck\", label: \"Deck\", minWidth: 80, align: \"center\" },\r\n  { id: \"tagsString\", label: \"Tags\", minWidth: 80, align: \"center\" }, // if we delete the tags column for stats, it would still be nice to leave it in for summary\r\n];\r\n\r\nconst deckColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"name\", label: \"Name\", minWidth: 20, align: \"center\" },\r\n  { id: \"count\", label: \"Card Count\", minWidth: 80, align: \"center\" },\r\n  { id: \"score\", label: \"Score\", minWidth: 80, align: \"center\" },\r\n];\r\n\r\nconst sessionColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"dateString\", label: \"Date\", minWidth: 80, align: \"center\" },\r\n  { id: \"count\", label: \"Card Count\", minWidth: 80, align: \"center\" },\r\n  { id: \"score\", label: \"Score\", minWidth: 80, align: \"center\" },\r\n  { id: \"duration\", label: \"Duration(secs)\", minWidth: 80, align: \"center\" },\r\n  { id: \"decksString\", label: \"Decks\", minWidth: 80, align: \"center\" },\r\n];\r\ntype Props = { rows: any[]; columnType: ColumnType };\r\n\r\nexport default function StatisticsTable(props: Props) {\r\n  const { rows, columnType } = props;\r\n  const classes = useStyles();\r\n  const [page, setPage] = React.useState(0);\r\n  const [rowsPerPage, setRowsPerPage] = React.useState(10);\r\n\r\n  let columns = null;\r\n  switch (columnType) {\r\n    case ColumnType.CARD_COLUMNS: {\r\n      columns = cardColumns;\r\n      break;\r\n    }\r\n    case ColumnType.SUMMARY_COLUMNS: {\r\n      columns = summaryColumns;\r\n      break;\r\n    }\r\n    case ColumnType.DECK_COLUMNS: {\r\n      columns = deckColumns;\r\n      break;\r\n    }\r\n    case ColumnType.SESSION_COLUMNS: {\r\n      columns = sessionColumns;\r\n      break;\r\n    }\r\n  }\r\n\r\n  const handleChangePage = (event: unknown, newPage: number) => {\r\n    setPage(newPage);\r\n  };\r\n\r\n  const handleChangeRowsPerPage = (\r\n    event: React.ChangeEvent<HTMLInputElement>\r\n  ) => {\r\n    setRowsPerPage(+event.target.value);\r\n    setPage(0);\r\n  };\r\n\r\n  return (\r\n    <Paper className={classes.root}>\r\n      <TableContainer className={classes.container}>\r\n        <Table stickyHeader aria-label=\"sticky table\">\r\n          <TableHead>\r\n            <TableRow>\r\n              {columns.map((column) => (\r\n                <TableCell\r\n                  key={column.id}\r\n                  align=\"center\"\r\n                  style={{ minWidth: column.minWidth }}\r\n                >\r\n                  {column.label}\r\n                </TableCell>\r\n              ))}\r\n            </TableRow>\r\n          </TableHead>\r\n          <TableBody>\r\n            {rows\r\n              .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)\r\n              .map((row) => {\r\n                return (\r\n                  <TableRow\r\n                    hover\r\n                    role=\"checkbox\"\r\n                    tabIndex={-1}\r\n                    key={`${row.indexString}_${row.front}`}\r\n                  >\r\n                    {columns.map((column) => {\r\n                      const value = row[column.id];\r\n                      return (\r\n                        <TableCell key={column.id} align=\"center\">\r\n                          {value}\r\n                        </TableCell>\r\n                      );\r\n                    })}\r\n                  </TableRow>\r\n                );\r\n              })}\r\n          </TableBody>\r\n        </Table>\r\n      </TableContainer>\r\n      <TablePagination\r\n        rowsPerPageOptions={[10, 25, 100]}\r\n        component=\"div\"\r\n        count={rows.length}\r\n        rowsPerPage={rowsPerPage}\r\n        page={page}\r\n        onChangePage={handleChangePage}\r\n        onChangeRowsPerPage={handleChangeRowsPerPage}\r\n      />\r\n    </Paper>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport \"./styles.css\";\r\n\r\nfunction renderHeaderRow(overview) {\r\n  return (\r\n    overview &&\r\n    Object.keys(overview.overview).map((overviewKey) => {\r\n      return (\r\n        <td key={overviewKey} className=\"overViewTable\">\r\n          {overviewKey}\r\n        </td>\r\n      );\r\n    })\r\n  );\r\n}\r\n\r\nfunction renderValueRow(overview) {\r\n  return (\r\n    overview &&\r\n    Object.values(overview.overview).map((overviewValue, index) => {\r\n      return (\r\n        <th\r\n          key={`${overviewValue.toString()}_${index}`}\r\n          className=\"overViewTable\"\r\n        >\r\n          {overviewValue}\r\n        </th>\r\n      );\r\n    })\r\n  );\r\n}\r\n\r\nfunction StatsOverview(overview) {\r\n  return (\r\n    <>\r\n      <table className=\"overViewTable\">\r\n        <tbody className=\"overViewTable\">\r\n          <tr key=\"statsOverviewHeading\" className=\"overViewTable\">\r\n            {renderHeaderRow(overview)}\r\n          </tr>\r\n          <tr key=\"statsOverviewValues\" className=\"overViewTable\">\r\n            {renderValueRow(overview)}\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default StatsOverview;\r\n","import React, { useState, useEffect } from \"react\";\r\nimport StatisticsTable from \"./StatisticsTable\";\r\nimport StatisticsOverview from \"./StatisticsOverview\";\r\nimport { ColumnType } from \"./StatisticsTable\";\r\nimport {\r\n  createCardData,\r\n  createDeckData,\r\n  createSessionData,\r\n} from \"../lib/utils\";\r\nimport { ComplexCommandParams } from \"../App\";\r\nimport { SubjectType as Subject } from \"../ast/SUBJECT\";\r\nimport {\r\n  getSelectedDecks,\r\n  getCardsFromSelectedDecks,\r\n  cardFilter,\r\n  getCardsFromSelectedSessions,\r\n  deckFilter,\r\n  getDeckNameFromID,\r\n  calculateDeckScore,\r\n  getPastSessions,\r\n  sessionFilter,\r\n  getUniqueDeckNamesFromSessions,\r\n} from \"../model/query\";\r\nimport { CircularProgress } from \"@material-ui/core\";\r\nimport Card from \"../model/Card\";\r\nimport Deck from \"../model/Deck\";\r\nimport Session from \"../model/Session\";\r\nimport SessionCard from \"../model/SessionCard\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\n\r\ntype Props = { complexCommandParams: ComplexCommandParams };\r\n\r\nenum View {\r\n  LOADING,\r\n  READY,\r\n  ERROR,\r\n}\r\n\r\ntype StatsObject = any; // can add typing here\r\n\r\ntype StatsState =\r\n  | {\r\n      view: View.LOADING;\r\n    }\r\n  | {\r\n      view: View.READY;\r\n      statsObject: StatsObject;\r\n    }\r\n  | {\r\n      view: View.ERROR;\r\n      error: Error;\r\n    };\r\n\r\nexport default function Statistics(props: Props) {\r\n  // Initialize the view to be \"Loading\" since we need to do asynchronous operation before showing data\r\n  const initialState: StatsState = { view: View.LOADING };\r\n  const [state, setState] = useState<StatsState>(initialState);\r\n  const database = useDatabase();\r\n\r\n  const {\r\n    limit,\r\n    filter,\r\n    isLimitAppliedToCards,\r\n    deckNames,\r\n    subject,\r\n  } = props.complexCommandParams;\r\n\r\n  async function createStatsObject() {\r\n    const {\r\n      rows,\r\n      highestScore,\r\n      lowestScore,\r\n      averageScore,\r\n    } = await getDetails();\r\n    return {\r\n      overview: {\r\n        \"average score\": averageScore,\r\n        \"highest score\": highestScore,\r\n        \"lowest score\": lowestScore,\r\n      },\r\n      details: rows,\r\n      columnType: getColumnType(),\r\n    };\r\n  }\r\n\r\n  async function getDetails() {\r\n    let rows = [];\r\n    let highestScore: number = NaN;\r\n    let lowestScore: number = NaN;\r\n    let averageScore: number = NaN;\r\n    let index = 1;\r\n    if (isLimitAppliedToCards) {\r\n      let retrievedCards: Array<Card>;\r\n      if (subject === Subject.Decks) {\r\n        retrievedCards = await getCardsFromSelectedDecks(database, deckNames);\r\n      } else if (subject === Subject.Sessions) {\r\n        retrievedCards = await getCardsFromSelectedSessions(database, limit);\r\n      } else {\r\n        throw new Error(\r\n          `Retrieving stats for cards from ${subject} is not supported`\r\n        );\r\n      }\r\n      const filteredCards: Array<Card> = cardFilter(\r\n        retrievedCards,\r\n        filter,\r\n        limit\r\n      );\r\n      let totalScore = 0;\r\n      for (let card of filteredCards) {\r\n        const score: number = card.right / (card.wrong + card.right);\r\n        totalScore += score;\r\n        highestScore =\r\n          isNaN(highestScore) || score > highestScore ? score : highestScore;\r\n        lowestScore =\r\n          isNaN(lowestScore) || score < lowestScore ? score : lowestScore;\r\n        rows = rows.concat(\r\n          createCardData(\r\n            index,\r\n            card.front,\r\n            card.back,\r\n            card.right,\r\n            card.wrong,\r\n            await getDeckNameFromID(database, card.deck_id)\r\n          )\r\n        );\r\n        index += 1;\r\n      }\r\n      averageScore = Number((totalScore / filteredCards.length).toFixed(2));\r\n    } else if (subject === Subject.Decks) {\r\n      const retrievedDecks = await getSelectedDecks(database, deckNames);\r\n      let filteredDecks: Array<Deck> = await deckFilter(\r\n        retrievedDecks,\r\n        filter,\r\n        limit\r\n      );\r\n      for (let deck of filteredDecks) {\r\n        const cards = await deck.cards.fetch();\r\n        const score = Number(calculateDeckScore(cards).toFixed(2));\r\n        rows = rows.concat(\r\n          createDeckData(index, deck.name, cards.length, score)\r\n        );\r\n        highestScore =\r\n          isNaN(highestScore) || score > highestScore ? score : highestScore;\r\n        lowestScore =\r\n          isNaN(lowestScore) || score < lowestScore ? score : lowestScore;\r\n        index += 1;\r\n      }\r\n      averageScore = Number(\r\n        (\r\n          rows.reduce(function (sum, a) {\r\n            return sum + a.score;\r\n          }, 0) / (rows.length || 1)\r\n        ).toFixed(2)\r\n      );\r\n    } else if (subject === Subject.Sessions) {\r\n      const retrievedSessions = await getPastSessions(database, limit);\r\n      let filteredSessions: Array<Session> = await sessionFilter(\r\n        database,\r\n        retrievedSessions,\r\n        filter,\r\n        limit\r\n      );\r\n      let totalScore = 0;\r\n      for (let session of filteredSessions) {\r\n        const deckNames = await getUniqueDeckNamesFromSessions(\r\n          database,\r\n          session\r\n        );\r\n        const sessionCards: Array<SessionCard> = (await session.sessionCards) as Array<\r\n          SessionCard\r\n        >;\r\n        let numberCorrect = 0;\r\n        sessionCards.forEach((c) => {\r\n          numberCorrect += c.is_correct ? 1 : 0;\r\n        });\r\n        let score = Number((numberCorrect / sessionCards.length).toFixed(2));\r\n        score = isNaN(score) ? 0 : score;\r\n        highestScore =\r\n          isNaN(highestScore) || score > highestScore ? score : highestScore;\r\n        lowestScore =\r\n          isNaN(lowestScore) || score < lowestScore ? score : lowestScore;\r\n        rows = rows.concat(\r\n          createSessionData(\r\n            index,\r\n            sessionCards.length,\r\n            numberCorrect,\r\n            session.started_at,\r\n            session.ended_at,\r\n            deckNames\r\n          )\r\n        );\r\n        index += 1;\r\n        totalScore += score;\r\n      }\r\n      averageScore = Number((totalScore / filteredSessions.length).toFixed(2));\r\n    } else {\r\n      throw new Error(\r\n        \"Command not currently supported: \" + props.complexCommandParams\r\n      );\r\n    }\r\n    return { rows, highestScore, lowestScore, averageScore };\r\n  }\r\n\r\n  function getColumnType() {\r\n    if (isLimitAppliedToCards) {\r\n      return ColumnType.CARD_COLUMNS;\r\n    }\r\n    switch (subject) {\r\n      case Subject.Decks: {\r\n        return ColumnType.DECK_COLUMNS;\r\n      }\r\n      case Subject.Sessions: {\r\n        return ColumnType.SESSION_COLUMNS;\r\n      }\r\n      case Subject.Tags: {\r\n        return ColumnType.DECK_COLUMNS;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Asynchronously load the data and change the state when done\r\n  useEffect(() => {\r\n    const setStatsObject = async () => {\r\n      try {\r\n        const statsObject = await createStatsObject();\r\n        setState({ view: View.READY, statsObject });\r\n      } catch (err) {\r\n        setState({ view: View.ERROR, error: err });\r\n      }\r\n    };\r\n    setStatsObject();\r\n  }, [props.complexCommandParams]);\r\n\r\n  // Conditionally render loading screen, error message, or the actual data\r\n  // Feel free to change this however you'd like, this is just some placeholder\r\n  if (state.view === View.LOADING) {\r\n    return <CircularProgress style={{ margin: \"auto\" }}></CircularProgress>;\r\n  } else if (state.view === View.ERROR) {\r\n    console.log(state.error);\r\n    return (\r\n      <h1 style={{ margin: \"auto\" }}>\r\n        Something went wrong when trying to fetch the stats\r\n      </h1>\r\n    );\r\n  } else {\r\n    return (\r\n      <>\r\n        <div className=\"right-side-container\">\r\n          <h1> Statistics</h1>\r\n          <StatisticsOverview overview={state.statsObject.overview} />\r\n          <StatisticsTable\r\n            rows={state.statsObject.details}\r\n            columnType={state.statsObject.columnType}\r\n          />\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport CardFlip from \"./CardFlip\";\r\n\r\nexport default function DeckViewDetails(props) {\r\n  return (\r\n    <>\r\n      <div className=\"session-container\" style={{ textAlign: \"center\" }}>\r\n        <h1>Deck: {props.name}</h1>\r\n        {props.deck.deck.cards.map((c) => {\r\n          return <CardFlip front={c.front} back={c.back}></CardFlip>;\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport StatisticsTable from \"./StatisticsTable\";\r\nimport { ColumnType } from \"./StatisticsTable\";\r\nimport { createSummaryData } from \"../lib/utils\";\r\n\r\nconst ConfettiEmoji = \"https://daranguyen.com/assets/confetti_emoji.png\";\r\n\r\nfunction getSessionCards() {\r\n  const sessionDataString = localStorage.getItem(\"sessionData\");\r\n  const sessionData = sessionDataString && JSON.parse(sessionDataString);\r\n  const endedAt = sessionData[\"ended_at\"];\r\n  const createdAt = sessionData[\"created_at\"];\r\n  const endedAtObj = new Date(endedAt);\r\n  const createdAtObj = new Date(createdAt);\r\n  const totalTimeInMS = endedAtObj.getTime() - createdAtObj.getTime();\r\n  const totalMinutes = Math.floor(totalTimeInMS / 60000);\r\n  const totalSeconds = ((totalTimeInMS % 60000) / 1000).toFixed(0);\r\n  const totalTime = `${totalMinutes} min ${totalSeconds} sec`;\r\n  const cardDataArray = sessionData[\"cardDataArray\"];\r\n  const cardSummaryDataArray =\r\n    cardDataArray &&\r\n    sessionData[\"cardDataArray\"].map((c) => {\r\n      return createSummaryData(\r\n        c[\"card_index\"] + 1,\r\n        c[\"front\"],\r\n        c[\"back\"],\r\n        c[\"is_correct\"],\r\n        c[\"deck\"],\r\n        c[\"tags\"]\r\n      );\r\n    });\r\n  return {\r\n    overview: { \"total time\": totalTime },\r\n    details: cardSummaryDataArray || [],\r\n  };\r\n}\r\n\r\nfunction getSessionScore(cardArray: any[]): [string, boolean] {\r\n  const reducer = (accumulator, currentValue) => {\r\n    const cardNumerator =\r\n      currentValue && currentValue.results === \"correct\" ? 1 : 0;\r\n    return accumulator + cardNumerator;\r\n  };\r\n  const numerator = cardArray.reduce(reducer, 0);\r\n  const denominator = cardArray.length;\r\n\r\n  const numeratorString = numerator && numerator.toString();\r\n  const denominatorString = denominator && denominator.toString();\r\n\r\n  const sessionScore = [numeratorString, denominatorString].join(\"/\");\r\n  const isAllCorrect = numerator === denominator && denominator !== 0;\r\n\r\n  return [sessionScore, isAllCorrect];\r\n}\r\n\r\nexport default function PostSessionSummary() {\r\n  const sessionCards = getSessionCards();\r\n  const [score, isAllCorrect]: [string, boolean] = getSessionScore(\r\n    sessionCards.details\r\n  );\r\n\r\n  return (\r\n    <div className=\"right-side-container\">\r\n      <h1>Summary</h1>\r\n      <br />\r\n      <h2>You got: {score} cards correct</h2>\r\n      {isAllCorrect && <h2>Good job!!</h2>}\r\n      {isAllCorrect && (\r\n        <img className=\"confetti\" src={ConfettiEmoji} alt={\"Confetti\"} />\r\n      )}\r\n      <br />\r\n      <h3>Time spent: {sessionCards.overview[\"total time\"]}</h3>\r\n      <br />\r\n      <StatisticsTable\r\n        rows={sessionCards.details}\r\n        columnType={ColumnType.SUMMARY_COLUMNS}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","import React, { useReducer } from \"react\";\r\nimport \"./App.css\";\r\nimport NavBar from \"./components/NavBar\";\r\nimport DeckView from \"./components/DeckView\";\r\nimport CardEditor from \"./components/CardEditor\";\r\nimport CommandEditor from \"./components/CommandEditor\";\r\nimport Session from \"./components/Session\";\r\nimport Statistics from \"./components/Statistics\";\r\nimport ListView from \"./components/ListView\";\r\nimport PROGRAM from \"./ast/PROGRAM\";\r\nimport { getInitialData } from \"./lib/getIintialData\";\r\nimport { createOrUpdateAllDecks } from \"./lib/reconciler\";\r\nimport { SubjectType as Subject } from \"./ast/SUBJECT\";\r\n\r\nimport DeckViewDetails from \"./components/DeckViewDetails\";\r\nimport ErrorMessage from \"./components/ErrorMessage\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\n\r\nimport PostSessionSummary from \"./components/PostSessionSummary\";\r\nimport { CircularProgress } from \"@material-ui/core\";\r\nimport {\r\n  getSelectedDecks,\r\n  deckFilter,\r\n  Filter,\r\n  getCardsFromSelectedDecks,\r\n} from \"./model/query\";\r\n\r\nimport { debug, randomize } from \"./lib/utils\";\r\n\r\nimport CREATE_DECK from \"./ast/CREATE_DECK\";\r\nimport { checkSessionCommandError } from \"./lib/sessionHelperFunctions\";\r\n\r\nconst CustomListView = ({ program, dispatch }) => {\r\n  return (\r\n    <div className=\"card-view-container\">\r\n      <div className=\"card-view\">\r\n        <div\r\n          style={{\r\n            display: \"grid\",\r\n            gridTemplateColumns: \"1fr 1fr\",\r\n            justifyItems: \"center\",\r\n          }}\r\n        >\r\n          <ListView\r\n            deckNames={program.create_decks.map((deck) => {\r\n              return deck.name;\r\n            })}\r\n            dispatch={dispatch}\r\n          ></ListView>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// What screen the UI should be showing\r\nexport enum View {\r\n  DECK,\r\n  STATS,\r\n  SESSION,\r\n  POST_SESSION,\r\n  LIST,\r\n  DECK_DETAIL,\r\n  ERROR,\r\n  LOADING,\r\n}\r\n\r\nexport type ComplexCommandParams = {\r\n  limit?: number;\r\n  filter?: Filter;\r\n  isLimitAppliedToCards?: boolean;\r\n  deckNames?: string[];\r\n  subject: Subject;\r\n  tagNames?: string[];\r\n};\r\n\r\ntype State = {\r\n  view: View;\r\n  program: PROGRAM;\r\n  cardEditor?: CodeMirror.Editor;\r\n  subjectToList: Subject;\r\n  deckToViewDetail?: string;\r\n  complexCommandParams?: ComplexCommandParams;\r\n};\r\n\r\nexport enum ActionType {\r\n  SetCardEditor = \"set card editor\",\r\n  CardEditorParseSuccess = \"card editor parse success\",\r\n  StartSession = \"start session\",\r\n  PostSession = \"post session\",\r\n  List = \"list\",\r\n  ViewDeckDetail = \"view deck detail\",\r\n  ShowStats = \"show stats\",\r\n  LoadDecks = \"load decks\",\r\n  CommandNotFound = \"command not found\",\r\n  QuitToHome = \"quit to home\",\r\n}\r\n\r\nexport type Action =\r\n  | {\r\n      type: ActionType.SetCardEditor; // Enables \"Load decks\" to work\r\n      cardEditor: CodeMirror.Editor;\r\n    }\r\n  | {\r\n      type: ActionType.CardEditorParseSuccess;\r\n      program: PROGRAM;\r\n    }\r\n  | {\r\n      type: ActionType.StartSession;\r\n      limit?: number;\r\n      filter?: Filter;\r\n      isLimitAppliedToCards?: boolean;\r\n      deckNames?: string[];\r\n      subject: Subject;\r\n      tagNames?: string[];\r\n    }\r\n  | {\r\n      type: ActionType.List;\r\n      listOption: \"decks\" | \"tags\";\r\n      // tags not implemented\r\n    }\r\n  | {\r\n      type: ActionType.ViewDeckDetail;\r\n      deckName: string;\r\n    }\r\n  | {\r\n      type: ActionType.ShowStats;\r\n      limit: number;\r\n      filter?: Filter;\r\n      isLimitAppliedToCards?: boolean;\r\n      deckNames?: string[];\r\n      subject: Subject;\r\n    }\r\n  | {\r\n      type: ActionType.LoadDecks;\r\n      createDSLValue: string;\r\n    }\r\n  | {\r\n      type: ActionType.QuitToHome;\r\n    }\r\n  | {\r\n      type: ActionType.CommandNotFound;\r\n    }\r\n  | {\r\n      type: ActionType.PostSession;\r\n    }; // Add actions here\r\n\r\nconst reducer = (state: State, action: Action): State => {\r\n  debug(\"Dispatched to App: \", action);\r\n  switch (action.type) {\r\n    // Add action handlers here\r\n    case \"set card editor\": {\r\n      return {\r\n        ...state,\r\n        cardEditor: action.cardEditor,\r\n      };\r\n    }\r\n    case \"card editor parse success\": {\r\n      return {\r\n        ...state,\r\n        program: action.program,\r\n        view: View.DECK,\r\n      };\r\n    }\r\n    case \"start session\": {\r\n      console.log(\"Start session action received\");\r\n      return {\r\n        ...state,\r\n        complexCommandParams: {\r\n          limit: action.limit,\r\n          filter: action.filter,\r\n          isLimitAppliedToCards: action.isLimitAppliedToCards,\r\n          deckNames: action.deckNames,\r\n          subject: action.subject,\r\n          tagNames: action.tagNames,\r\n        },\r\n        view: View.SESSION,\r\n      };\r\n    }\r\n    case \"show stats\": {\r\n      return {\r\n        ...state,\r\n        view: View.STATS,\r\n        complexCommandParams: {\r\n          limit: action.limit,\r\n          filter: action.filter,\r\n          isLimitAppliedToCards: action.isLimitAppliedToCards,\r\n          deckNames: action.deckNames,\r\n          subject: action.subject, // if deckNames is null then it is from past sessions\r\n        },\r\n      };\r\n    }\r\n    case \"list\": {\r\n      return {\r\n        ...state,\r\n        view: View.LIST,\r\n      };\r\n    }\r\n    case \"post session\": {\r\n      return {\r\n        ...state,\r\n        view: View.POST_SESSION,\r\n      };\r\n    }\r\n    case \"quit to home\": {\r\n      return {\r\n        ...state,\r\n        view: View.DECK,\r\n      };\r\n    }\r\n    case \"view deck detail\": {\r\n      return {\r\n        ...state,\r\n        view: View.DECK_DETAIL,\r\n        deckToViewDetail: action.deckName,\r\n      };\r\n    }\r\n    case \"load decks\": {\r\n      state.cardEditor.getDoc().setValue(action.createDSLValue);\r\n      return state;\r\n    }\r\n    case \"command not found\": {\r\n      return {\r\n        ...state,\r\n        view: View.ERROR,\r\n      };\r\n    }\r\n    default:\r\n      break;\r\n  }\r\n  debug(\"Unexpected end of reducer dispatch!\");\r\n  return state;\r\n};\r\n\r\nexport default function App() {\r\n  // Get initial data once from localStorage\r\n  const { isFirstTimeUser, initialText, initialProgram } = getInitialData(); // TODO: Also find session information from localStorage\r\n\r\n  const db = useDatabase();\r\n\r\n  if (isFirstTimeUser) {\r\n    createOrUpdateAllDecks(initialProgram, db);\r\n  }\r\n\r\n  const initialState: State = {\r\n    view: View.DECK,\r\n    program: initialProgram, // The \"source of truth\" until Goi gives user more card management\r\n\r\n    cardEditor: undefined,\r\n    deckToViewDetail: undefined,\r\n    subjectToList: undefined,\r\n    complexCommandParams: {\r\n      limit: undefined,\r\n      filter: undefined,\r\n      isLimitAppliedToCards: undefined, // SUBJECT_MODIFIER::selectedCards boolean attribute\r\n      deckNames: undefined,\r\n      subject: Subject.Undefined, // if deckNames is null then it is from past sessions\r\n    },\r\n  };\r\n\r\n  const [\r\n    { view, program, deckToViewDetail, complexCommandParams },\r\n    dispatch,\r\n  ] = useReducer(reducer, initialState);\r\n\r\n  const showView = (view: View) => {\r\n    if (view !== View.SESSION && view !== View.POST_SESSION) {\r\n      localStorage.removeItem(\"sessionData\");\r\n    }\r\n    switch (view) {\r\n      case View.DECK: {\r\n        return <DeckView program={program} dispatch={dispatch}></DeckView>;\r\n      }\r\n      case View.POST_SESSION: {\r\n        return <PostSessionSummary />;\r\n      }\r\n      case View.LIST: {\r\n        return (\r\n          <>\r\n            <CustomListView\r\n              program={program}\r\n              dispatch={dispatch}\r\n            ></CustomListView>\r\n          </>\r\n        );\r\n      }\r\n      case View.SESSION: {\r\n        return (\r\n          <Session\r\n            dispatch={dispatch}\r\n            complexCommandParams={complexCommandParams}\r\n            program={program}\r\n          ></Session>\r\n        );\r\n      }\r\n      case View.STATS: {\r\n        return (\r\n          <Statistics complexCommandParams={complexCommandParams}></Statistics>\r\n        );\r\n      }\r\n      case View.DECK_DETAIL: {\r\n        console.log(deckToViewDetail);\r\n        return (\r\n          <DeckViewDetails\r\n            name={deckToViewDetail}\r\n            deck={\r\n              program.create_decks.filter((d) => {\r\n                return d.name === deckToViewDetail;\r\n              })[0]\r\n            }\r\n          ></DeckViewDetails>\r\n        );\r\n      }\r\n      case View.ERROR: {\r\n        return (\r\n          <ErrorMessage message=\"Command not found. Type 'Help'\"></ErrorMessage>\r\n        );\r\n      }\r\n      case View.LOADING: {\r\n        return <CircularProgress style={{ margin: \"auto\" }} />;\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"navbar\">\r\n        <NavBar></NavBar>\r\n      </div>\r\n      <div className=\"container\" style={{ backgroundColor: \"#fafafa\" }}>\r\n        {/*gives CardEditor the ability to change Deck view */}\r\n        <CardEditor\r\n          dispatch={dispatch}\r\n          program={program}\r\n          initialText={initialText}\r\n          isInSession={view === View.SESSION}\r\n        ></CardEditor>\r\n        <CommandEditor dispatch={dispatch}></CommandEditor>\r\n        {showView(view)}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import {\r\n  appSchema,\r\n  tableSchema,\r\n  ColumnType,\r\n  ColumnSchema,\r\n} from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"./constants\";\r\n\r\nfunction columnSchema(\r\n  name: string,\r\n  type: ColumnType,\r\n  isIndexed?: boolean\r\n): ColumnSchema {\r\n  return {\r\n    name,\r\n    type,\r\n    isIndexed,\r\n  };\r\n}\r\n\r\n// ERD: https://drive.google.com/file/d/1lpoQcutNxBkVubtkJHgOVcD3UjohvQpm/view\r\n\r\n// Following suggested naming convention: plural snake case\r\n// https://nozbe.github.io/WatermelonDB/Schema.html\r\n\r\n// All tables automatically have a string column id to uniquely identify records\r\nexport default appSchema({\r\n  version: 1,\r\n  tables: [\r\n    tableSchema({\r\n      name: TableName.DECKS,\r\n      columns: [\r\n        columnSchema(\"name\", \"string\"),\r\n        columnSchema(\"created_at\", \"number\"), // automatic https://nozbe.github.io/WatermelonDB/Advanced/CreateUpdateTracking.html\r\n      ],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.CARDS,\r\n      columns: [\r\n        columnSchema(\"created_at\", \"number\"), // automatic\r\n        columnSchema(\"updated_at\", \"number\"), // automatic\r\n        columnSchema(\"last_tested_at\", \"number\"),\r\n        columnSchema(\"deck_id\", \"string\", true),\r\n        columnSchema(\"front\", \"string\", true),\r\n        columnSchema(\"back\", \"string\", true),\r\n        columnSchema(\"wrong\", \"number\"),\r\n        columnSchema(\"right\", \"number\"),\r\n      ],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.SESSIONS,\r\n      columns: [\r\n        columnSchema(\"started_at\", \"number\"), // manual\r\n        columnSchema(\"ended_at\", \"number\"), // manual\r\n      ],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.SESSIONS_CARDS,\r\n      columns: [\r\n        columnSchema(\"session_id\", \"string\", true),\r\n        columnSchema(\"card_id\", \"string\", true),\r\n        columnSchema(\"is_correct\", \"boolean\"),\r\n      ],\r\n    }),\r\n\r\n    // To have card tags we need to change EBNF, however it would be a huge improvement over deck tags\r\n    tableSchema({\r\n      name: TableName.TAGS,\r\n      columns: [columnSchema(\"name\", \"string\", true)],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.TAGS_CARDS,\r\n      columns: [\r\n        columnSchema(\"tag_id\", \"string\", true),\r\n        columnSchema(\"card_id\", \"string\", true),\r\n      ],\r\n    }),\r\n  ],\r\n});\r\n","import { Model } from \"@nozbe/watermelondb\";\r\nimport { date, field } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class Card extends Model {\r\n  static table = TableName.CARDS;\r\n  static associations: Associations = {\r\n    [TableName.DECKS]: { type: \"belongs_to\", key: \"deck_id\" },\r\n    [TableName.TAGS_CARDS]: { type: \"has_many\", foreignKey: \"card_id\" },\r\n    [TableName.SESSIONS_CARDS]: { type: \"has_many\", foreignKey: \"card_id\" },\r\n  };\r\n\r\n  @date(\"created_at\") created_at;\r\n  @date(\"updated_at\") updated_at;\r\n  @date(\"last_tested_at\") last_tested_at;\r\n  @field(\"deck_id\") deck_id;\r\n  @field(\"front\") front;\r\n  @field(\"back\") back;\r\n  @field(\"wrong\") wrong;\r\n  @field(\"right\") right;\r\n}\r\n","import { Model, Query } from \"@nozbe/watermelondb\";\r\nimport { children, date, field, action } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\nimport Card from \"./Card\";\r\n\r\nexport default class Deck extends Model {\r\n  static table = TableName.DECKS;\r\n  static associations: Associations = {\r\n    [TableName.CARDS]: { type: \"has_many\", foreignKey: \"deck_id\" },\r\n  };\r\n\r\n  @field(\"name\") name;\r\n  @date(\"created_at\") created_at;\r\n  @children(TableName.CARDS) cards: Query<Card>;\r\n\r\n  @action async addCard(front: string, back: string) {\r\n    return await this.collections.get(TableName.CARDS).create((card: Card) => {\r\n      card.deck_id = this.id;\r\n      card.front = front;\r\n      card.back = back;\r\n    });\r\n  }\r\n}\r\n","import { Model, Q } from \"@nozbe/watermelondb\";\r\nimport { date, lazy } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class Session extends Model {\r\n  static table = TableName.SESSIONS;\r\n  static associations: Associations = {\r\n    [TableName.SESSIONS_CARDS]: { type: \"has_many\", foreignKey: \"session_id\" },\r\n  };\r\n\r\n  @date(\"started_at\") started_at;\r\n  @date(\"ended_at\") ended_at;\r\n\r\n  @lazy cards = this.collections\r\n    .get(TableName.CARDS)\r\n    .query(Q.on(TableName.SESSIONS_CARDS, \"session_id\", this.id))\r\n    .fetch();\r\n\r\n  @lazy sessionCards = this.collections\r\n    .get(TableName.SESSIONS_CARDS)\r\n    .query(Q.where(\"session_id\", this.id))\r\n    .fetch();\r\n}\r\n","import { Model } from \"@nozbe/watermelondb\";\r\nimport { field } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class SessionCard extends Model {\r\n  static table = TableName.SESSIONS_CARDS;\r\n  static associations: Associations = {\r\n    [TableName.SESSIONS]: { type: \"belongs_to\", key: \"session_id\" },\r\n    [TableName.CARDS]: { type: \"belongs_to\", key: \"card_id\" },\r\n  };\r\n\r\n  @field(\"session_id\") session_id;\r\n  @field(\"card_id\") card_id;\r\n  @field(\"is_correct\") is_correct;\r\n}\r\n","import { Model, Q } from \"@nozbe/watermelondb\";\r\nimport { field, lazy } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class Tag extends Model {\r\n  static table = TableName.TAGS;\r\n  static associations: Associations = {\r\n    [TableName.TAGS_CARDS]: { type: \"has_many\", foreignKey: \"tag_id\" },\r\n  };\r\n\r\n  @field(\"name\") name;\r\n\r\n  @lazy cards = this.collections\r\n    .get(TableName.CARDS)\r\n    .query(Q.on(TableName.TAGS_CARDS, \"tag_id\", this.id))\r\n    .fetch();\r\n}\r\n","import { Model } from \"@nozbe/watermelondb\";\r\nimport { field } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class TagCard extends Model {\r\n  static table = TableName.TAGS_CARDS;\r\n  static associations: Associations = {\r\n    [TableName.TAGS]: { type: \"belongs_to\", key: \"tag_id\" },\r\n    [TableName.CARDS]: { type: \"belongs_to\", key: \"card_id\" },\r\n  };\r\n\r\n  @field(\"tag_id\") tag_id;\r\n  @field(\"card_id\") card_id;\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nimport { Database } from \"@nozbe/watermelondb\";\r\nimport LokiJSAdapter from \"@nozbe/watermelondb/adapters/lokijs\";\r\nimport DatabaseProvider from \"@nozbe/watermelondb/DatabaseProvider\";\r\nimport schema from \"./model/schema\";\r\nimport Card from \"./model/Card\";\r\nimport Deck from \"./model/Deck\";\r\nimport Session from \"./model/Session\";\r\nimport SessionCard from \"./model/SessionCard\";\r\nimport Tag from \"./model/Tag\";\r\nimport TagCard from \"./model/TagCard\";\r\n\r\nconst adapter = new LokiJSAdapter({\r\n  schema,\r\n  useWebWorker: false,\r\n  useIncrementalIndexedDB: true,\r\n});\r\n\r\nconst database = new Database({\r\n  adapter,\r\n  modelClasses: [Card, Deck, Session, SessionCard, Tag, TagCard],\r\n  actionsEnabled: true,\r\n});\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <DatabaseProvider database={database}>\r\n      <App />\r\n    </DatabaseProvider>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}