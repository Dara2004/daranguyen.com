{"version":3,"sources":["assets/wrongBtn.svg","assets/correctBtn.svg","assets/confettiEmoji.png","components/NavBar.tsx","components/NewCard.tsx","components/ListView.tsx","components/DeckView.tsx","lib/utils.ts","lib/tokenizer.ts","ast/NODE.js","ast/CARD.ts","ast/DECK.ts","ast/TAG.ts","ast/TAGS.ts","ast/ATTRIBUTE.ts","ast/ATTRIBUTES.ts","ast/CREATE_DECK.ts","ast/PROGRAM.ts","lib/constants.ts","lib/highlighter.ts","lib/guesser.ts","model/constants.ts","lib/reconciler.ts","lib/getIintialData.ts","components/CardEditor.tsx","ast/SUBJECT.ts","ast/DECKS.ts","ast/SESSIONS.ts","ast/SUBJECT_MODIFIER.ts","ast/COMPLEX_COMMAND.ts","ast/HELP.ts","ast/LIST.ts","ast/EXPORT_DECKS.ts","ast/LOAD_DECKS.ts","ast/QUIT_TO_HOME.ts","ast/COMMAND.ts","components/CommandEditor.tsx","components/ProgressBar.tsx","components/SingleCard.tsx","components/CardFlip.tsx","model/query.ts","lib/sessionHelperFunctions.ts","components/ErrorMessage.tsx","components/Session.tsx","components/StatisticsTable.tsx","components/StatisticsOverview.tsx","components/Statistics.tsx","components/DeckViewDetails.tsx","components/PostSessionSummary.tsx","App.tsx","serviceWorker.js","model/schema.ts","model/Card.ts","model/Deck.ts","model/Session.ts","model/SessionCard.ts","model/Tag.ts","model/TagCard.ts","index.js"],"names":["module","exports","NavBar","style","backgroundColor","useStyles","makeStyles","theme","createStyles","root","media","height","paddingTop","expand","transform","marginLeft","transition","transitions","create","duration","shortest","expandOpen","avatar","NewCard","props","classes","React","useState","expanded","setExpanded","marginTop","width","display","flexDirection","className","CardHeader","title","CardContent","Typography","paragraph","front","CardActions","disableSpacing","IconButton","clsx","onClick","aria-expanded","aria-label","Collapse","in","timeout","unmountOnExit","alignItems","back","Deck","Paper","margin","justifyItems","fontSize","console","log","name","dispatch","type","deckName","ListView","deckNames","map","idx","key","DeckView","program","decks","create_decks","cd","deck","length","textAlign","lastDeck","cards","color","gridTemplateColumns","debug","isDebugEnabled","debugDB","items","process","toLowerCase","shuffle","arr","sort","Math","random","createCardData","index","correct","incorrect","score","toString","indexString","createDeckData","count","createSessionData","startDate","endDate","decksString","join","startDateConverted","Date","endDateConverted","dateString","diffMs","round","randomize","subjects","shuffledCards","i","j","floor","temp","Tokenizer","content","literalsList","tokens","currentToken","literals","this","tokenize","tokenizedProgram","replace","forEach","s","re","RegExp","slicedArray","split","slice","t","trim","filter","token","regexp","checkNext","match","getNext","Error","theTokenizer","NODE","tokenizer","getTokenizer","CARD","cardNumber","getAndCheckToken","checkToken","parseInt","DECK","moreTokens","card","parse","push","TAG","tagName","TAGS","tags","tag","ATTRIBUTE","attribute","attributeType","value","currentAttribute","ATTRIBUTES","attributes","invalidNameTokens","CREATE_DECK","includes","checkForAndParseTags","checkForAndParseAttributes","checkForAndParseDeck","PROGRAM","create_deck","validCardFilter","allTokens","deckCreationLiterals","highlight","editor","doc","getDoc","lines","ranges","line","lineNumber","literal","indexOf","charStart","charEnd","getHighlights","getValue","markText","ch","GuessType","guessCardActionInDeck","oldDeck","newDeck","oldDeckCards","newDeckCards","CopyPasteSingleDeck","Delete","oldCards","updatedCards","newCards","uc","CreateCard","guessNewCard","guessCardAction","oldDecks","newDecks","numDifferences","firstDifference","undefined","od","nd","compareDeckLengths","CopyPasteMultiDecks","singleDifference","UpdateCardBack","oldBack","newBack","UpdateCardFront","oldFront","newFront","Nothing","guessCardUpdate","guess","prev","curr","oldDeckNames","newDecksFound","CreateDeck","guessNewDeck","list2","differingNames","reduce","acc","deck1","deck2","cards1","cards2","find","c1","c2","haveSameCards","UpdateDeckName","oldDeckName","newDeckName","guessPossiblyRenamedDeck","TableName","updateDeckName","oldName","newName","db","a","collections","get","DECKS","action","query","Q","where","eq","fetch","foundDecks","update","createOrUpdateCard","subAction","addCard","CARDS","cardsQ","id","foundCards","createOrUpdateEntireDeck","createDeck","cardsCollection","fetchCount","cardFrontQ","cardsWithSameFront","cardBackQ","cardsWithSameBack","cardToUpdate","c","createOrUpdateAllDecks","guessedAction","defaultText","CardEditor","useDatabase","initialText","isInSession","options","mode","lineNumbers","editorDidMount","ActionType","SetCardEditor","cardEditor","onChange","data","localStorage","setItem","makeTokenizer","JSON","stringify","reconcile","then","catch","err","CardEditorParseSuccess","SubjectType","SESSIONS","SUBJECT","subject","subjectType","Undefined","nextToken","Sessions","Decks","Tags","parseInteractivePrompt","SUBJECT_MODIFIER","limit","selectCards","actionToken","isNaN","Number","constants","COMPLEX_COMMAND","subjectModfier","HELP","LIST","option","EXPORT_DECKS","dataString","getItem","fakeAnchor","document","createElement","href","encodeURIComponent","download","toISOString","click","LOAD_DECKS","QUIT_TO_HOME","COMMAND","command","evaluate","helpMsg","lineHeight","startSessionOrStats","CommandEditor","openHelp","setOpenHelp","handleCloseHelp","event","reason","startsWith","setValue","setCursor","isHelpCommand","listNode","List","listOption","QuitToHome","fakeInput","onchange","e","file","target","files","fileReader","FileReader","readAsText","onload","deckCreationDSL","result","LoadDecks","createDSLValue","isStartSessionOrShowStats","modifier","isTagsSubject","StartSession","ShowStats","isLimitAppliedToCards","tagNames","CommandNotFound","Snackbar","anchorOrigin","vertical","horizontal","open","autoHideDuration","onClose","message","Fragment","size","ProgressBar","setNextCard","addCardDataToLocalStorage","currentCard","currentResult","setResult","useTheme","activeStep","setActiveStep","MobileStepper","variant","steps","position","nextButton","Button","prevActiveStep","disabled","direction","backButton","SingleCard","gutterBottom","CardFlip","isFlipped","setIsFlipped","handleClick","preventDefault","curState","flipDirection","Filter","getSelectedDecks","decksCollection","oneOf","getDeckNameFromID","getUniqueDeckNamesFromSessions","session","deckIds","sessionCards","sessionCard","foundDeckIds","card_id","deck_id","deckId","getCardsFromSelectedDecks","concat","getAllSessions","sessionsCollection","getPastSessions","n","allSessions","b","started_at","getCardsFromSelectedSessions","allCards","sessions","uniqueCards","cardFilter","BEST","right","wrong","WORST","NEWEST","created_at","OLDEST","RANDOM","deckFilter","deckScoreMap","Map","calculateDeckScore","set","sessionFilter","sessionsScoreMap","getSessionScore","rightCount","wrongCount","sessionCardsCollection","SESSIONS_CARDS","totalCards","sc","is_correct","cardIds","Set","has","add","getValidDeckNames","requestedDeckNames","validDeckNames","deckNamesInProgram","dn","actualDeckName","Object","keys","selectedCreateDecks","selectedCards","cardWithDeck","getCardsFromDecksNoFilter","splice","getCardStatsFromDB","selectedCardsSet","cardsWithStats","createdAt","getCardsFromDecksWithFilter","card1","card2","decksFromDB","filteredDecks","filteredDecksSet","filteredCreateDecks","getCardsFromDecks","getCardsFromTags","createDeckTags","hasASelectedTag","getCardsFromSessions","deckIdToDeckName","flashCards","addTagsToFlashCard","getSessionMaterialsWithTags","complexCommandParams","getSessionMaterials","sessionMaterials","flashCard","Alert","elevation","spacing","ErrorMessage","state","setState","handleClose","severity","nextCardIndex","gotCorrect","cardDataArray","sessionDataObject","newSessionDataObject","sessionData","currentCardID","cardData","card_index","alreadyAdded","o","alreadyAddedIndex","sessionsTable","cardTable","deckTable","sessionCardTable","deckNameToDeckModel","ended_at","createdSession","matchedCards","deckModel","cardModel","cm","last_tested_at","session_id","addEndTimeToSessionDataInLocalStorage","endedAt","currentSessionData","saveSessionDataToDB","Session","isDone","setIsDone","setNextCardIndex","setSessionMaterials","isLoading","setIsLoading","error","setError","useEffect","sessionCommandErr","activeDeckNames","matchedDeckNames","findIndex","possibleTags","giveError","checkSessionCommandError","nowString","initialData","initialDataString","_getSessionMaterials","PostSession","CircularProgress","initialTime","Minutes","Seconds","Subject","deckname","numPastSessionsString","showDecksOrPastSessionsHeader","alt","src","CorrectBtn","marginRight","WrongBtn","ColumnType","container","maxHeight","cardColumns","label","minWidth","align","summaryColumns","deckColumns","sessionColumns","StatisticsTable","rows","columnType","page","setPage","rowsPerPage","setRowsPerPage","columns","CARD_COLUMNS","SUMMARY_COLUMNS","DECK_COLUMNS","SESSION_COLUMNS","TableContainer","Table","stickyHeader","TableHead","TableRow","column","TableCell","TableBody","row","hover","role","tabIndex","TablePagination","rowsPerPageOptions","component","onChangePage","newPage","onChangeRowsPerPage","StatsOverview","View","overview","overviewKey","renderHeaderRow","values","overviewValue","renderValueRow","Statistics","initialState","view","LOADING","database","createStatsObject","getDetails","highestScore","lowestScore","averageScore","details","getColumnType","NaN","retrievedCards","filteredCards","retrievedDecks","retrievedSessions","filteredSessions","numberCorrect","sum","statsObject","READY","ERROR","setStatsObject","StatisticsOverview","DeckViewDetails","PostSessionSummary","sessionDataString","endedAtObj","createdAtObj","totalTimeInMS","getTime","totalMinutes","totalSeconds","toFixed","isCorrect","results","tagsString","createSummaryData","getSessionCards","cardArray","numerator","accumulator","currentValue","denominator","isAllCorrect","ConfettiEmoji","CustomListView","reducer","SESSION","STATS","POST_SESSION","DECK_DETAIL","deckToViewDetail","App","savedText","lastAstJsonStr","isFirstTimeUser","initialProgram","getInitialData","subjectToList","useReducer","removeItem","d","showView","Boolean","window","location","hostname","columnSchema","isIndexed","appSchema","version","tables","tableSchema","TAGS_CARDS","Card","date","field","Model","table","associations","foreignKey","children","lazy","on","SessionCard","Tag","TagCard","adapter","LokiJSAdapter","schema","useWebWorker","useIncrementalIndexedDB","Database","modelClasses","actionsEnabled","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"+EAAAA,EAAOC,QAAU,IAA0B,sC,oBCA3CD,EAAOC,QAAU,IAA0B,wC,oBCA3CD,EAAOC,QAAU,IAA0B,2C,qNCE5B,SAASC,IACtB,OACE,oCACE,yBAAKC,MAAO,CAAEC,gBAAiB,UAC7B,qC,qHCYFC,EAAYC,aAAW,SAACC,GAAD,OAC3BC,YAAa,CACXC,KAAM,GAGNC,MAAO,CACLC,OAAQ,EACRC,WAAY,UAEdC,OAAQ,CACNC,UAAW,eACXC,WAAY,OACZC,WAAYT,EAAMU,YAAYC,OAAO,YAAa,CAChDC,SAAUZ,EAAMU,YAAYE,SAASC,YAGzCC,WAAY,CACVP,UAAW,kBAEbQ,OAAQ,CACNlB,gBAAiB,YAOR,SAASmB,EAAQC,GAC9B,IAAMC,EAAUpB,IAD4B,EAEZqB,IAAMC,UAAS,GAFH,mBAErCC,EAFqC,KAE3BC,EAF2B,KAQ5C,OACE,oCACE,kBAAC,IAAD,CACE1B,MAAO,CACL2B,UAAW,MACXC,MAAO,OACPC,QAAS,OACTC,cAAe,UAEjBC,UAAWT,EAAQhB,MAEnB,kBAAC0B,EAAA,EAAD,CAAYC,MAAM,KAClB,kBAACC,EAAA,EAAD,KACE,yBAAKlC,MAAO,CAAEQ,OAAQ,MAAOmB,UAAW,QACtC,kBAACQ,EAAA,EAAD,CAAYC,WAAS,EAACpC,MAAO,IAC1BqB,EAAMgB,SAIb,kBAACC,EAAA,EAAD,CAAaC,gBAAc,GACzB,kBAACC,EAAA,EAAD,CACET,UAAWU,YAAKnB,EAAQZ,OAAT,eACZY,EAAQJ,WAAaO,IAExBiB,QA5BgB,WACxBhB,GAAaD,IA4BLkB,gBAAelB,EACfmB,aAAW,aAEX,kBAAC,IAAD,QAGJ,kBAACC,EAAA,EAAD,CAAUC,GAAIrB,EAAUsB,QAAQ,OAAOC,eAAa,GAClD,kBAACd,EAAA,EAAD,CACElC,MAAO,CACL2B,UAAW,QAGb,yBAAK3B,MAAO,CAAEQ,OAAQ,MAAOyC,WAAY,WACvC,kBAACd,EAAA,EAAD,CAAYC,WAAS,GAAEf,EAAM6B,W,aCpF3C,SAASC,EAAK9B,GACZ,OACE,kBAAC+B,EAAA,EAAD,CACEpD,MAAO,CACLqD,OAAQ,MACRzB,MAAO,OACPpB,OAAQ,OACR8C,aAAc,SACdzB,QAAS,OACT0B,SAAU,SAEZb,QAAS,WACPc,QAAQC,IAAIpC,EAAMqC,MAClBrC,EAAMsC,SAAS,CAAEC,KAAM,mBAAoBC,SAAUxC,EAAMqC,SAG7D,yBAAK1D,MAAO,CAAEqD,OAAQ,SAAWhC,EAAMqC,OAK9B,SAASI,EAASzC,GAC/B,OACE,oCACGA,EAAM0C,UAAUC,KAAI,SAACH,EAAUI,GAAX,OACnB,kBAAC,EAAD,CAAMC,IAAKD,EAAKP,KAAMG,EAAUF,SAAUtC,EAAMsC,eCtBzC,SAASQ,EAAT,GAMX,IAAD,EALDC,EAKC,EALDA,QACAT,EAIC,EAJDA,SAKMU,EAAa,OAAGD,QAAH,IAAGA,GAAH,UAAGA,EAASE,oBAAZ,aAAG,EAAuBN,KAAI,SAACO,GAAD,OAAQA,EAAGC,QAC5D,IAAKH,GAA0B,IAAjBA,EAAMI,OAClB,OACE,yBAAKzE,MAAO,CAAE0E,UAAW,WACvB,8FAIN,IAAMC,EAAWN,EAAMA,EAAMI,OAAS,GATrC,EAUuBE,EAASC,MAAMD,EAASC,MAAMH,OAAS,GAAvDpC,EAVP,EAUOA,MAAOa,EAVd,EAUcA,KAEf,OACE,oCACE,yBAAKnB,UAAU,uBACb,yBAAKA,UAAU,aACb,wBAAI/B,MAAO,CAAE6E,MAAO,YAApB,SACST,EAAQE,aAAaF,EAAQE,aAAaG,OAAS,GAAGf,MAE/D,kBAACtC,EAAD,CAASiB,MAAOA,EAAOa,KAAMA,IAC7B,yBACElD,MAAO,CACL2B,UAAW,MACXE,QAAS,OACTiD,oBAAqB,YAGvB,kBAAChB,EAAD,CACEC,UAAWK,EAAQE,aAAaN,KAAI,SAACO,GAAD,OAAQA,EAAGb,QAC/CC,SAAUA,Q,gEC7CjB,SAASoB,IACS,IAAD,EAAlBC,MACF,EAAAxB,SAAQC,IAAR,mBAIG,SAASwB,IAA8B,IAAD,uBAAlBC,EAAkB,yBAAlBA,EAAkB,gBAC3CH,EAAK,WAAL,GAAM,iBAAN,OAAgBG,IAGlB,SAASF,IACP,MAEgD,OAA9CG,KAA4BC,cAIzB,SAASC,EAAWC,GACzB,OAAOA,EAAIC,MAAK,kBAAMC,KAAKC,SAAW,MAGjC,SAASC,EACdC,EACAtD,EACAa,EACA0C,EACAC,EACArB,GAEA,IAAMsB,EAAQF,EAAQG,WAAa,KAAOF,EAAYD,GAASG,WAE/D,MAAO,CAAEC,YADWL,EAAMI,WAAa,KACjB1D,QAAOa,OAAM4C,QAAOtB,QA4BrC,SAASyB,EACdN,EACAjC,EACAwC,EACAJ,GAGA,MAAO,CAAEE,YADWL,EAAMI,WAAa,KACjBrC,OAAMwC,QAAOJ,SAG9B,SAASK,EACdR,EACAO,EACAN,EACAQ,EACAC,EACAhC,GAEA,IAAMyB,EAAQF,EAAQG,WAAa,IAAMG,EAAMH,WACzCO,EAAcjC,EAAMkC,KAAK,MACzBP,EAAcL,EAAMI,WAAa,KACjCS,GAAsB,IAAIC,KAAKL,GAC/BM,GAAoB,IAAID,KAAKJ,GAC7BM,EAAaH,EAAmBT,WAEhCa,EAASJ,EAAqBE,EAGpC,MAAO,CAAEV,cAAaW,aAAYT,QAAOJ,QAAO9E,SAFjCwE,KAAKqB,MAAQD,EAAS,MAAY,KAAW,KAEFN,eAIrD,SAASQ,EAAUC,GAExB,IADA,IAAIC,EAAgBD,EACXE,EAAID,EAAcvC,OAAS,EAAGwC,EAAI,EAAGA,IAAK,CACjD,IAAMC,EAAI1B,KAAK2B,MAAM3B,KAAKC,UAAYwB,EAAI,IACpCG,EAAOJ,EAAcC,GAC3BD,EAAcC,GAAKD,EAAcE,GACjCF,EAAcE,GAAKE,EAErB,OAAOJ,E,ICjGHK,E,WAOJ,WAAoBC,EAAiBC,GAA8B,yBAJ3DC,YAI0D,OAH1DC,kBAG0D,EAChEJ,EAAUjD,QAAUkD,EACpBD,EAAUK,SAAWH,EACrBI,KAAKH,OAAS,GACdG,KAAKF,aAAe,EAEpBE,KAAKC,W,uDAIL,IAAIC,EAAmBR,EAAUjD,QACjCyD,EAAmBA,EAAiBC,QAAQ,MAAO,KACnD/C,EAAMsC,EAAUjD,SAEhBiD,EAAUK,SAASK,SAAQ,SAACC,GAC1BjD,EAAM,WAAYiD,GAClB,IAAMC,EAAK,IAAIC,OAAOF,EAAG,MACzBjD,EAAM,WAAYkD,GAElBlD,EADA8C,EAAmBA,EAAiBC,QAAQG,EAAzB,WAAiCD,EAAjC,UAIrBjD,EADA8C,EAAmBA,EAAiBC,QAAQ,MAAO,MAEnD,IACMK,EADYN,EAAiBO,MAAM,KACXC,MAAM,GACpCV,KAAKH,OAASW,EAAYnE,KAAI,SAACsE,GAAD,OAAOA,EAAEC,UAAQC,QAAO,SAACF,GAAD,MAAa,KAANA,KAC7DvD,EAAM4C,KAAKH,U,kCAYX,OANIG,KAAKF,aAAeE,KAAKH,OAAO/C,OAC1BkD,KAAKH,OAAOG,KAAKF,cAEjB,mB,gCAOV,IAAIgB,EAAQ,GASZ,OAPId,KAAKF,aAAeE,KAAKH,OAAO/C,QAClCgE,EAAQd,KAAKH,OAAOG,KAAKF,cACzBE,KAAKF,gBAELgB,EAAQ,YAGHA,I,iCAGEC,GACT,IAAMV,EAAIL,KAAKgB,YACTV,EAAK,IAAIC,OAAOQ,GAEtB,OADA3D,EAAM,eAAD,OAAgBiD,EAAhB,mBAA4BU,EAA5B,QACIV,EAAEY,MAAMX,K,uCAGFS,GACf,IAAMV,EAAIL,KAAKkB,UACTZ,EAAK,IAAIC,OAAOQ,GAEtB,IAAKV,EAAEY,MAAMX,GACX,MAAMa,MAAM,mEAAD,OAC0DJ,EAD1D,qBAC6EV,IAI1F,OADAjD,EAAM,YAAD,OAAaiD,EAAb,iBAAuBU,IACrBV,I,mCAIP,OAAOL,KAAKF,aAAeE,KAAKH,OAAO/C,U,qCAGpB6C,EAAiBI,GACpCC,KAAKoB,aAAe,IAAI1B,EAAUC,EAASI,K,qCAI3C,OAAOC,KAAKoB,iB,KA1FV1B,EACWjD,a,EADXiD,EAEWK,c,EAFXL,EAKW0B,kB,EAyFF1B,QC9FM2B,E,iDACnBC,UAAY5B,EAAU6B,e,oDAEpB,MAAM,IAAIJ,MAAM,2B,iCAGhB,MAAM,IAAIA,MAAM,gC,KCNCK,E,4MACnBC,WAAqB,E,EACrB/G,MAAgB,G,EAChBa,KAAe,G,sDAIb,GAFAyE,KAAKsB,UAAUI,iBAAiB,QACZ1B,KAAKsB,UAAUK,WAAW,kBAQ5C,MAAM,IAAIR,MAAM,iCANhBnB,KAAKyB,WAAaG,SAAS5B,KAAKsB,UAAUJ,WAC1ClB,KAAKsB,UAAUI,iBAAiB,OAChC1B,KAAKtF,MAAQsF,KAAKsB,UAAUJ,UAC5BlB,KAAKsB,UAAUI,iBAAiB,KAChC1B,KAAKzE,KAAOyE,KAAKsB,UAAUJ,c,GAZCG,GCCbQ,E,4MACnB5E,MAAgB,G,sDAEd,KACE+C,KAAKsB,UAAUQ,eACd9B,KAAKsB,UAAUK,WAAW,eAC1B3B,KAAKsB,UAAUK,WAAW,mBAC1B3B,KAAKsB,UAAUK,WAAW,mBAC1B3B,KAAKsB,UAAUK,WAAW,cAC1B3B,KAAKsB,UAAUK,WAAW,gBAC3B,CACA,IAAII,EAAO,IAAIP,EACfO,EAAKC,QACLhC,KAAK/C,MAAMgF,KAAKF,Q,GAbYV,GCDba,E,4MACnBC,QAAkB,G,sDAEhBnC,KAAKmC,QAAUnC,KAAKsB,UAAUJ,c,GAHDG,GCCZe,E,4MACnBC,KAAc,G,EACdpG,KAAO,O,uEAIL,IADA+D,KAAKsB,UAAUI,iBAAiB,SACzB1B,KAAKsB,UAAUQ,cAAc,CAClC,IAAIQ,EAAM,IAAIJ,EACdI,EAAIN,QACJhC,KAAKqC,KAAKJ,KAAKK,GACoB,MAA/BtC,KAAKsB,UAAUN,aACjBhB,KAAKsB,UAAUJ,a,8BAWnB,IAJkB,aADAlB,KAAKsB,UAAUN,YAAYvD,eAE3CuC,KAAKsB,UAAUJ,UAEjBlB,KAAKsB,UAAUI,iBAAiB,KAE9B1B,KAAKsB,UAAUQ,eACd9B,KAAKsB,UAAUK,WAAW,eAC1B3B,KAAKsB,UAAUK,WAAW,mBAC1B3B,KAAKsB,UAAUK,WAAW,mBAC1B3B,KAAKsB,UAAUK,WAAW,QAC3B,CACmC,MAA/B3B,KAAKsB,UAAUN,aACjBhB,KAAKsB,UAAUJ,UAEjB,IAAIoB,EAAM,IAAIJ,EACdI,EAAIN,QACJhC,KAAKqC,KAAKJ,KAAKK,Q,GAlCajB,GCIbkB,E,4MACnBC,UAA0B,CAAEC,cAAe,GAAIC,MAAO,I,sDAGpD,IAAMC,EAAmB3C,KAAKsB,UAAUJ,UAExC,OADAlB,KAAKsB,UAAUI,iBAAiB,KACxBiB,GACN,IAAK,gBAEH,GADA3C,KAAKwC,UAAUC,cAAgB,aAC3BzC,KAAKsB,UAAUK,WAAW,qBAG5B,MAAM,IAAIR,MAAM,oCAFhBnB,KAAKwC,UAAUE,MAAQ1C,KAAKsB,UAAUJ,UAIxC,MACF,IAAK,gBAEH,GADAlB,KAAKwC,UAAUC,cAAgB,aAC3BzC,KAAKsB,UAAUK,WAAW,uBAG5B,MAAM,IAAIR,MAAM,oCAFhBnB,KAAKwC,UAAUE,MAAQ1C,KAAKsB,UAAUJ,UAIxC,MACF,IAAK,YAEH,GADAlB,KAAKwC,UAAUC,cAAgB,SAE7BzC,KAAKsB,UAAUK,WAAW,2CAI1B,MAAM,IAAIR,MAAM,gCAFhBnB,KAAKwC,UAAUE,MAAQ1C,KAAKsB,UAAUJ,UAIxC,MACF,QACE,Y,GAlC+BG,GCJlBuB,E,4MACnBC,WAA0B,G,sDAKxB,GAHsB7C,KAAKsB,UAAUK,WACnC,yCAGA,KACE3B,KAAKsB,UAAUQ,eACd9B,KAAKsB,UAAUK,WAAW,cAC1B3B,KAAKsB,UAAUK,WAAW,QAC3B,CACA,IAAIa,EAAY,IAAID,EACpBC,EAAUR,QACVhC,KAAK6C,WAAWZ,KAAKO,Q,GAdWnB,GCElCyB,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,aAE1BC,E,4MACnBV,KAAoB,K,EACpBQ,WAAgC,K,EAChChG,KAAoB,K,EACpBd,KAAe,G,qEAIK,aADAiE,KAAKsB,UAAUN,YAAYvD,gBAE3CuC,KAAKqC,KAAO,IAAID,EAChBpC,KAAKqC,KAAKL,W,mDAKRhC,KAAKsB,UAAUK,WAAW,2CAC5B3B,KAAK6C,WAAa,IAAID,EACtB5C,KAAK6C,WAAWb,W,6CAKdhC,KAAKsB,UAAUK,WAAW,SAC5B3B,KAAKnD,KAAO,IAAIgF,EAChB7B,KAAKnD,KAAKmF,W,8BAMZhC,KAAKsB,UAAUI,iBAAiB,eAChC,IAAM3F,EAAOiE,KAAKsB,UAAUJ,UAC5B,GAAI4B,EAAkBE,SAASjH,GAC7B,MAAM,IAAIoF,MAAM,qBAIlB,IAFAnB,KAAKjE,KAAOA,EACZiE,KAAKsB,UAAUI,iBAAiB,KACzB1B,KAAKsB,UAAUQ,cAAc,CAClC9B,KAAKiD,uBACLjD,KAAKkD,6BACLlD,KAAKmD,uBACL,W,GAzCmC9B,GCJpB+B,E,4MACnBzG,aAA8B,G,sDAE5B,KAAOqD,KAAKsB,UAAUQ,cAChB9B,KAAKsB,UAAUK,WAAW,gBADI,CAEhC,IAAI0B,EAAc,IAAIN,EACtBM,EAAYrB,QACZhC,KAAKrD,aAAasF,KAAKoB,Q,GAPMhC,GCSxBiC,GAAkB,CAAC,OAAQ,QAAS,SAAU,SAAU,UAGxDC,GAAS,UAAOD,GAfL,CACtB,iBACA,qBACA,OACA,OACA,eACA,aACA,OACA,eACA,IACA,cAG6B,CAAC,SAAU,QAAS,kBAItCE,GAAuB,CAAC,cAAe,IAAK,MAAO,MAAO,KCPhE,SAASC,GACdC,EACA3D,EACA3F,GAEA,IAAMuJ,EAAMD,EAAOE,UAYrB,SAAuBnH,EAAiBsD,GAEtC,IAAM8D,GADNpH,EAAUA,EAAQgB,eACIgD,MAAM,MACtBqD,EAAkB,GAaxB,OAZAD,EAAMzD,SAAQ,SAAC2D,EAAMC,GACnBjE,EAASK,SAAQ,SAAC6D,GAChB,IAAM3H,EAAMyH,EAAKG,QAAQD,IACZ,IAAT3H,GACFwH,EAAO7B,KAAK,CACV+B,aACAG,UAAW7H,EACX8H,QAAS9H,EAAM2H,EAAQnH,eAKxBgH,GA1BYO,CADLV,EAAIW,WACsBvE,GAC7BK,SAAQ,SAACqD,GAClBE,EAAIY,SACF,CAAER,KAAMN,EAAUO,WAAYQ,GAAIf,EAAUU,WAC5C,CAAEJ,KAAMN,EAAUO,WAAYQ,GAAIf,EAAUW,SAC5C,CAAEhK,UAAWA,GAAa,wB,IClBpBqK,G,6CAoNZ,SAASC,GACPC,EACAC,GACQ,IAAD,IACDC,EAAY,UAAGF,EAAQ9H,YAAX,aAAG,EAAcI,MAC7B6H,EAAY,UAAGF,EAAQ/H,YAAX,aAAG,EAAcI,MACnC,OAAoB,MAAhB4H,EACK,CACL5I,KAAMwI,GAAUM,oBAChB7I,SAAU0I,EAAQ7I,MAGF,MAAhB+I,GAMAD,EAAa/H,OAASgI,EAAahI,OAL9B,CACLb,KAAMwI,GAAUO,QAWdF,EAAahI,SAAW+H,EAAa/H,OAAS,EApEtD,SACEmI,EACAC,EACAhJ,GAGA,IADA,IAAMiJ,EAAmB,GAChB7F,EAAI,EAAGA,EAAI2F,EAASnI,SAAUwC,EAAG,CAAC,IAAD,EAChB2F,EAAS3F,GAAzB5E,EADgC,EAChCA,MAAOa,EADyB,EACzBA,KACT6J,EAAKF,EAAa5F,GACpB8F,EAAG1K,QAAUA,GAAS0K,EAAG7J,OAASA,GACpC4J,EAASlD,KAAKmD,GAIlB,GAAwB,IAApBD,EAASrI,OAAc,CAAC,IAAD,EACDoI,EAAaA,EAAapI,OAAS,GAAnDpC,EADiB,EACjBA,MAAOa,EADU,EACVA,KAEf,MAAO,CACLU,KAAMwI,GAAUY,WAChBnJ,WACAxB,QACAa,QAIJ,GAAwB,IAApB4J,EAASrI,OAAc,CAAC,IAAD,EACDqI,EAAS,GAAzBzK,EADiB,EACjBA,MAAOa,EADU,EACVA,KACf,MAAO,CACLU,KAAMwI,GAAUY,WAChBnJ,WACAxB,QACAa,QAKJ,MAAO,CACLU,KAAMwI,GAAUM,oBAChB7I,YAgCSoJ,CAAaT,EAAcC,EAAcH,EAAQ5I,MAGjD,CACLE,KAAMwI,GAAUM,oBAChB7I,SAAU0I,EAAQ7I,MA8E1B,SAASwJ,GACPC,EACAC,GACQ,IAAD,EA3KT,SAA4BD,EAAyBC,GACnD,IAAIC,EAAiB,EACjBC,OAAkBC,EAUtB,OATAJ,EAASpF,SAAQ,SAACyF,EAAIvJ,GAAS,IAAD,QACtBwJ,EAAKL,EAASnJ,IAChB,UAAAuJ,EAAGhJ,YAAH,mBAASI,aAAT,eAAgBH,WAAhB,UAA2BgJ,EAAGjJ,YAA9B,iBAA2B,EAASI,aAApC,aAA2B,EAAgBH,SAEtB,MADrB4I,IAEAC,EAAkBrJ,MAIjB,CAAEoJ,iBAAgBC,mBAgKmBI,CAC1CP,EACAC,GAFMC,EADD,EACCA,eAAgBC,EADjB,EACiBA,gBAIxB,OAAID,EAAiB,EACZ,CACLzJ,KAAMwI,GAAUuB,qBAGG,IAAnBN,EAIKhB,GAFSc,EAASG,GACTF,EAASE,IAxF7B,SACEH,EACAC,GAGA,IADA,IAAIQ,OAA0BL,EACrBtG,EAAI,EAAGA,EAAIkG,EAAS1I,SAAUwC,EAAG,CAAC,IAAD,IAClC2F,EAAQ,UAAGO,EAASlG,GAAGzC,YAAf,aAAG,EAAkBI,MAC7BkI,EAAQ,UAAGM,EAASnG,GAAGzC,YAAf,aAAG,EAAkBI,MACnC,GAAIgI,GAAYE,EACd,IAAK,IAAI5F,EAAI,EAAGA,EAAI0F,EAASnI,SAAUyC,EACrC,GACE0F,EAAS1F,GAAG7E,QAAUyK,EAAS5F,GAAG7E,OAClCuK,EAAS1F,GAAGhE,OAAS4J,EAAS5F,GAAGhE,KAInC,GACE0J,EAAS1F,GAAG7E,QAAUyK,EAAS5F,GAAG7E,OAClCuK,EAAS1F,GAAGhE,OAAS4J,EAAS5F,GAAGhE,KACjC,CACA,GAAI0K,EAEF,MAAO,CACLhK,KAAMwI,GAAUuB,qBAIpBC,EAAmB,CACjBhK,KAAMwI,GAAUyB,eAChBhK,SAAUsJ,EAASlG,GAAGvD,KACtBrB,MAAOuK,EAAS1F,GAAG7E,MACnByL,QAASlB,EAAS1F,GAAGhE,KACrB6K,QAASjB,EAAS5F,GAAGhE,UAElB,IACL0J,EAAS1F,GAAG7E,QAAUyK,EAAS5F,GAAG7E,OAClCuK,EAAS1F,GAAGhE,OAAS4J,EAAS5F,GAAGhE,KAkBjC,MAAO,CACLU,KAAMwI,GAAUuB,qBAjBlB,GAAIC,EAEF,MAAO,CACLhK,KAAMwI,GAAUuB,qBAIpBC,EAAmB,CACjBhK,KAAMwI,GAAU4B,gBAChBnK,SAAUsJ,EAASlG,GAAGvD,KACtBuK,SAAUrB,EAAS1F,GAAG7E,MACtB6L,SAAUpB,EAAS5F,GAAG7E,MACtBa,KAAM0J,EAAS1F,GAAGhE,OAY5B,OAAK0K,GAEI,CACLhK,KAAMwI,GAAU+B,SA4BbC,CAAgBjB,EAAUC,GAepB,SAASiB,GAAMC,EAAeC,GAC3C,IAAMpB,EAAWmB,EAAKhK,aAChB8I,EAAWmB,EAAKjK,aACtB,GAAI6I,EAAS1I,OAAS2I,EAAS3I,OAC7B,MAAO,CACLb,KAAMwI,GAAUO,QAGpB,GAAIQ,EAAS1I,OAAS2I,EAAS3I,OAC7B,OAAI0I,EAAS1I,SAAW2I,EAAS3I,OAAS,EA1T9C,SAAsB0I,EAAyBC,GAE7C,IAAMoB,EAAe,GACrBrB,EAASpF,SAAQ,SAACyF,GAChBgB,EAAahB,EAAG9J,OAAQ,KAE1B,IAAM+K,EAAgB,GAMtB,GALArB,EAASrF,SAAQ,SAAC0F,EAAIxJ,GACfuK,EAAaf,EAAG/J,OACnB+K,EAAc7E,KAAK,CAAElG,KAAM+J,EAAG/J,KAAMO,WAGX,IAAzBwK,EAAchK,OAAc,CAAC,IAAD,IACRgK,EAAc,GAA5B/K,EADsB,EACtBA,KAER,OADiB,UAAA0J,EAFa,EAChBnJ,KACiBO,KAAKI,aAAnB,eAA0BH,QAAS,EAO3C,CAELb,KAAMwI,GAAUM,oBAChB7I,SAAUH,GARL,CACLE,KAAMwI,GAAUsC,WAChB7K,SAAUH,GAYhB,MAAO,CACLE,KAAMwI,GAAUuB,qBA4RPgB,CAAaxB,EAAUC,GAGvB,CACLxJ,KAAMwI,GAAUuB,qBAMtB,IA/RAiB,EA+RMC,GA/RND,EA+RwDxB,EAAVD,EA7RjC2B,QACX,SAACC,EAAKC,EAAO/H,GAAb,OAAoB+H,EAAMtL,OAASkL,EAAM3H,GAAGvD,KAAOqL,EAAM,EAAIA,IAC7D,IA4RF,OAAIF,EAAiB,EACZ,CACLjL,KAAMwI,GAAUuB,qBAGG,IAAnBkB,EAtQN,SACE1B,EACAC,GAIA,IADA,IAAInJ,EAAM,EACHA,EAAMkJ,EAAS1I,QAChB0I,EAASlJ,GAAKP,OAAS0J,EAASnJ,GAAKP,QAGvCO,EAIJ,IAAMuJ,EAAKL,EAASlJ,GACdwJ,EAAKL,EAASnJ,GAEpB,OAxCF,SAAuB+K,EAAoBC,GAA8B,IAAD,YACtE,IAAI,UAAAD,EAAMxK,YAAN,mBAAYI,aAAZ,eAAmBH,WAAnB,UAA8BwK,EAAMzK,YAApC,iBAA8B,EAAYI,aAA1C,aAA8B,EAAmBH,QACnD,OAAO,EAET,GAAyB,OAArB,UAAAuK,EAAMxK,YAAN,eAAYI,QAAsC,OAArB,UAAAqK,EAAMzK,YAAN,eAAYI,OAE3C,OAAO,EAIT,IAAMsK,EAASF,EAAMxK,KAAKI,MACpBuK,EAASF,EAAMzK,KAAKI,MAE1B,OAAQsK,EAAOE,MAAK,SAACC,EAAIpL,GACvB,IAAMqL,EAAKH,EAAOlL,GAClB,OACEoL,EAAGjG,aAAekG,EAAGlG,YACrBiG,EAAGhN,QAAUiN,EAAGjN,OAChBgN,EAAGnM,OAASoM,EAAGpM,QAsBfqM,CAAc/B,EAAIC,GACb,CACL7J,KAAMwI,GAAUoD,eAChBC,YAAajC,EAAG9J,KAChBgM,YAAajC,EAAG/J,MAGX,CAELE,KAAMwI,GAAUM,oBAChB7I,SAAU4J,EAAG/J,MA4ORiM,CAAyBxC,EAAUC,GAIrCF,GAAgBC,EAAUC,I,SArYvBhB,K,yBAAAA,E,yBAAAA,E,kCAAAA,E,oCAAAA,E,kCAAAA,E,6CAAAA,E,6CAAAA,E,2BAAAA,E,mBAAAA,Q,SCJAwD,G,iBCSGC,G,uFAAf,WAA8BC,EAAiBC,EAAiBC,GAAhE,gBAAAC,EAAA,6DACEhL,EAAQ,kCAAD,OAAmC6K,EAAnC,eAAiDC,IAD1D,SAGU1L,EAAQ2L,EAAGE,YAAYC,IAAIP,GAAUQ,OAH/C,SAIUJ,EAAGK,OAAH,wBAAU,+BAAAJ,EAAA,sEACY5L,EACvBiM,MAAMC,KAAEC,MAAM,OAAQD,KAAEE,GAAGX,KAC3BY,QAHW,UAIY,KAHpBC,EADQ,QAIClM,OAJD,wBAKN6H,EAAUqE,EAAW,GALf,SAMNrE,EAAQsE,QAAO,SAACpM,GACpBA,EAAKd,KAAOqM,KAPF,OASZ9K,EAAQ,8BAAD,OAA+B6K,EAA/B,eAA6CC,IATxC,8BAWN,IAAIjH,MAAJ,8CACmC6H,EAAWlM,OAD9C,gCAC4EqL,EAD5E,MAXM,6CAJpB,uDAqBI7K,EAAQ,EAAD,IArBX,0D,+BAyBe4L,G,qFAAf,WAAkCxC,EAAc2B,GAAhD,gBAAAC,EAAA,yDAEI5B,EAAMzK,OAASwI,GAAU4B,iBACzBK,EAAMzK,OAASwI,GAAUyB,gBACzBQ,EAAMzK,OAASwI,GAAUY,WAJ7B,uBAMI/H,EAAQ,sDANZ,iCASEA,EAAQ,+CAAD,OAAgDoJ,EAAMxK,WAT/D,SAYUQ,EAAQ2L,EAAGE,YAAYC,IAAIP,GAAUQ,OAZ/C,SAcUJ,EAAGK,OAAH,wBAAU,6CAAAJ,EAAA,sEACY5L,EACvBiM,MAAMC,KAAEC,MAAM,OAAQD,KAAEE,GAAGpC,EAAMxK,YACjC6M,QAHW,UAIY,KAHpBC,EADQ,QAIClM,OAJD,oBAKZQ,EAAQ,6BACFT,EAAOmM,EAAW,GACpBtC,EAAMzK,OAASwI,GAAUY,WAPjB,wBAQV/H,EAAQ,sCAAD,OACiCoJ,EAAMhM,MADvC,oBACwDgM,EAAMnL,OAT3D,UAYJsB,EAAKsM,WAAU,kBAAMtM,EAAKuM,QAAQ1C,EAAMhM,MAAOgM,EAAMnL,SAZjD,eAaV+B,EAAQ,mCAAD,OAC8BoJ,EAAMhM,MADpC,oBACqDgM,EAAMnL,OAdxD,8BAoBN0B,EAAQoL,EAAGE,YAAYC,IAAIP,GAAUoB,OAEvC3C,EAAMzK,OAASwI,GAAU4B,gBAtBjB,wBAuBJiD,EAASrM,EAAM0L,MACnBC,KAAEC,MAAM,OAAQD,KAAEE,GAAGpC,EAAMnL,OAC3BqN,KAAEC,MAAM,QAASD,KAAEE,GAAGpC,EAAMJ,WAC5BsC,KAAEC,MAAM,UAAWD,KAAEE,GAAGjM,EAAK0M,MA1BrB,UA4BgBD,EAAOP,QA5BvB,WA6BgB,KADpBS,EA5BI,QA6BK1M,OA7BL,wBA8BRQ,EAAQ,6BACFyE,EAAOyH,EAAW,GA/BhB,UAgCFzH,EAAKkH,QAAO,SAAClH,GACjBA,EAAKrH,MAAQgM,EAAMH,YAjCb,QAmCRjJ,EAAQ,oCAnCA,8BAqCF,IAAI6D,MAAJ,kDACuCqI,EAAW1M,OADlD,8EArCE,mCAyCD4J,EAAMzK,OAASwI,GAAUyB,eAzCxB,wBA0CJoD,EAASrM,EAAM0L,MACnBC,KAAEC,MAAM,OAAQD,KAAEE,GAAGpC,EAAMP,UAC3ByC,KAAEC,MAAM,QAASD,KAAEE,GAAGpC,EAAMhM,QAC5BkO,KAAEC,MAAM,UAAWD,KAAEE,GAAGjM,EAAK0M,MA7CrB,UA+CgBD,EAAOP,QA/CvB,WAgDgB,KADpBS,EA/CI,QAgDK1M,OAhDL,wBAiDRQ,EAAQ,6BACFyE,EAAOyH,EAAW,GAlDhB,UAmDFzH,EAAKkH,QAAO,SAAClH,GACjBA,EAAKxG,KAAOmL,EAAMN,WApDZ,QAsDR9I,EAAQ,mCAtDA,8BAwDF,IAAI6D,MAAJ,kDACuCqI,EAAW1M,OADlD,8EAxDE,sCA8DN,IAAIqE,MAAJ,kDACuC6H,EAAWlM,OADlD,gCACgF4J,EAAMxK,SADtF,MA9DM,6CAdpB,yDAkFIoB,EAAQ,qBAAD,MAlFX,2D,+BAoHemM,G,qFAAf,WAAwCC,EAAyBrB,GAAjE,sBAAAC,EAAA,6DACQvM,EAAO2N,EAAW3N,KAClBkB,EAFR,UAEgByM,EAAW7M,YAF3B,aAEgB,EAAiBI,MAC/BK,EAAQ,2BAAD,OAA4BvB,EAA5B,gBAHT,SAKUW,EAAQ2L,EAAGE,YAAYC,IAAIP,GAAUQ,OAL/C,SAMUJ,EAAGK,OAAH,wBAAU,+BAAAJ,EAAA,sEACY5L,EACvBiM,MAAMC,KAAEC,MAAM,OAAQD,KAAEE,GAAG/M,KAC3BgN,QAHW,UAIY,KAHpBC,EADQ,QAIClM,OAJD,0CAAAwL,EAAA,yCAAAA,EAAA,6DAKZhL,EAAQ,8CALI,SAMWZ,EAAMtD,QAAO,SAACyD,GACnCA,EAAKd,KAAOA,KAPF,UAMN6I,EANM,OASZtH,EAAQ,aACJL,EAVQ,gCAWSA,GAXT,cAAAqL,EAAA,mCAAAA,EAAA,6DAWCvG,EAXD,QAYRzE,EAAQ,6BAAD,OACwByE,EAAKrH,MAD7B,mBAC6CqH,EAAKxG,KADlD,MAZC,SAgBFqJ,EAAQuE,WAAU,kBACtBvE,EAAQwE,QAAQrH,EAAKrH,MAAOqH,EAAKxG,SAjB3B,+QAoBV+B,EAAQ,wCApBE,eAsBZA,EAAQ,oBAAD,OAAqBvB,EAArB,gBAtBK,mMAyBY,IAAtBiN,EAAWlM,OAzBD,2CAAAwL,EAAA,2CAAAA,EAAA,yDA0BZhL,EAAQ,+EAGFT,EAAOmM,EAAW,IACpB/L,EA9BQ,iBA+BJ0M,EAAkBtB,EAAGE,YAAYC,IAAIP,GAAUoB,OA/B3C,eAgCSpM,GAhCT,cAAAqL,EAAA,mDAAAA,EAAA,6DAgCCvG,EAhCD,QAkCRzE,EAAQ,oCAAD,OAC+ByE,EAAKrH,MADpC,mBACoDqH,EAAKxG,KADzD,MAGD+N,EAASK,EAAgBhB,MAC7BC,KAAEC,MAAM,UAAWD,KAAEE,GAAGjM,EAAK0M,KAC7BX,KAAEC,MAAM,QAASD,KAAEE,GAAG/G,EAAKrH,QAC3BkO,KAAEC,MAAM,OAAQD,KAAEE,GAAG/G,EAAKxG,QAxCpB,SA0CY+N,EAAOM,aA1CnB,UA2CM,KADRrL,EA1CE,+BA4CNjB,EAAQ,uCAAD,OACkCyE,EAAKrH,MADvC,mBACuDqH,EAAKxG,KAD5D,MA5CD,0CAiDJgD,EAAQ,GAjDJ,wBAkDNjB,EAAQ,eAAD,OACUiB,EADV,kDACyDwD,EAAKrH,MAD9D,mBAC8EqH,EAAKxG,KADnF,MAlDD,6CAwDR+B,EAAQ,uDACFuM,EAAaF,EAAgBhB,MACjCC,KAAEC,MAAM,UAAWD,KAAEE,GAAGjM,EAAK0M,KAC7BX,KAAEC,MAAM,QAASD,KAAEE,GAAG/G,EAAKrH,SA3DrB,UA6DyBmP,EAAWd,QA7DpC,WA8D0B,KAD5Be,EA7DE,QA8DehN,OA9Df,wBAgENQ,EAAQ,iDACFyM,EAAYJ,EAAgBhB,MAChCC,KAAEC,MAAM,UAAWD,KAAEE,GAAGjM,EAAK0M,KAC7BX,KAAEC,MAAM,OAAQD,KAAEE,GAAG/G,EAAKxG,QAnEtB,UAqE0BwO,EAAUhB,QArEpC,WAsE2B,KAD3BiB,EArEA,QAsEgBlN,OAtEhB,wBAwEJQ,EAAQ,6BAAD,OACwByE,EAAKrH,MAD7B,mBAC6CqH,EAAKxG,KADlD,MAxEH,UA2EEsB,EAAKsM,WAAU,kBAAMtM,EAAKuM,QAAQrH,EAAKrH,MAAOqH,EAAKxG,SA3ErD,eA4EJ+B,EAAQ,2BA5EJ,yCA+E2B,IAA7B0M,EAAkBlN,OA/EhB,wBAiFEmN,EAAeD,EAAkB,GACvC1M,EAAQ,8DAlFJ,UAqFE2M,EAAahB,QAAO,SAACiB,GACzBA,EAAExP,MAAQqH,EAAKrH,SAtFb,eAwFJ4C,EAAQ,gCAxFJ,2CA2FF0M,EAAkBlN,OAAS,GA3FzB,wBA4FJQ,EAAQ,qBAAD,OACgB0M,EAAkBlN,OADlC,8CAC8EiF,EAAKxG,KADnF,MA5FH,yCAkG0B,IAA9BuO,EAAmBhN,OAlGf,wBAoGAmN,EAAeH,EAAmB,GACxCxM,EAAQ,8DArGF,UAwGA2M,EAAahB,QAAO,SAACiB,GACzBA,EAAE3O,KAAOwG,EAAKxG,QAzGV,eA2GN+B,EAAQ,+BA3GF,2CA8GJwM,EAAmBhN,OAAS,GA9GxB,wBA+GNQ,EAAQ,qBAAD,OACgBwM,EAAmBhN,OADnC,+CACgFiF,EAAKrH,MADrF,MA/GD,ieAuHN,IAAIyG,MAAJ,gBAAmB6H,EAAWlM,OAA9B,+BAvHM,6CANpB,uDAiIIQ,EAAQ,mCAAD,MAjIX,0D,sBAqIO,SAAe6M,GAAtB,qC,gDAAO,WAAsC1N,EAAkB4L,GAAxD,oBAAAC,EAAA,sDACLhL,EAAQ,sEADH,wBAGcb,EAAQE,cAHtB,gEAGQC,EAHR,iBAIK6M,GAAyB7M,EAAIyL,GAJlC,8IAMH/K,EACE,sEAPC,kDAUHA,EAAQ,iCAAD,MAVJ,wE,sEAsBQ,WACbqJ,EACAC,EACAyB,GAHa,wBAAAC,EAAA,sDAMbhL,EAAQ,kBADF8M,EAAgB1D,GAAMC,EAAMC,IALrB,KAQLwD,EAAcnO,KART,cASNwI,GAAU+B,SATJ,OAUN/B,GAAUO,OAVJ,SAYNP,GAAUoD,eAZJ,SAgBNpD,GAAU4B,iBAhBJ,OAiBN5B,GAAUyB,gBAjBJ,OAkBNzB,GAAUY,WAlBJ,UAqBNZ,GAAUM,qBArBJ,OAsBNN,GAAUsC,WAtBJ,UA2BNtC,GAAUuB,oBA3BJ,2DAaD8B,EAA6BsC,EAA7BtC,YAAaC,EAAgBqC,EAAhBrC,YAbZ,SAcHG,GAAeJ,EAAaC,EAAaM,GAdtC,0DAmBHa,GAAmBkB,EAAe/B,GAnB/B,iDAuBDnM,EAAakO,EAAblO,SACFW,EAAO+J,EAAKjK,aAAa8K,MAAK,SAAC7K,GAAD,OAAQA,EAAGb,OAASG,KAxB/C,UAyBHuN,GAAyB5M,EAAMwL,GAzB5B,2DA4BH8B,GAAuBvD,EAAMyB,GA5B1B,+E,gCDjTHJ,K,cAAAA,E,cAAAA,E,oBAAAA,E,gCAAAA,E,YAAAA,E,yBAAAA,Q,KEKL,IAIDoC,GAAW,0HCOjB,IAAMtK,GAAW,CAAC,cAAe,IAAK,IAAK,KAQ5B,SAASuK,GAAW5Q,GACjC,IAAM2O,EAAKkC,yBAEHC,EAA6B9Q,EAA7B8Q,YAAaC,EAAgB/Q,EAAhB+Q,YA8BrB,OACE,oCACE,yBAAKrQ,UAAU,eACZqQ,EACC,yBAAKrQ,UAAU,qCAAqCoQ,GAEpD,kBAAC,eAAD,CACE9H,MAAO8H,EACPE,QAAS,CACPC,KAAM,MACNlS,MAAO,aACPmS,aAAa,GAEfC,eAAgB,SAACnH,EAAQhB,GACvBe,GAAUC,EAAQ3D,IAClBrG,EAAMsC,SAAS,CACbC,KAAM6O,GAAWC,cACjBC,WAAYtH,KAGhBuH,SAhDW,SAACvH,EAA2BwH,EAAMxI,GACrDe,GAAUC,EAAQ3D,IAElBoL,aAAaC,QD1Be,mBC0BW1I,GAEvC,IACEhD,EAAU2L,cAAc3I,EAAOc,IAC/B,IAAM/G,EAAU,IAAI2G,EACpB3G,EAAQuF,QAG0B,IAAhCvF,EAAQE,aAAaG,QAC0C,OAA/DL,EAAQE,aAAaF,EAAQE,aAAaG,OAAS,GAAGD,KAEtDO,EAAM,4CAEN+N,aAAaC,QDxCI,aCwCeE,KAAKC,UAAU9O,IFoQxC,SAAf,uCElQQ+O,CAAU9R,EAAM+C,QAASA,EAAS4L,GAC/BoD,MAAK,kBAAMnO,EAAQ,qCACnBoO,OAAM,SAACC,GAAD,OAASrO,EAAQ,+BAAgCqO,MAC1DjS,EAAMsC,SAAS,CAAEC,KAAM6O,GAAWc,uBAAwBnP,aAE5D,MAAOkP,GACPvO,EAAMuO,KAyBAvR,UAAU,6B,WCzEVyR,GCHSpD,G,4MACnB/L,MAAkB,G,EAClBT,KAAO,Q,uEAIL,IADA+D,KAAKsB,UAAUI,iBAAiB,UACzB1B,KAAKsB,UAAUQ,cACpB9B,KAAKtD,MAAMuF,KAAKjC,KAAKsB,UAAUJ,WACI,MAA/BlB,KAAKsB,UAAUN,aACjBhB,KAAKsB,UAAUJ,c,GATYG,GCAdyK,G,4MACnB7P,KAAO,W,uEAEL+D,KAAKsB,UAAUI,iBAAiB,qB,GAHEL,I,SFG1BwK,K,cAAAA,E,oBAAAA,E,YAAAA,E,uBAAAA,Q,SAOSE,G,4MACnBC,QAA0C,K,EAC1CC,YAA2BJ,GAAYK,U,sDAGrC,IAAMC,EAAYnM,KAAKsB,UAAUN,YACjC,GAAkB,kBAAdmL,EACFnM,KAAKgM,QAAU,IAAIF,GACnB9L,KAAKiM,YAAcJ,GAAYO,cAC1B,GAAkB,WAAdD,EACTnM,KAAKgM,QAAU,IAAIvD,GACnBzI,KAAKiM,YAAcJ,GAAYQ,UAC1B,IAAkB,UAAdF,EAIT,MAAM,IAAIhL,MACR,kEAJFnB,KAAKgM,QAAU,IAAI5J,EACnBpC,KAAKiM,YAAcJ,GAAYS,KAMjCtM,KAAKgM,QAAQO,6B,GApBoBlL,GGThBmL,G,4MACnBvQ,KAAe,G,EACf4E,OAAiB,S,EACjB4L,MAAgB,I,EAChBC,aAAuB,E,sDAGrB,IAAMC,EAAc3M,KAAKsB,UAAUJ,UACnC,GAAoB,mBAAhByL,EACF3M,KAAK/D,KAAO,iBACP,IAAoB,uBAAhB0Q,EAGT,MAAM,IAAIxL,MACR,2EAHFnB,KAAK/D,KAAO,gBAMd,IAAIkQ,EAAYnM,KAAKsB,UAAUN,YAC1B4L,MAAMC,OAAOV,MAChBnM,KAAKyM,MAAQ5O,KAAKqB,MAAM2N,OAAO7M,KAAKsB,UAAUJ,YAC9CiL,EAAYnM,KAAKsB,UAAUN,aAEzB8L,GAA0B9J,SAASmJ,KACrCnM,KAAKa,OAASb,KAAKsB,UAAUJ,UAC7BiL,EAAYnM,KAAKsB,UAAUN,aAEX,eAAdmL,IACFnM,KAAK0M,aAAc,EACnB1M,KAAKsB,UAAUJ,e,GA5ByBG,GCCzB0L,G,4MACnBC,eAA0C,K,EAC1ChB,QAA0B,K,sDAExBhM,KAAKgN,eAAiB,IAAIR,GAC1BxM,KAAKgN,eAAehL,QAEpBhC,KAAKgM,QAAU,IAAID,GACnB/L,KAAKgM,QAAQhK,Y,GAR4BX,GCFxB4L,G,4MACnBhR,KAAe,G,sDAEb+D,KAAK/D,KAAO,OACZ+D,KAAKsB,UAAUI,iBAAiB,Y,GAJFL,GCAb6L,G,4MACnBC,OAAiB,G,sDAKf,GAFAnN,KAAKsB,UAAUI,iBAAiB,QAChC1B,KAAKmN,OAASnN,KAAKsB,UAAUJ,UACT,SAAhBlB,KAAKmN,QAAqC,UAAhBnN,KAAKmN,OACjC,MAAM,IAAIhM,MAAM,2B,GAPYE,GCAb+L,G,sKAEjBpN,KAAKsB,UAAUI,iBAAiB,kB,iCAIhC,IAAM2L,EAAalC,aAAamC,QAAQ,oBACpCC,EAAaC,SAASC,cAAc,KACxCF,EAAWG,KACT,iCAAmCC,mBAAmBN,GACxDE,EAAWK,SAAX,WAAyB,IAAI9O,MAAO+O,cAApC,QACAN,EAAWO,Y,GAX2BzM,GCArB0M,G,sKAEjB/N,KAAKsB,UAAUI,iBAAiB,kB,GAFIL,GCAnB2M,G,sKAEjBhO,KAAKsB,UAAUI,iBAAiB,6B,GAFML,GCMrB4M,G,4MACnBhS,KAAe,G,EACfiS,QAOW,K,sDAGT,IAAM/B,EAAYnM,KAAKsB,UAAUN,YAoBjC,GAnBkB,SAAdmL,GACFnM,KAAKkO,QAAU,IAAIjB,GACnBjN,KAAK/D,KAAO,QACW,SAAdkQ,GACTnM,KAAKkO,QAAU,IAAIhB,GACnBlN,KAAK/D,KAAO,QACW,iBAAdkQ,GACTnM,KAAKkO,QAAU,IAAId,GACnBpN,KAAK/D,KAAO,gBACW,eAAdkQ,GACTnM,KAAKkO,QAAU,IAAIH,GACnB/N,KAAK/D,KAAO,cACW,SAAdkQ,GAAsC,iBAAdA,GACjCnM,KAAKkO,QAAU,IAAIF,GACnBhO,KAAK/D,KAAO,iBAEZ+D,KAAKkO,QAAU,IAAInB,GACnB/M,KAAK/D,KAAO,mBAEO,OAAjB+D,KAAKkO,QACP,MAAM,IAAI/M,MAAM,6BAElBnB,KAAKkO,QAAQlM,U,iCAIbhC,KAAKkO,QAAQC,e,GAvCoB9M,G,+BCW/B+M,GACJ,yBACE/V,MAAO,CACLuD,SAAU,OACVyS,WAAY,QAGd,8DANF,sGASE,6DATF,oGAYE,8CAZF,yKAeE,uDAfF,wBAgBE,iEAhBF,sBAiBE,mDAjBF,mCAuBEC,GAA8B,GAkBnB,SAASC,GAAc7U,GAAe,IAAD,EAClBE,IAAMC,UAAS,GADG,mBAC3C2U,EAD2C,KACjCC,EADiC,KAG5CC,EAAkB,SACtBC,EACAC,GAEe,cAAXA,GAIJH,GAAY,IA8Fd,OACE,oCACE,yBAAKrU,UAAU,kBACb,kBAAC,eAAD,CACEsI,MAAO,oDACPgI,QAAS,CACPC,KAAM,MACNlS,MAAO,QACPmS,aAAa,GAEfC,eAAgB,SAACnH,EAAQhB,GACvBe,GAAUC,EAAQ3D,KAEpBkL,SAxGoB,SAACvH,EAA2BwH,EAAMxI,GAQ5D,GAPAe,GAAUC,EAAQ3D,IACb2C,EAAMmM,WAAW,QAEpBnL,EAAOE,SAASkL,SAAS,MACzBpL,EAAOE,SAASmL,UAAU,IAGxBrM,EAAMM,SAAS,MAAO,CACxB,IAAIgM,GAAgB,EAGpB,IACEtP,EAAU2L,cAAc3I,EAAO3C,IAC/B,IAAMmO,EAAU,IAAID,GAGpB,GAFAC,EAAQlM,QACRnG,QAAQC,IAAIoS,EAAQA,SACC,SAAjBA,EAAQjS,KAAiB,CAC3B,IAAMgT,EAAWf,EAAQA,QACD,UAApBe,EAAS9B,OACXzT,EAAMsC,SAAS,CAAEC,KAAM6O,GAAWoE,KAAMC,WAAY,UACvB,SAApBF,EAAS9B,OAClBzT,EAAMsC,SAAS,CAAEC,KAAM6O,GAAWoE,KAAMC,WAAY,SAEpDtT,QAAQC,IAAI,2BAA4BmT,EAAS9B,aAE9C,GAAqB,SAAjBe,EAAQjS,KACjB+S,GAAgB,OACX,GAAqB,iBAAjBd,EAAQjS,KACjBiS,EAAQC,gBACH,GAAqB,iBAAjBD,EAAQjS,KACjBvC,EAAMsC,SAAS,CAAEC,KAAM6O,GAAWsE,kBAC7B,GAAqB,eAAjBlB,EAAQjS,KAAuB,CACxC,IAAMoT,EAAY7B,SAASC,cAAc,SACzC4B,EAAUpT,KAAO,OAEjBoT,EAAUC,SAAW,SAACC,GACpB,IAAMC,EAAOD,EAAEE,OAAOC,MAAM,GACtBC,EAAa,IAAIC,WACvBD,EAAWE,WAAWL,EAAM,SAE5BG,EAAWG,OAAS,SAACP,GACnB,IAAMQ,EAAkBR,EAAEE,OAAOO,OACjCtW,EAAMsC,SAAS,CACbC,KAAM6O,GAAWmF,UACjBC,eAAgBH,MAItBV,EAAUvB,aACL,GAjFf,SAAmCI,GACjC,MAEc,kBADVA,EAAQA,QAA4BlB,eACnC/Q,MAEHqS,GAAsB,iBACf,GAGK,eADVJ,EAAQA,QAA4BlB,eACnC/Q,OAEHqS,GAAsB,cACf,GAqEQ6B,CAA0BjC,GAAU,CAC7C,IAAMkC,EAAYlC,EAAQA,QACvBlB,eACH,GAAIoD,EAAU,CACZ,IAAMC,EAEJ,SADCnC,EAAQA,QAA4BlC,QAAQC,YAE/CvS,EAAMsC,SAAS,CACbC,KAC0B,kBAAxBqS,GACIxD,GAAWwF,aACXxF,GAAWyF,UACjB9D,MAAO2D,EAAS3D,MAChB5L,OAAQuP,EAASvP,OACjB2P,sBAAuBJ,EAAS1D,YAChCtQ,WACGiU,GACCnC,EAAQA,QAA4BlC,QAAQA,QAC3CtP,MACLsP,QAAUkC,EAAQA,QAA4BlC,QAAQC,YACtDwE,SACEJ,GACEnC,EAAQA,QAA4BlC,QACnCA,QAAiB3J,KAAKhG,KAAI,SAACsE,GAAD,OAAOA,EAAEwB,eAI9C,MAAOwJ,GACP9P,QAAQC,IAAI6P,GACZjS,EAAMsC,SAAS,CACbC,KAAM6O,GAAW4F,kBAGjB1B,GACFP,GAAY,GAEd/K,EAAOE,SAASkL,SAAS,MACzBpL,EAAOE,SAASmL,UAAU,QAoB1B,kBAAC4B,GAAA,EAAD,CACEC,aAAc,CACZC,SAAU,SACVC,WAAY,QAEdC,KAAMvC,EACNwC,iBAAkB,KAClBC,QAASvC,EACTwC,QAAS9C,GACT1F,OACE,kBAAC,IAAMyI,SAAP,KACE,kBAACtW,EAAA,EAAD,CACEuW,KAAK,QACLnW,aAAW,QACXiC,MAAM,UACNnC,QAAS2T,GAET,kBAAC,KAAD,CAAW9S,SAAS,e,yEC/L5BrD,GAAYC,YAAW,CAC3BG,KAAM,CACJsB,MAAO,UAII,SAASoX,GAAT,GAQX,IAPFpU,EAOC,EAPDA,MACAjB,EAMC,EANDA,SACAsV,EAKC,EALDA,YACAC,EAIC,EAJDA,0BACAC,EAGC,EAHDA,YACAC,EAEC,EAFDA,cACAC,EACC,EADDA,UAEM/X,EAAUpB,KACVE,EAAQkZ,eAFb,EAGmC/X,IAAMC,SAAS,GAHlD,mBAGM+X,EAHN,KAGkBC,EAHlB,KAuBD,OACE,oCACE,kBAACC,GAAA,EAAD,CACEC,QAAQ,OACRC,MAAO/U,EAAMH,OACbmV,SAAS,SACTL,WAAYA,EACZxX,UAAWT,EAAQhB,KACnBuZ,WACE,kBAACC,GAAA,EAAD,CACEf,KAAK,QACLrW,QA7BS,WACjB8W,GAAc,SAACO,GAAD,OAAoBA,EAAiB,KACnDd,EAAYM,EAAa,GACrBA,GAAc3U,EAAMH,OAAS,GAC/Bd,GAAS,GAENyV,EAGHC,EAAU,IAFVH,EAA0BC,EAAaI,OAAYhM,IAuB7CyM,SAAUT,IAAe3U,EAAMH,QAHjC,OAMuB,QAApBrE,EAAM6Z,UACL,kBAAC,KAAD,MAEA,kBAAC,KAAD,OAINC,WACE,kBAACJ,GAAA,EAAD,CAAQf,KAAK,QAAQrW,QA5BV,WACjB8W,GAAc,SAACO,GAAD,OAAoBA,EAAiB,KACnDd,EAAYM,EAAa,IA0BuBS,SAAyB,IAAfT,GAC7B,QAApBnZ,EAAM6Z,UACL,kBAAC,KAAD,MAEA,kBAAC,KAAD,MAJJ,UAUJ,kBAACR,GAAA,EAAD,CACEC,QAAQ,WACRC,MAAO/U,EAAMH,OACbmV,SAAS,SACTL,WAAYA,EACZxX,UAAWT,EAAQhB,KACnBuZ,WAAY,KACZK,WAAY,Q,yBC7EL,SAASC,GAAW9Y,GACjC,OACE,kBAAC,IAAD,CAAMrB,MAAO,CAAE4B,MAAO,OAAQpB,OAAQ,SACpC,kBAAC0B,EAAA,EAAD,CAAalC,MAAO,CAAES,WAAY,UAChC,kBAAC0B,EAAA,EAAD,CAAY0C,MAAM,gBAAgBuV,cAAY,GAC3C/Y,EAAMiG,WCPjB,IAAMpH,GAAYC,YAAW,CAC3BG,KAAM,CACJqB,UAAW,MACX+C,UAAW,SACXrB,OAAQ,YAKG,SAASgX,GAAT,GAAoC,IAAhBhY,EAAe,EAAfA,MAAOa,EAAQ,EAARA,KAAQ,EACd1B,oBAAS,GADK,mBACzC8Y,EADyC,KAC9BC,EAD8B,KAE1CjZ,EAAUpB,KACVsa,EAAc,SAACtD,GACnBA,EAAEuD,iBACFF,GAAa,SAACG,GACZ,OAAQA,MAIZ,OACE,oCACE,yBAAK3Y,UAAWT,EAAQhB,MACtB,kBAAC,KAAD,CAAega,UAAWA,EAAWK,cAAc,YACjD,yBAAKjY,QAAS8X,GACZ,kBAACL,GAAD,CAAY7S,QAASjF,KAGvB,yBAAKK,QAAS8X,GACZ,kBAACL,GAAD,CAAY7S,QAASpE,EAAMR,QAAS8X,Q,ICzBpCI,G,8DAaL,SAAeC,GAAtB,qC,gDAAO,WACL7K,EACAjM,GAFK,gBAAAkM,EAAA,6DAIC6K,EAAkB9K,EAAGE,YAAYC,IAAIP,GAAUQ,OAJhD,SAKS0K,EACXxK,MAAMC,KAAEC,MAAM,OAAQD,KAAEwK,MAAMhX,KAC9B2M,QAPE,oF,sBAUA,SAAesK,GAAtB,qC,gDAAO,WACLhL,EACAkB,GAFK,kBAAAjB,EAAA,6DAKC6K,EAAkB9K,EAAGE,YAAYC,IAAIP,GAAUQ,OALhD,SAMgB0K,EAClBxK,MAAMC,KAAEC,MAAM,KAAMU,IACpBR,QARE,aAMCrM,EAND,QASKI,OAAS,GATd,sBAUG,IAAIqE,MAAJ,8CAAiDoI,IAVpD,gCAYE7M,EAAM,GAAGX,MAZX,4C,sBAeA,SAAeuX,GAAtB,qC,gDAAO,WACLjL,EACAkL,GAFK,sCAAAjL,EAAA,6DAIDkL,EAAU,GACR7J,EAAkBtB,EAAGE,YAAYC,IAAIP,GAAUoB,OALhD,SAM2CkK,EAAQtW,MANnD,OAMCwW,EAND,sBASmBA,GATnB,gEASIC,EATJ,QAUGC,EAAe,GAVlB,UAWgBhK,EAChBhB,MAAMC,KAAEC,MAAM,KAAM6K,EAAYE,UAChC7K,QAbA,QAWChH,EAXD,OAayB,GACvB4R,EAAa5R,EAAK8R,WACrBF,EAAa5R,EAAK8R,UAAW,EAC7BL,EAAQvR,KAAKF,EAAK8R,UAhBjB,+IAmBDzX,EAA2B,GAnB1B,MAoBcoX,EApBd,iDAoBIM,EApBJ,UAqBH1X,EArBG,UAqBkBiX,GAAkBhL,EAAIyL,GArBxC,yBAqBO7R,KArBP,6EAuBE7F,GAvBF,iE,sBA0BA,SAAe2X,GAAtB,qC,gDAAO,WACL1L,EACAjM,GAFK,wBAAAkM,EAAA,6DAID0H,EAAS,GAJR,SAKekD,GAAiB7K,EAAIjM,GALpC,OAKCM,EALD,sBAMcA,GANd,gEAMIoX,EANJ,aAOM9D,EAPN,UAO0B8D,EAAO7W,MAAM8L,QAPvC,oBAOHiH,EAPG,KAOagE,OAPb,wLASEhE,GATF,iE,sBA2CA,SAAeiE,GAAtB,mC,gDAAO,WAA8B5L,GAA9B,gBAAAC,EAAA,6DACC4L,EAAqB7L,EAAGE,YAAYC,IAAIP,GAAU6D,UADnD,SAESoI,EAAmBvL,QAAQI,QAFpC,oF,sBAKA,SAAeoL,GAAtB,mC,gDAAO,WACL9L,GADK,8BAAAC,EAAA,6DAEL8L,EAFK,+BAEO,EAFP,SAIqBH,GAAe5L,GAJpC,cAICgM,EAJD,yBAKEA,EAAYzW,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUA,EAAEC,WAAajM,EAAEiM,cAAY7T,MAAM,EAAG0T,IALnE,4C,sBAQA,SAAeI,GAAtB,mC,gDAAO,WACLnM,GADK,wCAAAC,EAAA,6DAEL8L,EAFK,+BAEO,EAERK,EAAwB,GAJvB,SAKkBN,GAAgB9L,EAAI+L,GALtC,OAKCM,EALD,sBAOiBA,GAPjB,gEAOMnB,EAPN,kBAQiBA,EAAQtW,MARzB,QAQGA,EARH,OASHwX,EAAST,OAAO/W,GATb,wKAYE0X,GAAYF,IAZd,iE,sBAeA,SAASG,GACd3X,EACA4D,GAEc,IADduT,EACa,uDADD,EAERpE,EAAS,GAEb,OAAQnP,GACN,KAAKoS,GAAO4B,KACV7E,EAAS/S,EACNW,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUA,EAAEQ,MAAQR,EAAES,OAASzM,EAAEwM,MAAQxM,EAAEyM,UAChDrU,MAAM,EAAG0T,GACZ,MACF,KAAKnB,GAAO+B,MACVhF,EAAS/S,EACNW,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUhM,EAAEwM,MAAQxM,EAAEyM,OAAST,EAAEQ,MAAQR,EAAES,UAChDrU,MAAM,EAAG0T,GACZ,MACF,KAAKnB,GAAOgC,OACVjF,EAAS/S,EAAMW,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUhM,EAAE4M,WAAaZ,EAAEY,cAAYxU,MAAM,EAAG0T,GACpE,MACF,KAAKnB,GAAOkC,OACVnF,EAAS/S,EAAMW,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUA,EAAEY,WAAa5M,EAAE4M,cAAYxU,MAAM,EAAG0T,GACpE,MACF,KAAKnB,GAAOmC,OACVpF,EAAStS,EAAQT,GAAOyD,MAAM,EAAG0T,GACjC,MACF,QACE,MAAM,IAAIjT,MAAJ,iCAAoCN,IAG9C,OAAOmP,EAGF,SAAeqF,GAAtB,qC,gDAAO,WACL3Y,EACAmE,GAFK,0CAAAyH,EAAA,sDAGL8L,EAHK,+BAGO,EAERpE,EAAS,GACTsF,EAAe,IAAIC,IANlB,eAOY7Y,GAPZ,gEAOIG,EAPJ,kBAQiBA,EAAKI,MAAM8L,QAR5B,QAQG9L,EARH,OASGkB,EAAQqX,GAAmBvY,GACjCqY,EAAaG,IAAI5Y,EAAK0M,GAAIpL,GAVvB,oJAaG0C,EAbH,cAcEoS,GAAO4B,KAdT,UAmBE5B,GAAO+B,MAnBT,UAwBE/B,GAAOgC,OAxBT,UA2BEhC,GAAOkC,OA3BT,UA8BElC,GAAOmC,OA9BT,2BAeDpF,EAAStT,EACNkB,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUgB,EAAa9M,IAAI8L,EAAE/K,IAAM+L,EAAa9M,IAAIF,EAAEiB,OAC3D7I,MAAM,EAAG0T,GAjBX,oCAoBDpE,EAAStT,EACNkB,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUgB,EAAa9M,IAAIF,EAAEiB,IAAM+L,EAAa9M,IAAI8L,EAAE/K,OAC3D7I,MAAM,EAAG0T,GAtBX,oCAyBDpE,EAAStT,EAAMkB,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUhM,EAAE4M,WAAaZ,EAAEY,cAAYxU,MAAM,EAAG0T,GAzBnE,oCA4BDpE,EAAStT,EAAMkB,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUA,EAAEY,WAAa5M,EAAE4M,cAAYxU,MAAM,EAAG0T,GA5BnE,oCA+BDpE,EAAStS,EAAQhB,GAAOgE,MAAM,EAAG0T,GA/BhC,mCAkCK,IAAIjT,MAAJ,iCAAoCN,IAlCzC,iCAqCEmP,GArCF,iE,sBAwCA,SAAe0F,GAAtB,uC,gDAAO,WACLrN,EACAqM,EACA7T,GAHK,wCAAAyH,EAAA,sDAIL8L,EAJK,+BAIO,EAERpE,EAAS,GACT2F,EAAmB,IAAIJ,IAPtB,eASiBb,GATjB,gEASMnB,EATN,kBAUiBqC,GAAgBvN,EAAIkL,GAVrC,QAUGpV,EAVH,OAWHwX,EAAiBF,IAAIlC,EAAQhK,GAAIpL,GAX9B,oJAcG0C,EAdH,cAeEoS,GAAO4B,KAfT,UAqBE5B,GAAO+B,MArBT,UA0BE/B,GAAOgC,OA1BT,UA6BEhC,GAAOkC,OA7BT,UAgCElC,GAAOmC,OAhCT,2BAgBDpF,EAAOpS,MACL,SAAC0K,EAAGgM,GAAJ,OACEqB,EAAiBnN,IAAI8L,EAAE/K,IAAMoM,EAAiBnN,IAAIF,EAAEiB,IAAI7I,MAAM,EAAG0T,MAlBpE,oCAsBDpE,EACGpS,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUqB,EAAiBnN,IAAIF,EAAEiB,IAAMoM,EAAiBnN,IAAI8L,EAAE/K,OACnE7I,MAAM,EAAG0T,GAxBX,oCA2BDpE,EAAS0E,EAAS9W,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUhM,EAAEiM,WAAaD,EAAEC,cAAY7T,MAAM,EAAG0T,GA3BtE,oCA8BDpE,EAAS0E,EAAS9W,MAAK,SAAC0K,EAAGgM,GAAJ,OAAUA,EAAEC,WAAajM,EAAEiM,cAAY7T,MAAM,EAAG0T,GA9BtE,oCAiCDpE,EAAStS,EAAQgX,GAAUhU,MAAM,EAAG0T,GAjCnC,mCAoCK,IAAIjT,MAAJ,iCAAoCN,IApCzC,iCAuCEmP,GAvCF,iE,sBA0CA,SAASwF,GAAmBvY,GACjC,IAAI4Y,EAAa,EACbC,EAAa,EAKjB,OAJA7Y,EAAMmD,SAAQ,SAAC2B,GACb8T,GAAc9T,EAAK+S,MACnBgB,GAAc/T,EAAKgT,SAEdc,GAAcA,EAAaC,GAG7B,SAAeF,GAAtB,qC,gDAAO,WACLvN,EACAkL,GAFK,oBAAAjL,EAAA,6DAICyN,EAAyB1N,EAAGE,YAAYC,IAAIP,GAAU+N,gBAJvD,SAKuBD,EACzBpN,MAAMC,KAAEC,MAAM,aAAc0K,EAAQhK,KACpCR,QAPE,cAKC0K,EALD,OAQCwC,EAAaxC,EAAa3W,OAR3B,kBASE2W,EAAapX,KAAI,SAAC6Z,GAAD,OAAQA,EAAGC,cAAYrZ,OAASmZ,GATnD,4C,sBAYA,SAAStB,GAAY1X,GAC1B,IAD2D,EACvD+S,EAAS,GACPoG,EAAU,IAAIC,IAFuC,eAGxCpZ,GAHwC,IAG3D,2BAA0B,CAAC,IAAhB8E,EAAe,QACnBqU,EAAQE,IAAIvU,EAAKwH,MACpByG,EAAO/N,KAAKF,GACZqU,EAAQG,IAAIxU,EAAKwH,MANsC,8BAS3D,OAAOyG,G,SA1RGiD,K,YAAAA,E,cAAAA,E,gBAAAA,E,gBAAAA,E,iBAAAA,Q,KCmGZ,SAASuD,GACP/Z,EACAga,GAEA,IAAMC,EAAiB,GACjBC,EAAqB,GAY3B,OAXAla,EAAQE,aAAayD,SAAQ,SAACxD,GAAQ,IAAD,KAC/B,UAAAA,EAAGC,YAAH,mBAASI,aAAT,eAAgBH,QAAS,IAC3B6Z,EAAmB/Z,EAAGb,KAAK0B,eAAiBb,EAAGb,SAGnD0a,EAAmBrW,SAAQ,SAACwW,GAC1B,IAAMC,EAAiBF,EAAmBC,EAAGnZ,eACzCoZ,IACFH,EAAeG,IAAkB,MAG9BC,OAAOC,KAAKL,GAGrB,SAAS3C,GAA0BiD,GACjC,IADqE,EACjEC,EAA6B,GADoC,eAEpDD,GAFoD,IAErE,2BAAsC,CAAC,IAAD,EAA3Bpa,EAA2B,QAC9BV,EAAWU,EAAGb,KADgB,eAEjBa,EAAGC,KAAKI,OAFS,IAEpC,2BAAkC,CAAC,IAAxB8E,EAAuB,QAC1BmV,EAAe,CAAExc,MAAOqH,EAAKrH,MAAOa,KAAMwG,EAAKxG,KAAMW,YAC3D+a,EAAchV,KAAKiV,IAJe,gCAF+B,8BASrE,OAAOD,E,SAGME,G,yFAAf,WACE/a,EACA4a,EACAvK,EACA+D,GAJF,gBAAAlI,EAAA,6DAMOkI,IACHrR,EAAU6X,GACNvK,EAAQuK,EAAoBla,QAC9Bka,EAAoBI,OAAO3K,IAM/BwK,EAAgB9X,EAFZ8X,EAAgBlD,GAA0BiD,IAG1CxG,IACFrR,EAAU8X,GACNxK,EAAQwK,EAAcna,QACxBma,EAAcG,OAAO3K,IAnB3B,kBAsBS,CACLrQ,UAAWA,EACXa,MAAOga,IAxBX,4C,+BAqCeI,G,uFAAf,WACEhP,EACAjM,EACA6a,GAHF,0BAAA3O,EAAA,6DAKQgP,EAAmB,GACzBL,EAAc7W,SAAQ,YAAgC,IAA7BlE,EAA4B,EAA5BA,SAAUxB,EAAkB,EAAlBA,MAAOa,EAAW,EAAXA,KACxC+b,EAAiB,GAAD,OAAIpb,EAAJ,YAAgBxB,EAAhB,YAAyBa,KAAU,KAG/Cgc,EAAkC,GAV1C,SAYsBrE,GAAiB7K,EAAIjM,GAZ3C,OAYQM,EAZR,sBAaqBA,GAbrB,cAAA4L,EAAA,mCAAAA,EAAA,6DAaazL,EAbb,iBAc8BA,EAAKI,MAAM8L,QAdzC,cAegB3I,SACV,YAA2D,IAAxD1F,EAAuD,EAAvDA,MAAOa,EAAgD,EAAhDA,KAAMuZ,EAA0C,EAA1CA,MAAOC,EAAmC,EAAnCA,MAAmByC,EAAgB,EAA5BtC,WACxBoC,EAAiB,GAAD,OAAIza,EAAKd,KAAT,YAAiBrB,EAAjB,YAA0Ba,KAE5Cgc,EAAetV,KAAK,CAClB/F,SAAUW,EAAKd,KACfrB,QACAa,OACAuZ,QACAC,QACAyC,iBAzBZ,wSA+BSD,GA/BT,iE,+BAkCeE,G,6FAAf,WACEpP,EACAqO,EACAM,EACAnW,EACA4L,EACA+D,GANF,4BAAAlI,EAAA,yDAUEnJ,EADI8X,EAAgBlD,GAA0BiD,IAEzCxG,EAXP,qBAYQ/D,GAASuK,EAAoBla,QAZrC,yCAaa,CACLV,UAAWsa,EACXzZ,MAAOga,IAff,kCAmBQxK,GAASwK,EAAcna,QAnB/B,yCAoBa,CACLV,UAAWsa,EACXzZ,MAAOga,IAtBf,WA2BMzG,EA3BN,kCA4BiC6G,GAC3BhP,EACAqO,EACAO,GA/BN,QAiCI,OALMM,EA5BV,OAiCY1W,GACN,KAAKoS,GAAO4B,KACV0C,EAAe3Z,MAAK,SAAC8Z,EAAOC,GAC1B,QAASD,EAAM5C,MAAQ4C,EAAM3C,OAAS4C,EAAM7C,MAAQ6C,EAAM5C,WAG9D,KAAK9B,GAAO+B,MACVuC,EAAe3Z,MAAK,SAAC8Z,EAAOC,GAC1B,OAAOD,EAAM5C,MAAQ4C,EAAM3C,OAAS4C,EAAM7C,MAAQ6C,EAAM5C,UAG5D,KAAK9B,GAAOkC,OACVoC,EAAe3Z,MAAK,SAAC8Z,EAAOC,GAC1B,OAAOD,EAAMF,UAAYG,EAAMH,aAGnC,KAAKvE,GAAOgC,OACVsC,EAAe3Z,MAAK,SAAC8Z,EAAOC,GAC1B,QAASD,EAAMF,UAAYG,EAAMH,cAnD3C,OAuDID,EAAeH,OAAO3K,GACtBtN,EAAUoY,GAxDd,kBAyDW,CACLnb,UAAWsa,EACXzZ,MAAOsa,IA3Db,yBA+D8BrE,GAAiB7K,EAAIqO,GA/DnD,eA+DUkB,EA/DV,iBAgEgCvC,GAAWuC,EAAa/W,EAAQ4L,GAhEhE,eAgEUoL,EAhEV,OAiEUC,EAAmB,GACzBD,EAAczX,SAAQ,SAACvD,GACrBib,EAAiBjb,EAAKd,OAAQ,KAE1Bgc,EAAsBf,EAAoBnW,QAC9C,SAACjE,GAAD,OAAQkb,EAAiBlb,EAAGb,SAG9BoD,EADMlC,EAAQ8W,GAA0BgE,IAxE5C,kBA0EW,CACL3b,UAAWsa,EACXzZ,MAAOA,IA5Eb,6C,+BAiFe+a,G,2FAAf,WACE3P,EACA5L,EACAga,EACA5V,EACA2P,GALF,gCAAAlI,EAAA,yDAMEmE,EANF,+BAMkB,EAEViK,EAAiBF,GAAkB/Z,EAASga,GAC5CO,EAAsBva,EAAQE,aAAakE,QAAO,SAACjE,GACvD,OAAO8Z,EAAe1T,SAASpG,EAAGb,SAG/B8E,GAAUA,IAAWoS,GAAOmC,OAbnC,yCAcW+B,GACLT,EACAM,EACAvK,EACA+D,IAlBN,uBAqBiBiH,GACXpP,EACAqO,EACAM,EACAnW,EACA4L,EACA+D,GA3BN,qF,+BAgCeyH,G,6FAAf,WACE5P,EACA5L,EACAgU,EACA5P,EACA2P,EACA/D,GANF,kBAAAnE,EAAA,6DAQQ0O,EAAsBva,EAAQE,aAAakE,QAAO,SAACjE,GACvD,IAAMsb,EAAiBtb,EAAGyF,MAAQzF,EAAGyF,KAAKA,KAAKhG,KAAI,SAACsE,GAAD,OAAOA,EAAEwB,WACxDgW,GAAkB,EAQtB,OAPID,GACFA,EAAe9X,SAAQ,SAACO,GAClB8P,EAASzN,SAASrC,KACpBwX,GAAkB,MAIjBA,KAGH/b,EAAY4a,EAAoB3a,KAAI,SAACO,GAAD,OAAQA,EAAGb,QArBvD,SAsBeob,GACX/a,EACA4a,EACAvK,EACA+D,GA1BJ,oF,+BA8Be4H,G,uFAAf,WACE/P,EACAxH,EACA2P,GAHF,sDAAAlI,EAAA,yDAIEmE,EAJF,+BAIkB,GAIZ+D,EARN,gCASqByD,GAAe5L,GATpC,OASIqM,EATJ,kCAWQ7T,EAXR,kCAYuBoT,GAAe5L,GAZtC,eAYMqM,EAZN,iBAauBgB,GAAcrN,EAAIqM,EAAU7T,EAAQ4L,GAb3D,QAaMiI,EAbN,gDAeuBP,GAAgB9L,EAAIoE,GAf3C,QAeMiI,EAfN,eAmBMzX,EAAqB,GAnB3B,eAoBwByX,GApBxB,kEAoBanB,EApBb,kBAqBwBA,EAAQtW,MArBhC,SAqBUA,EArBV,QAsBU+W,OAAO/W,GAtBjB,iJAyBEA,EAAQ0X,GAAY1X,GAEhBuT,GAAyBvT,EAAMH,OAAS2P,IAExCxP,EADE4D,EACM+T,GAAW3X,EAAO4D,EAAQ4L,GAE1B/O,EAAQT,GAAOma,OAAO3K,IAIlC/O,EAAQT,GAEFP,EAA0B2L,EAAGE,YAAYC,IAAIP,GAAUQ,OACvD4P,EAAmB,GACnBC,EAA0B,GAvClC,eAwCqBrb,GAxCrB,8DAwCa8E,EAxCb,QAyCSsW,EAAiBtW,EAAK8R,SAzC/B,kCA2CcnX,EAAMiM,MAAMC,KAAEC,MAAM,KAAMD,KAAEE,GAAG/G,EAAK8R,WAAW9K,QA3C7D,QA0CMsP,EAAiBtW,EAAK8R,SA1C5B,OA4CQ,GAAG9X,KA5CX,QA8CUG,EAAWmc,EAAiBtW,EAAK8R,SACvCyE,EAAWrW,KAAK,CACd/F,WACAxB,MAAOqH,EAAKrH,MACZa,KAAMwG,EAAKxG,OAlDjB,0KAsDS,CAAE0B,MAAOqb,IAtDlB,gF,sBAyDA,SAASC,GAAmB9b,EAAkBsF,GAC5C,IAAMnF,EAAkBH,EAAQE,aAAa8K,MAC3C,SAAC7K,GAAD,OAAQA,EAAGb,OAASgG,EAAK7F,YAE3B6F,EAAKM,KAAOzF,EAAGyF,MAAQzF,EAAGyF,KAAKA,KAAKhG,KAAI,SAACsE,GAAD,OAAOA,GAAKA,EAAEwB,WAGjD,SAAeqW,GAAtB,uC,gDAAO,WACL/b,EACAgc,EACApQ,GAHK,gBAAAC,EAAA,sEAK0BoQ,GAC7Bjc,EACAgc,EACApQ,GARG,cAKCsQ,EALD,QAUY1b,MAAMmD,SAAQ,SAACwY,GAC9B,OAAOL,GAAmB9b,EAASmc,MAXhC,kBAcED,GAdF,4C,sBAsBA,SAAeD,GAAtB,uC,gDAAO,WACLjc,EACAgc,EACApQ,GAHK,0BAAAC,EAAA,yDAMH0D,EAMEyM,EANFzM,QACAnL,EAKE4X,EALF5X,OACA2P,EAIEiI,EAJFjI,sBACA/D,EAGEgM,EAHFhM,MACWgK,EAETgC,EAFFrc,UACAqU,EACEgI,EADFhI,SAGc,UAAZzE,EAdC,gCAeUgM,GACX3P,EACA5L,EACAga,EACA5V,EACA2P,EACA/D,GArBC,kDAuBkB,SAAZT,EAvBN,kCAwBUiM,GACX5P,EACA5L,EACAgU,EACA5P,EACA2P,EACA/D,GA9BC,oDAgCkB,aAAZT,EAhCN,kCAiCUoM,GAAqB/P,EAAIxH,EAAQ2P,EAAuB/D,GAjClE,uDAmCG,IAAItL,MAAM,kBAnCb,6C,8CClbP,SAAS0X,GAAMnf,GACb,OAAO,kBAAC,KAAD,eAAUof,UAAW,EAAG/G,QAAQ,UAAarY,IAMtD,IAAMnB,GAAYC,aAAW,SAACC,GAAD,MAAmB,CAC9CE,KAAM,CACJsB,MAAO,OACP,YAAa,CACXD,UAAWvB,EAAMsgB,QAAQ,SAKhB,SAASC,GAAT,GAAoC,IAAZ9H,EAAW,EAAXA,QAC/BvX,EAAUpB,KADgC,EAEtBqB,IAAMC,SAAgB,CAC9CkX,MAAM,EACNF,SAAU,MACVC,WAAY,WALkC,mBAEzCmI,EAFyC,KAElCC,EAFkC,KAOxCrI,EAA+BoI,EAA/BpI,SAAUC,EAAqBmI,EAArBnI,WAAYC,EAASkI,EAATlI,KACxBoI,EAAc,WAClBD,EAAS,eAAKD,EAAN,CAAalI,MAAM,MAG7B,OACE,yBAAK3W,UAAWT,EAAQhB,MACtB,kBAACgY,GAAA,EAAD,CACEC,aAAc,CAAEC,WAAUC,cAC1BC,KAAMA,EACNE,QAASkI,GAET,kBAAC,GAAD,CAAOlI,QAASkI,EAAaC,SAAS,SACnClI,KCiBX,SAASK,GACPxP,EACAsX,EACAC,GAEA,IACIC,EACAC,EACAC,EAHEC,EAAcvO,aAAamC,QAAQ,eAIzC,GAAIoM,EAAa,EAEfH,GADAC,EAAoBlO,KAAKtJ,MAAM0X,IACE,iBACbH,EAAgB,IACpC,IAAMI,EAAa,UAAM5X,EAAK7F,SAAX,YAAuB6F,EAAKrH,MAA5B,YAAqCqH,EAAKxG,MACvDqe,EAAW,CACfhG,QAAS+F,EACTjf,MAAOqH,EAAKrH,MACZa,KAAMwG,EAAKxG,KACX4a,WAAYmD,EACZO,WAAYR,EACZxc,KAAMkF,EAAK7F,SACXmG,KAAMN,EAAKM,MAEPyX,EAAeP,EAAc1Y,QACjC,SAACkZ,GAAD,OAAOA,EAAEnG,UAAY+F,KACrB,GACIK,EAAoBT,EAAcrV,QAAQ4V,GAC5CA,EACFP,EAAcS,GAAqBJ,EAEnCL,EAActX,KAAK2X,GAErBH,EAAoB,eACfD,EADe,CAElBD,cAAeA,IAEjBpO,aAAaC,QAAQ,cAAeE,KAAKC,UAAUkO,K,gDAkBvD,WACEvO,EACA7C,GAFF,sBAAAC,EAAA,6DAIQ2R,EAA0C5R,EAAGE,YAAYC,IAC7DP,GAAU6D,UAGNoO,EAAmC7R,EAAGE,YAAYC,IAAIP,GAAUoB,OAChE8Q,EAAmC9R,EAAGE,YAAYC,IAAIP,GAAUQ,OAChE2R,EAA4C/R,EAAGE,YAAYC,IAC/DP,GAAU+N,gBAXd,SAeQ3N,EAAGK,OAAH,wBAAU,qCAAAJ,EAAA,6DAER+R,EAAsB,GAFd,SAIeJ,EAAc7gB,QAAO,SAACma,GACjDA,EAAQgB,WAAa,IAAIzV,KAAKoM,EAAKgK,YACnC3B,EAAQ+G,SAAW,IAAIxb,KAAKoM,EAAKoP,aANrB,OAIRC,EAJQ,sBAQErP,EAAKqO,eARP,cAAAjR,EAAA,2CAAAA,EAAA,0DASS,KADZ4B,EARG,SASNiM,aAAwC,IAAjBjM,EAAEiM,WATnB,oBAYLkE,EAAoBnQ,EAAErN,MAZjB,gCAcAsd,EAAUxR,MAAMC,KAAEC,MAAM,OAAQD,KAAEE,GAAGoB,EAAErN,QAAQkM,QAd/C,OAaRsR,EAAoBnQ,EAAErN,MAbd,OAeN,GAfM,cAiBJiX,EAASuG,EAAoBnQ,EAAErN,MAAM0M,GAjBjC,SAmBiB2Q,EACxBvR,MACCC,KAAEC,MAAM,UAAWD,KAAEE,GAAGgL,IACxBlL,KAAEC,MAAM,QAASD,KAAEE,GAAGoB,EAAExP,QACxBkO,KAAEC,MAAM,OAAQD,KAAEE,GAAGoB,EAAE3O,QAExBwN,QAzBO,UA4BkB,KATtByR,EAnBI,QA4BO1d,OA5BP,wBA8BF2d,EAAuBJ,EAAoBnQ,EAAErN,MA9B3C,UAgCF4d,EAAUtR,UAAV,wBAAoB,uBAAAb,EAAA,sEACLmS,EAAUrR,QAAQc,EAAExP,MAAOwP,EAAE3O,MADxB,OACxBmf,EADwB,mDAhClB,gCAqCRA,EAAYF,EAAa,GArCjB,yBAwCJE,EAAUzR,QAAO,SAAC0R,GAClBzQ,EAAEiM,WACJwE,EAAG7F,QAEH6F,EAAG5F,QAEL4F,EAAGC,eAAiB,IAAI9b,KAAKoM,EAAKoP,aA9C1B,yBAkDJF,EAAiBhhB,QAAO,SAACsa,GAC7BA,EAAYE,QAAU8G,EAAUnR,GAChCmK,EAAYmH,WAAaN,EAAehR,GACxCmK,EAAYyC,WAAajM,EAAEiM,cArDnB,uUAflB,4C,sBA2EA,SAAS2E,GAAsCzS,GAC7C,IACI0S,EACAC,EAFEtB,EAAcvO,aAAamC,QAAQ,eAOzC,GAJIoM,IAEFqB,GADAC,EAAqB1P,KAAKtJ,MAAM0X,IACJ,UAE1BsB,IAAuBD,EAAS,CAClC,IAAM7P,EAAI,eAAQ8P,EAAR,CAA4BV,UAAU,IAAIxb,MAAOV,c,uCAC3D6c,CAAoB/P,EAAM7C,GAC1B,IAAMgF,EAAa/B,KAAKC,UAAUL,GAClCC,aAAaC,QAAQ,cAAeiC,IAIzB,SAAS6N,GAAQxhB,GAC9B,IAAM2O,EAAKkC,yBADiC,EAEhB1Q,mBAAS,IAFO,mBAErCmW,EAFqC,KAE7B0B,EAF6B,OAGhB7X,oBAAS,GAHO,mBAGrCshB,EAHqC,KAG7BC,EAH6B,OAIFvhB,mBAAS,GAJP,mBAIrCwf,EAJqC,KAItBgC,EAJsB,OAKIxhB,mBAC9C,MAN0C,mBAKrC8e,EALqC,KAKnB2C,EALmB,OAQVzhB,oBAAS,GARC,mBAQrC0hB,EARqC,KAQ1BC,EAR0B,OASlB3hB,mBAAgB,MATE,mBASrC4hB,EATqC,KAS9BC,EAT8B,KAW5CC,qBAAU,WACR,IAAMC,EF3KH,SACLnf,EACAgc,GAC8B,IAE5BzM,EAGEyM,EAHFzM,QACWyK,EAETgC,EAFFrc,UACAqU,EACEgI,EADFhI,SAGF,GAAgB,UAAZzE,EAAqB,CACvB,IAAKyK,EACH,MAAO,CACLvF,QAvBN,6DA0BE,IAAM2K,EAAkBpf,EAAQE,aAAaN,KAAI,SAACO,GAAD,OAAQA,EAAGb,QACtD+f,EAAmB,IAAIzF,IAU7B,GATAI,EAAmBrW,SAAQ,SAACrE,IAIjB,IAFP8f,EAAgBE,WACd,SAAC7f,GAAD,OAAcH,EAAK0B,gBAAkBvB,EAASuB,kBAGhDqe,EAAiBvF,IAAIxa,MAGK,IAA1B+f,EAAiB1K,KACnB,MAAO,CACLF,QAvCN,kEA0CO,GAAgB,SAAZlF,EAAoB,CAC7B,GAAwB,IAApByE,EAAS3T,OACX,MAAO,CACLoU,QA1CN,4DA6CE,IAAI8K,EAAe,GACnBvf,EAAQE,aAAayD,SAAQ,SAACxD,GAC5BA,EAAGyF,MAAQzF,EAAGyF,KAAKA,KAAKjC,SAAQ,SAACO,GAAD,OAAOqb,EAAa/Z,KAAKtB,EAAEwB,eAE7D,IAAI8Z,GAAY,EAMhB,GALAxL,EAASrQ,SAAQ,SAACO,GACXqb,EAAahZ,SAASrC,KACzBsb,GAAY,MAGZA,EACF,MAAO,CACL/K,QAzDN,4DA+DA,OAAO,EEmHqBgL,CACxBxiB,EAAM+C,QACN/C,EAAM+e,sBAEJmD,EACFF,EAAS,IAAIva,MAAMya,EAAkB1K,UAIb,yCAAG,mCAAA5I,EAAA,+EAEMkQ,GAC7B9e,EAAM+C,QACN/C,EAAM+e,qBACNpQ,GALuB,OAOzBjL,EALMub,EAFmB,QAQnBwD,GAAY,IAAIrd,MAAOV,WACvBge,EAAc,CAAElH,WAAYiH,EAAWtB,WAAYsB,GACnDE,EAAoB/Q,KAAKC,UAAU6Q,GACzCjR,aAAaC,QAAQ,cAAeiR,GAEpCf,EAAoB3C,GACpB6C,GAAa,GACbE,EAAS,MAfgB,kDAiBzBte,EAAM,EAAD,IACLse,EAAS,EAAD,IACRF,GAAa,GAnBY,0DAAH,oDAuB1Bc,KACC,IAEHX,qBAAU,WACJR,IACFL,GAAsCzS,GACtC3O,EAAMsC,SAAS,CAAEC,KAAM6O,GAAWyR,iBAEnC,CAACpB,IAyCJ,OAAIM,EACK,kBAACzC,GAAD,CAAc9H,QAASuK,EAAMvK,UAGlCiK,GAGCI,EAFI,kBAACiB,GAAA,EAAD,MAIL,qCACIrB,GACA,yBAAK/gB,UAAU,qBACb,uCAEA,yBAAKA,UAAU,oBACb,wBAAIA,UAAU,YAAd,cACA,6BACA,kBAAC,KAAD,CAAOqiB,YAAa,MACjB,kBACC,kBAAC,IAAMtL,SAAP,KACE,yBAAK/W,UAAU,SACb,kBAAC,KAAMsiB,QAAP,MADF,SACyB,kBAAC,KAAMC,QAAP,MADzB,aA3DoB,WACpC,GACEjjB,EAAM+e,qBAAqBzM,UAAY4Q,GAAQvQ,OAC/C3S,EAAM+e,qBAAqBzM,UAAY4Q,GAAQtQ,KAE/C,OACE,oCACE,wBAAIlS,UAAU,SAAd,WACA,6BACA,uBAAGA,UAAU,aACVue,EAAiBvc,UAAUC,KAAI,SAACwgB,GAC/B,OACEA,IACAlE,EAAiBvc,UACfuc,EAAiBvc,UAAUU,OAAS,GAG/B,0BAAMP,IAAKsgB,GAAWA,EAAtB,KAEF,0BAAMtgB,IAAKsgB,GAAWA,EAAtB,WAKV,GAAInjB,EAAM+e,qBAAqBzM,UAAY4Q,GAAQxQ,SAAU,CAAC,IAAD,EAC9D0Q,EAAqB,UAAGpjB,EAAM+e,qBAAqBhM,aAA9B,aAAG,EAAkCrO,WAI9D,OAHK0e,IACHA,EAAwB,KAGxB,oCACE,wBAAI1iB,UAAU,SAAd,iBACA,6BACA,uBAAGA,UAAU,aAAa0iB,KAgCrBC,IAEH,kBAAC1L,GAAD,CACEpU,MAAO0b,EAAiB1b,MACxBjB,SAAUof,EACV9J,YAAa+J,EACb9J,0BAA2BA,GAC3BC,YAAamH,EAAiB1b,MAAMoc,GACpC5H,cAAezB,EACf0B,UAAWA,IAEb,kBAACgB,GAAD,CACEhY,MAAOie,EAAiB1b,MAAMoc,GAAe3e,MAC7Ca,KAAMod,EAAiB1b,MAAMoc,GAAe9d,OAE9C,yBAAKlD,MAAO,CAAE0E,UAAW,SAAU/C,UAAW,QAC5C,2BACEgjB,IAAI,UACJ/gB,KAAK,QACLghB,IAAKC,KACL7kB,MAAO,CAAE4B,MAAO,MAAOkjB,YAAa,OACpCpiB,QAAS,WACP2W,EAAU,YACVH,GAA0B,eACnBoH,EAAiB1b,MAAMoc,GADL,CACqBA,kBAC5CA,GACA,MAIN,2BACE2D,IAAI,QACJ/gB,KAAK,QACLghB,IAAKG,KACL/kB,MAAO,CAAE4B,MAAO,OAChBc,QAAS,WACP2W,EAAU,cACVtU,EAAM4S,GACNuB,GAA0B,eACnBoH,EAAiB1b,MAAMoc,GADL,CACqBA,kBAC5CA,GACA,OAKR,4BAAKrJ,K,ICtWLqN,G,gFAAAA,O,+BAAAA,I,qCAAAA,I,+BAAAA,I,sCAAAA,Q,KAOZ,IAAM9kB,GAAYC,YAAW,CAC3BG,KAAM,CACJsB,MAAO,QAETqjB,UAAW,CACTC,UAAW,OAITC,GAAc,CAClB,CAAEjU,GAAI,cAAekU,MAAO,GAAIC,SAAU,GAAIC,MAAO,UACrD,CAAEpU,GAAI,QAASkU,MAAO,QAASC,SAAU,GAAIC,MAAO,UACpD,CAAEpU,GAAI,OAAQkU,MAAO,OAAQC,SAAU,GAAIC,MAAO,UAClD,CAAEpU,GAAI,QAASkU,MAAO,QAASC,SAAU,GAAIC,MAAO,UACpD,CAAEpU,GAAI,OAAQkU,MAAO,OAAQC,SAAU,GAAIC,MAAO,WAG9CC,GAAiB,CACrB,CAAErU,GAAI,cAAekU,MAAO,GAAIC,SAAU,GAAIC,MAAO,UACrD,CAAEpU,GAAI,QAASkU,MAAO,QAASC,SAAU,GAAIC,MAAO,UACpD,CAAEpU,GAAI,OAAQkU,MAAO,OAAQC,SAAU,GAAIC,MAAO,UAClD,CAAEpU,GAAI,UAAWkU,MAAO,UAAWC,SAAU,GAAIC,MAAO,UACxD,CAAEpU,GAAI,OAAQkU,MAAO,OAAQC,SAAU,GAAIC,MAAO,UAClD,CAAEpU,GAAI,aAAckU,MAAO,OAAQC,SAAU,GAAIC,MAAO,WAGpDE,GAAc,CAClB,CAAEtU,GAAI,cAAekU,MAAO,GAAIC,SAAU,GAAIC,MAAO,UACrD,CAAEpU,GAAI,OAAQkU,MAAO,OAAQC,SAAU,GAAIC,MAAO,UAClD,CAAEpU,GAAI,QAASkU,MAAO,aAAcC,SAAU,GAAIC,MAAO,UACzD,CAAEpU,GAAI,QAASkU,MAAO,QAASC,SAAU,GAAIC,MAAO,WAGhDG,GAAiB,CACrB,CAAEvU,GAAI,cAAekU,MAAO,GAAIC,SAAU,GAAIC,MAAO,UACrD,CAAEpU,GAAI,aAAckU,MAAO,OAAQC,SAAU,GAAIC,MAAO,UACxD,CAAEpU,GAAI,QAASkU,MAAO,aAAcC,SAAU,GAAIC,MAAO,UACzD,CAAEpU,GAAI,QAASkU,MAAO,QAASC,SAAU,GAAIC,MAAO,UACpD,CAAEpU,GAAI,WAAYkU,MAAO,aAAcC,SAAU,GAAIC,MAAO,UAC5D,CAAEpU,GAAI,QAASkU,MAAO,QAASC,SAAU,GAAIC,MAAO,WAIvC,SAASI,GAAgBrkB,GAAe,IAC7CskB,EAAqBtkB,EAArBskB,KAAMC,EAAevkB,EAAfukB,WACRtkB,EAAUpB,KAFoC,EAG5BqB,IAAMC,SAAS,GAHa,mBAG7CqkB,EAH6C,KAGvCC,EAHuC,OAIdvkB,IAAMC,SAAS,IAJD,mBAI7CukB,EAJ6C,KAIhCC,EAJgC,KAMhDC,EAAU,KACd,OAAQL,GACN,KAAKZ,GAAWkB,aACdD,EAAUd,GACV,MAEF,KAAKH,GAAWmB,gBACdF,EAAUV,GACV,MAEF,KAAKP,GAAWoB,aACdH,EAAUT,GACV,MAEF,KAAKR,GAAWqB,gBACdJ,EAAUR,GAgBd,OACE,kBAACriB,EAAA,EAAD,CAAOrB,UAAWT,EAAQhB,MACxB,kBAACgmB,GAAA,EAAD,CAAgBvkB,UAAWT,EAAQ2jB,WACjC,kBAACsB,GAAA,EAAD,CAAOC,cAAY,EAAC5jB,aAAW,gBAC7B,kBAAC6jB,GAAA,EAAD,KACE,kBAACC,GAAA,EAAD,KACGT,EAAQjiB,KAAI,SAAC2iB,GAAD,OACX,kBAACC,GAAA,EAAD,CACE1iB,IAAKyiB,EAAOzV,GACZoU,MAAM,SACNtlB,MAAO,CAAEqlB,SAAUsB,EAAOtB,WAEzBsB,EAAOvB,YAKhB,kBAACyB,GAAA,EAAD,KACGlB,EACEtd,MAAMwd,EAAOE,EAAaF,EAAOE,EAAcA,GAC/C/hB,KAAI,SAAC8iB,GACJ,OACE,kBAACJ,GAAA,EAAD,CACEK,OAAK,EACLC,KAAK,WACLC,UAAW,EACX/iB,IAAG,UAAK4iB,EAAI9gB,YAAT,YAAwB8gB,EAAIzkB,QAE9B4jB,EAAQjiB,KAAI,SAAC2iB,GACZ,IAAMtc,EAAQyc,EAAIH,EAAOzV,IACzB,OACE,kBAAC0V,GAAA,EAAD,CAAW1iB,IAAKyiB,EAAOzV,GAAIoU,MAAM,UAC9Bjb,aAUrB,kBAAC6c,GAAA,EAAD,CACEC,mBAAoB,CAAC,GAAI,GAAI,KAC7BC,UAAU,MACVlhB,MAAOyf,EAAKlhB,OACZshB,YAAaA,EACbF,KAAMA,EACNwB,aA3DmB,SAAC/Q,EAAgBgR,GACxCxB,EAAQwB,IA2DJC,oBAxD0B,SAC9BjR,GAEA0P,GAAgB1P,EAAMc,OAAO/M,OAC7Byb,EAAQ,O,OC9CG0B,ICjBVC,GDiBUD,GAjBf,SAAuBE,GACrB,OACE,oCACE,2BAAO3lB,UAAU,iBACf,2BAAOA,UAAU,iBACf,wBAAImC,IAAI,uBAAuBnC,UAAU,iBAlCnD,SAAyB2lB,GACvB,OACEA,GACAjJ,OAAOC,KAAKgJ,EAASA,UAAU1jB,KAAI,SAAC2jB,GAClC,OACE,wBAAIzjB,IAAKyjB,EAAa5lB,UAAU,iBAC7B4lB,MA6BEC,CAAgBF,IAEnB,wBAAIxjB,IAAI,sBAAsBnC,UAAU,iBAxBlD,SAAwB2lB,GACtB,OACEA,GACAjJ,OAAOoJ,OAAOH,EAASA,UAAU1jB,KAAI,SAAC8jB,EAAeniB,GACnD,OACE,wBACEzB,IAAG,UAAK4jB,EAAc/hB,WAAnB,YAAiCJ,GACpC5D,UAAU,iBAET+lB,MAgBEC,CAAeL,QCYb,SAASM,GAAW3mB,GAEjC,IAAM4mB,EAA2B,CAAEC,KAAMT,GAAKU,SAFC,EAGrB3mB,mBAAqBymB,GAHA,mBAGxCrH,EAHwC,KAGjCC,EAHiC,KAIzCuH,EAAWlW,yBAJ8B,EAY3C7Q,EAAM+e,qBALRhM,EAP6C,EAO7CA,MACA5L,EAR6C,EAQ7CA,OACA2P,EAT6C,EAS7CA,sBACApU,EAV6C,EAU7CA,UACA4P,EAX6C,EAW7CA,QAX6C,SAchC0U,IAdgC,6EAc/C,qCAAApY,EAAA,sEAMYqY,IANZ,uBAEI3C,EAFJ,EAEIA,KACA4C,EAHJ,EAGIA,aACAC,EAJJ,EAIIA,YACAC,EALJ,EAKIA,aALJ,kBAOS,CACLf,SAAU,CACR,gBAAiBe,EACjB,gBAAiBF,EACjB,eAAgBC,GAElBE,QAAS/C,EACTC,WAAY+C,MAdhB,4CAd+C,+BAgChCL,IAhCgC,6EAgC/C,iFAAArY,EAAA,yDACM0V,EAAO,GACP4C,EAAuBK,IACvBJ,EAAsBI,IACtBH,EAAuBG,IACvBjjB,EAAQ,GACRwS,EANN,oBAQQxE,IAAY4Q,GAAQvQ,MAR5B,iCAS6B0H,GAA0B0M,EAAUrkB,GATjE,OASM8kB,EATN,kCAUelV,IAAY4Q,GAAQxQ,SAVnC,kCAW6BoI,GAA6BiM,EAAUhU,GAXpE,QAWMyU,EAXN,qCAaY,IAAI/f,MAAJ,0CAC+B6K,EAD/B,sBAbZ,QAiBUmV,EAAgBvM,GAAWsM,EAAgBrgB,EAAQ4L,GAjB7D,eAkBqB0U,GAlBrB,kEAkBapf,EAlBb,QAmBY5D,EAAgB4D,EAAK+S,OAAS/S,EAAKgT,MAAQhT,EAAK+S,OACtD8L,EACEhU,MAAMgU,IAAiBziB,EAAQyiB,EAAeziB,EAAQyiB,EACxDC,EACEjU,MAAMiU,IAAgB1iB,EAAQ0iB,EAAc1iB,EAAQ0iB,EAvB5D,KAwBa7C,EAxBb,KAyBQjgB,EAzBR,KA0BUC,EA1BV,KA2BU+D,EAAKrH,MA3Bf,KA4BUqH,EAAKxG,KA5Bf,KA6BUwG,EAAK+S,MA7Bf,KA8BU/S,EAAKgT,MA9Bf,UA+BgB1B,GAAkBoN,EAAU1e,EAAK8R,SA/BjD,iEAwBMmK,EAxBN,KAwBkBhK,OAxBlB,gBAkCMhW,GAAS,EAlCf,6KAoCagO,IAAY4Q,GAAQvQ,MApCjC,kCAqCiC6G,GAAiBuN,EAAUrkB,GArC5D,eAqCUglB,EArCV,iBAsC2C/L,GACrC+L,EACAvgB,EACA4L,GAzCN,QAsCQoL,EAtCR,sBA2CqBA,GA3CrB,kEA2Cahb,EA3Cb,kBA4C0BA,EAAKI,MAAM8L,QA5CrC,QA4CY9L,EA5CZ,OA6CYkB,EAAQqX,GAAmBvY,GACjC+gB,EAAOA,EAAKhK,OACV1V,EAAeN,EAAOnB,EAAKd,KAAMkB,EAAMH,OAAQqB,IAEjDyiB,EACEhU,MAAMgU,IAAiBziB,EAAQyiB,EAAeziB,EAAQyiB,EACxDC,EACEjU,MAAMiU,IAAgB1iB,EAAQ0iB,EAAc1iB,EAAQ0iB,EACtD7iB,GAAS,EArDf,+KAuDagO,IAAY4Q,GAAQxQ,SAvDjC,mCAwDoC+H,GAAgBsM,EAAUhU,GAxD9D,eAwDU4U,EAxDV,iBAyDiD3L,GAC3C+K,EACAY,EACAxgB,EACA4L,GA7DN,QAyDQ6U,EAzDR,sBA+DwBA,GA/DxB,mEA+Da/N,EA/Db,kBAgE8BD,GACtBmN,EACAlN,GAlER,eAgEYnX,EAhEZ,kBAoEsDmX,EAAQtW,MApE9D,SAoEYwW,EApEZ,OAuEY8N,EAAgB9N,EAAapX,KAAI,SAAC6Z,GAAD,OAAQA,EAAGC,cAAYrZ,OACxDqB,EAAQojB,EAAgB9N,EAAa3W,OAC3C8jB,EACEhU,MAAMgU,IAAiBziB,EAAQyiB,EAAeziB,EAAQyiB,EACxDC,EACEjU,MAAMiU,IAAgB1iB,EAAQ0iB,EAAc1iB,EAAQ0iB,EACtD7C,EAAOA,EAAKhK,OACVxV,EACER,EACAyV,EAAa3W,OACbykB,EACAhO,EAAQgB,WACRhB,EAAQ+G,SACRle,IApFV,4LAyFU,IAAI+E,MACR,oCAAsCzH,EAAM+e,sBA1FlD,gBA6FEqI,EACE9C,EAAK7W,QAAO,SAAUqa,EAAKlZ,GACzB,OAAOkZ,EAAMlZ,EAAEnK,QACd,IAAM6f,EAAKlhB,QAAU,GAhG5B,kBAiGS,CAAEkhB,OAAM4C,eAAcC,cAAaC,iBAjG5C,kGAhC+C,sBAoI/C,SAASE,IACP,GAAIxQ,EACF,OAAO6M,GAAWkB,aAEpB,OAAQvS,GACN,KAAK4Q,GAAQvQ,MACX,OAAOgR,GAAWoB,aAEpB,KAAK7B,GAAQxQ,SACX,OAAOiR,GAAWqB,gBAEpB,KAAK9B,GAAQtQ,KACX,OAAO+Q,GAAWoB,cAoBxB,OAdA9C,qBAAU,YACY,yCAAG,6BAAArT,EAAA,+EAEOoY,IAFP,OAEbe,EAFa,OAGnBvI,EAAS,CAAEqH,KAAMT,GAAK4B,MAAOD,gBAHV,gDAKnBvI,EAAS,CAAEqH,KAAMT,GAAK6B,MAAOlG,MAAM,EAAD,KALf,yDAAH,qDAQpBmG,KACC,CAACloB,EAAM+e,uBAINQ,EAAMsH,OAAST,GAAKU,QACf,kBAAChE,GAAA,EAAD,CAAkBnkB,MAAO,CAAEqD,OAAQ,UACjCud,EAAMsH,OAAST,GAAK6B,OAC7B9lB,QAAQC,IAAImd,EAAMwC,OAEhB,wBAAIpjB,MAAO,CAAEqD,OAAQ,SAArB,wDAMA,oCACE,yBAAKtB,UAAU,wBACb,2CACA,kBAACynB,GAAD,CAAoB9B,SAAU9G,EAAMwI,YAAY1B,WAChD,kBAAChC,GAAD,CACEC,KAAM/E,EAAMwI,YAAYV,QACxB9C,WAAYhF,EAAMwI,YAAYxD,eCpO3B,SAAS6D,GAAgBpoB,GACtC,OACE,oCACE,yBAAKU,UAAU,oBAAoB/B,MAAO,CAAE0E,UAAW,WACrD,qCAAWrD,EAAMqC,MAChBrC,EAAMmD,KAAKA,KAAKI,MAAMZ,KAAI,SAAC6N,GAC1B,OAAO,kBAACwI,GAAD,CAAUhY,MAAOwP,EAAExP,MAAOa,KAAM2O,EAAE3O,a,SDoB9CukB,O,qBAAAA,I,iBAAAA,I,kBAAAA,Q,8BEsBU,SAASiC,KACtB,IAAMtO,EAjDR,WACE,IAAMuO,EAAoB7W,aAAamC,QAAQ,eACzCoM,EAAcsI,GAAqB1W,KAAKtJ,MAAMggB,GAC9CjH,EAAUrB,EAAW,SACrBlC,EAAYkC,EAAW,WACvBuI,EAAa,IAAInjB,KAAKic,GACtBmH,EAAe,IAAIpjB,KAAK0Y,GACxB2K,EAAgBF,EAAWG,UAAYF,EAAaE,UACpDC,EAAexkB,KAAK2B,MAAM2iB,EAAgB,KAC1CG,GAAiBH,EAAgB,IAAS,KAAMI,QAAQ,GAe9D,MAAO,CACLxC,SAAU,CAAE,aAfC,UAAMsC,EAAN,gBAA0BC,EAA1B,SAgBbvB,QAfoBrH,EAAW,eAG/BA,EAAW,cAAkBrd,KAAI,SAAC6N,GAChC,OzCaC,SACLlM,EACAtD,EACAa,EACAinB,EACA3lB,EACAwF,GAEA,IAAIogB,EAOAC,EAOJ,OAZED,OADgB7c,IAAd4c,EACQ,UAEAA,EAAY,UAAY,YAKlCE,EADErgB,GAAQA,EAAKvF,OAAS,EACXuF,EAAKzD,KAAK,MAEV,OAGR,CAAEP,YADWL,EAAMI,WAAa,KACjB1D,QAAOa,OAAMknB,UAAS5lB,OAAM6lB,cyCnCvCC,CACLzY,EAAC,WAAiB,EAClBA,EAAC,MACDA,EAAC,KACDA,EAAC,WACDA,EAAC,KACDA,EAAC,UAK4B,IAuBd0Y,GADsB,EAlB7C,SAAyBC,GACvB,IAKMC,EAAYD,EAAU1b,QALZ,SAAC4b,EAAaC,GAG5B,OAAOD,GADLC,GAAyC,YAAzBA,EAAaP,QAAwB,EAAI,KAGjB,GACtCQ,EAAcJ,EAAU/lB,OAQ9B,MAAO,CAHc,CAHGgmB,GAAaA,EAAU1kB,WACrB6kB,GAAeA,EAAY7kB,YAEKQ,KAAK,KAC1CkkB,IAAcG,GAA+B,IAAhBA,GAODrN,CAC/CnC,EAAasN,SAH4B,mBAEpC5iB,EAFoC,KAE7B+kB,EAF6B,KAM3C,OACE,yBAAK9oB,UAAU,wBACb,uCACA,6BACA,wCAAc+D,EAAd,kBACC+kB,GAAgB,0CAChBA,GACC,yBAAK9oB,UAAU,WAAW6iB,IAAKkG,KAAenG,IAAK,aAErD,6BACA,2CAAiBvJ,EAAasM,SAAS,eACvC,6BACA,kBAAChC,GAAD,CACEC,KAAMvK,EAAasN,QACnB9C,WAAYZ,GAAWmB,mBC1C/B,IAwBYsB,GA6BAhV,GArDNsY,GAAiB,SAAC,GAA2B,IAAzB3mB,EAAwB,EAAxBA,QAAST,EAAe,EAAfA,SACjC,OACE,yBAAK5B,UAAU,uBACb,yBAAKA,UAAU,aACb,yBACE/B,MAAO,CACL6B,QAAS,OACTiD,oBAAqB,UACrBxB,aAAc,WAGhB,kBAACQ,EAAD,CACEC,UAAWK,EAAQE,aAAaN,KAAI,SAACQ,GACnC,OAAOA,EAAKd,QAEdC,SAAUA,S,SASV8jB,O,eAAAA,I,iBAAAA,I,qBAAAA,I,+BAAAA,I,eAAAA,I,6BAAAA,I,iBAAAA,I,sBAAAA,Q,cA6BAhV,K,gCAAAA,E,mDAAAA,E,6BAAAA,E,2BAAAA,E,YAAAA,E,kCAAAA,E,uBAAAA,E,uBAAAA,E,oCAAAA,E,2BAAAA,Q,KA8DZ,IAAMuY,GAAU,SAACpK,EAAcvQ,GAE7B,OADAtL,EAAM,sBAAuBsL,GACrBA,EAAOzM,MAEb,IAAK,kBACH,OAAO,eACFgd,EADL,CAEEjO,WAAYtC,EAAOsC,aAGvB,IAAK,4BACH,OAAO,eACFiO,EADL,CAEExc,QAASiM,EAAOjM,QAChB8jB,KAAMT,GAAKje,OAGf,IAAK,gBAEH,OADAhG,QAAQC,IAAI,iCACL,eACFmd,EADL,CAEER,qBAAsB,CACpBhM,MAAO/D,EAAO+D,MACd5L,OAAQ6H,EAAO7H,OACf2P,sBAAuB9H,EAAO8H,sBAC9BpU,UAAWsM,EAAOtM,UAClB4P,QAAStD,EAAOsD,QAChByE,SAAU/H,EAAO+H,UAEnB8P,KAAMT,GAAKwD,UAGf,IAAK,aACH,OAAO,eACFrK,EADL,CAEEsH,KAAMT,GAAKyD,MACX9K,qBAAsB,CACpBhM,MAAO/D,EAAO+D,MACd5L,OAAQ6H,EAAO7H,OACf2P,sBAAuB9H,EAAO8H,sBAC9BpU,UAAWsM,EAAOtM,UAClB4P,QAAStD,EAAOsD,WAItB,IAAK,OACH,OAAO,eACFiN,EADL,CAEEsH,KAAMT,GAAK5S,OAGf,IAAK,eACH,OAAO,eACF+L,EADL,CAEEsH,KAAMT,GAAK0D,eAGf,IAAK,eACH,OAAO,eACFvK,EADL,CAEEsH,KAAMT,GAAKje,OAGf,IAAK,mBACH,OAAO,eACFoX,EADL,CAEEsH,KAAMT,GAAK2D,YACXC,iBAAkBhb,EAAOxM,WAG7B,IAAK,aAEH,OADA+c,EAAMjO,WAAWpH,SAASkL,SAASpG,EAAOwH,gBACnC+I,EAET,IAAK,oBACH,OAAO,eACFA,EADL,CAEEsH,KAAMT,GAAK6B,QAOjB,OADAvkB,EAAM,uCACC6b,GAGM,SAAS0K,KAAM,M1BhNvB,WACL,IAAMC,EAAYzY,aAAamC,QArBD,oBAsBxBuW,EAAiB1Y,aAAamC,QAvBb,cAwBvB,GAAIsW,EACF,MAAO,CACLE,iBAAiB,EACjBtZ,YAAaoZ,EACbG,eAAgBzY,KAAKtJ,MAAM6hB,IAI7BnkB,EAAU2L,cAAchB,GAAa7G,IACrC,IAAM/G,EAAU,IAAI2G,EAIpB,OAHA3G,EAAQuF,QACRmJ,aAAaC,QAlCe,mBAkCWf,IACvCc,aAAaC,QApCQ,aAoCWE,KAAKC,UAAU9O,IACxC,CACLqnB,iBAAiB,EACjBtZ,YAAaH,GACb0Z,eAAgBtnB,G0B+LqCunB,GAAjDF,EAFoB,EAEpBA,gBAAiBtZ,EAFG,EAEHA,YAAauZ,EAFV,EAEUA,eAEhC1b,EAAKkC,yBAEPuZ,GACF3Z,GAAuB4Z,EAAgB1b,GAGzC,IAAMiY,EAAsB,CAC1BC,KAAMT,GAAKje,KACXpF,QAASsnB,EAET/Y,gBAAYpF,EACZ8d,sBAAkB9d,EAClBqe,mBAAere,EACf6S,qBAAsB,CACpBhM,WAAO7G,EACP/E,YAAQ+E,EACR4K,2BAAuB5K,EACvBxJ,eAAWwJ,EACXoG,QAAS4Q,GAAQ1Q,YAtBO,EA6BxBgY,qBAAWb,GAAS/C,GA7BI,0BA2BxBC,EA3BwB,EA2BxBA,KAAM9jB,EA3BkB,EA2BlBA,QAASinB,EA3BS,EA2BTA,iBAAkBjL,EA3BT,EA2BSA,qBACnCzc,EA5B0B,KA0F5B,OACE,oCACE,yBAAK5B,UAAU,UACb,kBAAChC,EAAD,OAEF,yBAAKgC,UAAU,YAAY/B,MAAO,CAAEC,gBAAiB,YAEnD,kBAACgS,GAAD,CACEtO,SAAUA,EACVS,QAASA,EACT+N,YAAaA,EACbC,YAAa8V,IAAST,GAAKwD,UAE7B,kBAAC/U,GAAD,CAAevS,SAAUA,IAxEd,SAACukB,GAIhB,OAHIA,IAAST,GAAKwD,SAAW/C,IAAST,GAAK0D,cACzCrY,aAAagZ,WAAW,eAElB5D,GACN,KAAKT,GAAKje,KACR,OAAO,kBAACrF,EAAD,CAAUC,QAASA,EAAST,SAAUA,IAE/C,KAAK8jB,GAAK0D,aACR,OAAO,kBAACzB,GAAD,MAET,KAAKjC,GAAK5S,KACR,OACE,oCACE,kBAAC,GAAD,CACEzQ,QAASA,EACTT,SAAUA,KAKlB,KAAK8jB,GAAKwD,QACR,OACE,kBAAC,GAAD,CACEtnB,SAAUA,EACVyc,qBAAsBA,EACtBhc,QAASA,IAIf,KAAKqjB,GAAKyD,MACR,OACE,kBAAClD,GAAD,CAAY5H,qBAAsBA,IAGtC,KAAKqH,GAAK2D,YAER,OADA5nB,QAAQC,IAAI4nB,GAEV,kBAAC5B,GAAD,CACE/lB,KAAM2nB,EACN7mB,KACEJ,EAAQE,aAAakE,QAAO,SAACujB,GAC3B,OAAOA,EAAEroB,OAAS2nB,KACjB,KAKX,KAAK5D,GAAK6B,MACR,OACE,kBAAC3I,GAAD,CAAc9H,QAAQ,mCAG1B,KAAK4O,GAAKU,QACR,OAAO,kBAAChE,GAAA,EAAD,CAAkBnkB,MAAO,CAAEqD,OAAQ,WAmBzC2oB,CAAS9D,KCtUE+D,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASxjB,MACvB,2D,6CCVN,SAASyjB,GACP3oB,EACAE,EACA0oB,GAEA,MAAO,CACL5oB,OACAE,OACA0oB,aAUWC,I,uLAAAA,wBAAU,CACvBC,QAAS,EACTC,OAAQ,CACNC,uBAAY,CACVhpB,KAAMkM,GAAUQ,MAChB6V,QAAS,CACPoG,GAAa,OAAQ,UACrBA,GAAa,aAAc,aAG/BK,uBAAY,CACVhpB,KAAMkM,GAAUoB,MAChBiV,QAAS,CACPoG,GAAa,aAAc,UAC3BA,GAAa,aAAc,UAC3BA,GAAa,iBAAkB,UAC/BA,GAAa,UAAW,UAAU,GAClCA,GAAa,QAAS,UAAU,GAChCA,GAAa,OAAQ,UAAU,GAC/BA,GAAa,QAAS,UACtBA,GAAa,QAAS,aAG1BK,uBAAY,CACVhpB,KAAMkM,GAAU6D,SAChBwS,QAAS,CACPoG,GAAa,aAAc,UAC3BA,GAAa,WAAY,aAG7BK,uBAAY,CACVhpB,KAAMkM,GAAU+N,eAChBsI,QAAS,CACPoG,GAAa,aAAc,UAAU,GACrCA,GAAa,UAAW,UAAU,GAClCA,GAAa,aAAc,cAK/BK,uBAAY,CACVhpB,KAAMkM,GAAU7F,KAChBkc,QAAS,CAACoG,GAAa,OAAQ,UAAU,MAE3CK,uBAAY,CACVhpB,KAAMkM,GAAU+c,WAChB1G,QAAS,CACPoG,GAAa,SAAU,UAAU,GACjCA,GAAa,UAAW,UAAU,S,4CCrErBO,I,GAQlBC,gBAAK,c,GACLA,gBAAK,c,GACLA,gBAAK,kB,GACLC,iBAAM,W,GACNA,iBAAM,S,GACNA,iBAAM,Q,GACNA,iBAAM,S,GACNA,iBAAM,S,ykBAfyBC,U,GACzBC,MAAQpd,GAAUoB,M,GAClBic,c,qBACJrd,GAAUQ,MAAQ,CAAExM,KAAM,aAAcM,IAAK,Y,eAC7C0L,GAAU+c,WAAa,CAAE/oB,KAAM,WAAYspB,WAAY,Y,eACvDtd,GAAU+N,eAAiB,CAAE/Z,KAAM,WAAYspB,WAAY,Y,k2BCJ3C/pB,I,GAMlB2pB,iBAAM,Q,GACND,gBAAK,c,GACLM,oBAASvd,GAAUoB,O,ubAEE3O,EAAea,G,6FACtByE,KAAKuI,YAAYC,IAAIP,GAAUoB,OAAOjQ,QAAO,SAAC2I,GACzDA,EAAK8R,QAAU,EAAKtK,GACpBxH,EAAKrH,MAAQA,EACbqH,EAAKxG,KAAOA,K,sJAdgB6pB,U,GACzBC,MAAQpd,GAAUQ,M,GAClB6c,a,eACJrd,GAAUoB,MAAQ,CAAEpN,KAAM,WAAYspB,WAAY,Y,uWAOpD7c,W,0ECXkBwS,I,GAMlBgK,gBAAK,c,GACLA,gBAAK,Y,sWAP6BE,U,GAC5BC,MAAQpd,GAAU6D,S,GAClBwZ,a,eACJrd,GAAU+N,eAAiB,CAAE/Z,KAAM,WAAYspB,WAAY,e,oQAM7DE,S,yEAAazlB,KAAKuI,YAChBC,IAAIP,GAAUoB,OACdV,MAAMC,KAAE8c,GAAGzd,GAAU+N,eAAgB,aAAchW,KAAKuJ,KACxDR,W,ICZgB4c,I,GAOlBR,iBAAM,c,GACNA,iBAAM,W,GACNA,iBAAM,c,0WATgCC,U,GAChCC,MAAQpd,GAAU+N,e,GAClBsP,c,qBACJrd,GAAU6D,SAAW,CAAE7P,KAAM,aAAcM,IAAK,e,eAChD0L,GAAUoB,MAAQ,CAAEpN,KAAM,aAAcM,IAAK,Y,kVCJ7BqpB,I,GAMlBT,iBAAM,Q,kTANwBC,U,GACxBC,MAAQpd,GAAU7F,K,GAClBkjB,a,eACJrd,GAAU+c,WAAa,CAAE/oB,KAAM,WAAYspB,WAAY,W,mJAKzDE,S,yEAAazlB,KAAKuI,YAChBC,IAAIP,GAAUoB,OACdV,MAAMC,KAAE8c,GAAGzd,GAAU+c,WAAY,SAAUhlB,KAAKuJ,KAChDR,W,ICXgB8c,I,GAOlBV,iBAAM,U,GACNA,iBAAM,W,sTAR4BC,U,GAC5BC,MAAQpd,GAAU+c,W,GAClBM,c,qBACJrd,GAAU7F,KAAO,CAAEnG,KAAM,aAAcM,IAAK,W,eAC5C0L,GAAUoB,MAAQ,CAAEpN,KAAM,aAAcM,IAAK,Y,iOCQ5CupB,GAAU,IAAIC,KAAc,CAChCC,UACAC,cAAc,EACdC,yBAAyB,IAGrBzF,GAAW,IAAI0F,YAAS,CAC5BL,WACAM,aAAc,CAACnB,GAAMzpB,GAAM0f,GAASyK,GAAaC,GAAKC,IACtDQ,gBAAgB,IAGlBC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,KAAD,CAAkB/F,SAAUA,IAC1B,kBAAC,GAAD,QAGJjT,SAASiZ,eAAe,SRgGpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBnb,MAAK,SAAAob,GACJA,EAAaC,gBAEdpb,OAAM,SAAA+P,GACL5f,QAAQ4f,MAAMA,EAAMvK,c","file":"static/js/main.4db772b7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/wrongBtn.f1294bc2.svg\";","module.exports = __webpack_public_path__ + \"static/media/correctBtn.dfcec944.svg\";","module.exports = __webpack_public_path__ + \"static/media/confettiEmoji.cf8cb21d.png\";","import React from \"react\";\r\n\r\nexport default function NavBar() {\r\n  return (\r\n    <>\r\n      <div style={{ backgroundColor: \"white\" }}>\r\n        <h1>Goi</h1>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\nimport { makeStyles, Theme, createStyles } from \"@material-ui/core/styles\";\nimport clsx from \"clsx\";\nimport Card from \"@material-ui/core/Card\";\nimport CardHeader from \"@material-ui/core/CardHeader\";\n// import CardMedia from '@material-ui/core/CardMedia';\nimport CardContent from \"@material-ui/core/CardContent\";\nimport CardActions from \"@material-ui/core/CardActions\";\nimport Collapse from \"@material-ui/core/Collapse\";\n// import Avatar from '@material-ui/core/Avatar';\nimport IconButton from \"@material-ui/core/IconButton\";\nimport Typography from \"@material-ui/core/Typography\";\n// import { red } from '@material-ui/core/colors';\n// import FavoriteIcon from '@material-ui/icons/Favorite';\n// import ShareIcon from '@material-ui/icons/Share';\nimport ExpandMoreIcon from \"@material-ui/icons/ExpandMore\";\n// import MoreVertIcon from '@material-ui/icons/MoreVert';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      // maxWidth: 345,\n    },\n    media: {\n      height: 0,\n      paddingTop: \"56.25%\", // 16:9\n    },\n    expand: {\n      transform: \"rotate(0deg)\",\n      marginLeft: \"auto\",\n      transition: theme.transitions.create(\"transform\", {\n        duration: theme.transitions.duration.shortest,\n      }),\n    },\n    expandOpen: {\n      transform: \"rotate(180deg)\",\n    },\n    avatar: {\n      backgroundColor: \"red\",\n    },\n  })\n);\n\ntype Props = { style?: {}; front: string; back: string };\n\nexport default function NewCard(props: Props) {\n  const classes = useStyles();\n  const [expanded, setExpanded] = React.useState(false);\n\n  const handleExpandClick = () => {\n    setExpanded(!expanded);\n  };\n\n  return (\n    <>\n      <Card\n        style={{\n          marginTop: \"2em\",\n          width: \"23em\",\n          display: \"flex\",\n          flexDirection: \"column\",\n        }}\n        className={classes.root}\n      >\n        <CardHeader title=\"\" />\n        <CardContent>\n          <div style={{ height: \"3em\", marginTop: \"3em\" }}>\n            <Typography paragraph style={{}}>\n              {props.front}\n            </Typography>\n          </div>\n        </CardContent>\n        <CardActions disableSpacing>\n          <IconButton\n            className={clsx(classes.expand, {\n              [classes.expandOpen]: expanded,\n            })}\n            onClick={handleExpandClick}\n            aria-expanded={expanded}\n            aria-label=\"show more\"\n          >\n            <ExpandMoreIcon />\n          </IconButton>\n        </CardActions>\n        <Collapse in={expanded} timeout=\"auto\" unmountOnExit>\n          <CardContent\n            style={{\n              marginTop: \"4em\",\n            }}\n          >\n            <div style={{ height: \"5em\", alignItems: \"center\" }}>\n              <Typography paragraph>{props.back}</Typography>\n            </div>\n          </CardContent>\n        </Collapse>\n      </Card>\n    </>\n  );\n}\n","import React from \"react\";\r\nimport { Paper } from \"@material-ui/core\";\r\nimport CenteredTabs from \"./CenteredTabs\";\r\n\r\ntype DeckProps = { name: string; dispatch?; key: number };\r\ntype ListProps = { deckNames: string[]; dispatch? };\r\n\r\nfunction Deck(props: DeckProps) {\r\n  return (\r\n    <Paper\r\n      style={{\r\n        margin: \"2em\",\r\n        width: \"20vw\",\r\n        height: \"12vw\",\r\n        justifyItems: \"center\",\r\n        display: \"flex\",\r\n        fontSize: \"1.5em\",\r\n      }}\r\n      onClick={() => {\r\n        console.log(props.name);\r\n        props.dispatch({ type: \"view deck detail\", deckName: props.name });\r\n      }}\r\n    >\r\n      <div style={{ margin: \"auto\" }}>{props.name}</div>\r\n    </Paper>\r\n  );\r\n}\r\n\r\nexport default function ListView(props: ListProps) {\r\n  return (\r\n    <>\r\n      {props.deckNames.map((deckName, idx) => (\r\n        <Deck key={idx} name={deckName} dispatch={props.dispatch}></Deck>\r\n      ))}\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport NewCard from \"./NewCard\";\r\n\r\n// import React from 'react';\r\nimport CenteredTabs from \"./CenteredTabs\";\r\nimport { Paper } from \"@material-ui/core\";\r\nimport ListView from \"./ListView\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\nimport DECK from \"../ast/DECK\";\r\n\r\nexport default function DeckView({\r\n  program,\r\n  dispatch,\r\n}: {\r\n  program: PROGRAM;\r\n  dispatch: Function;\r\n}) {\r\n  const decks: DECK[] = program?.create_decks?.map((cd) => cd.deck);\r\n  if (!decks || decks.length === 0) {\r\n    return (\r\n      <div style={{ textAlign: \"center\" }}>\r\n        <h2>You have no deck!  Enter something in the editor!</h2>\r\n      </div>\r\n    );\r\n  }\r\n  const lastDeck = decks[decks.length - 1];\r\n  const { front, back } = lastDeck.cards[lastDeck.cards.length - 1];\r\n\r\n  return (\r\n    <>\r\n      <div className=\"card-view-container\">\r\n        <div className=\"card-view\">\r\n          <h1 style={{ color: \"#333333\" }}>\r\n            Deck: {program.create_decks[program.create_decks.length - 1].name}\r\n          </h1>\r\n          <NewCard front={front} back={back}></NewCard>\r\n          <div\r\n            style={{\r\n              marginTop: \"2em\",\r\n              display: \"grid\",\r\n              gridTemplateColumns: \"1fr 1fr\",\r\n            }}\r\n          >\r\n            <ListView\r\n              deckNames={program.create_decks.map((cd) => cd.name)}\r\n              dispatch={dispatch}\r\n            ></ListView>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","export function debug(...items: any): void {\r\n  if (isDebugEnabled()) {\r\n    console.log(...items);\r\n  }\r\n}\r\n\r\nexport function debugDB(...items: any): void {\r\n  debug(\" \", ...items);\r\n}\r\n\r\nfunction isDebugEnabled(): boolean {\r\n  return (\r\n    process.env.REACT_APP_DEBUG &&\r\n    process.env.REACT_APP_DEBUG.toLowerCase() === \"on\"\r\n  );\r\n}\r\n\r\nexport function shuffle<T>(arr: Array<T>): Array<T> {\r\n  return arr.sort(() => Math.random() - 0.5);\r\n}\r\n\r\nexport function createCardData(\r\n  index: number,\r\n  front: string,\r\n  back: string,\r\n  correct: number,\r\n  incorrect: number,\r\n  deck: string\r\n) {\r\n  const score = correct.toString() + \"/\" + (incorrect + correct).toString();\r\n  const indexString = index.toString() + \".)\";\r\n  return { indexString, front, back, score, deck };\r\n}\r\n\r\nexport function createSummaryData(\r\n  index: number,\r\n  front: string,\r\n  back: string,\r\n  isCorrect: boolean,\r\n  deck: string,\r\n  tags?: string[]\r\n) {\r\n  let results;\r\n  if (isCorrect === undefined) {\r\n    results = \"skipped\";\r\n  } else {\r\n    results = isCorrect ? \"correct\" : \"incorrect\";\r\n  }\r\n\r\n  let tagsString;\r\n  if (tags && tags.length > 0) {\r\n    tagsString = tags.join(\", \");\r\n  } else {\r\n    tagsString = \"none\";\r\n  }\r\n  const indexString = index.toString() + \".)\";\r\n  return { indexString, front, back, results, deck, tagsString };\r\n}\r\n\r\nexport function createDeckData(\r\n  index: number,\r\n  name: string,\r\n  count: number,\r\n  score: number\r\n) {\r\n  const indexString = index.toString() + \".)\";\r\n  return { indexString, name, count, score };\r\n}\r\n\r\nexport function createSessionData(\r\n  index: number,\r\n  count: number,\r\n  correct: number,\r\n  startDate: number,\r\n  endDate: number,\r\n  decks: string[]\r\n) {\r\n  const score = correct.toString() + \"/\" + count.toString();\r\n  const decksString = decks.join(\", \");\r\n  const indexString = index.toString() + \".)\";\r\n  const startDateConverted = +new Date(startDate);\r\n  const endDateConverted = +new Date(endDate);\r\n  const dateString = startDateConverted.toString();\r\n\r\n  const diffMs = startDateConverted - endDateConverted;\r\n  let duration = Math.round(((diffMs % 86400000) % 3600000) / 60000); // minutes\r\n\r\n  return { indexString, dateString, count, score, duration, decksString };\r\n}\r\n\r\n// shuffle function from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function randomize(subjects: any[]): any[] {\r\n  let shuffledCards = subjects;\r\n  for (let i = shuffledCards.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    const temp = shuffledCards[i];\r\n    shuffledCards[i] = shuffledCards[j];\r\n    shuffledCards[j] = temp;\r\n  }\r\n  return shuffledCards;\r\n}\r\n","import { debug } from \"./utils\";\r\n\r\nclass Tokenizer {\r\n  private static program: string;\r\n  private static literals: Array<string>;\r\n  private tokens: Array<string>;\r\n  private currentToken: number;\r\n  private static theTokenizer: Tokenizer;\r\n\r\n  private constructor(content: string, literalsList: Array<string>) {\r\n    Tokenizer.program = content;\r\n    Tokenizer.literals = literalsList;\r\n    this.tokens = [];\r\n    this.currentToken = 0;\r\n\r\n    this.tokenize();\r\n  }\r\n\r\n  tokenize(): void {\r\n    let tokenizedProgram = Tokenizer.program;\r\n    tokenizedProgram = tokenizedProgram.replace(/\\n/g, \"_\");\r\n    debug(Tokenizer.program);\r\n\r\n    Tokenizer.literals.forEach((s) => {\r\n      debug(\"string: \", s);\r\n      const re = new RegExp(s, \"ig\");\r\n      debug(\"regexp: \", re);\r\n      tokenizedProgram = tokenizedProgram.replace(re, `_${s}_`);\r\n      debug(tokenizedProgram);\r\n    });\r\n    tokenizedProgram = tokenizedProgram.replace(/__/g, \"_\");\r\n    debug(tokenizedProgram);\r\n    const temparray = tokenizedProgram.split(\"_\");\r\n    const slicedArray = temparray.slice(1);\r\n    this.tokens = slicedArray.map((t) => t.trim()).filter((t) => t !== \"\");\r\n    debug(this.tokens);\r\n  }\r\n\r\n  checkNext(): string {\r\n    let token = \"\";\r\n\r\n    if (this.currentToken < this.tokens.length) {\r\n      token = this.tokens[this.currentToken];\r\n    } else {\r\n      token = \"NO_MORE_TOKENS\";\r\n    }\r\n\r\n    return token;\r\n  }\r\n\r\n  getNext(): string {\r\n    let token = \"\";\r\n\r\n    if (this.currentToken < this.tokens.length) {\r\n      token = this.tokens[this.currentToken];\r\n      this.currentToken++;\r\n    } else {\r\n      token = \"NULLTOKEN\";\r\n    }\r\n\r\n    return token;\r\n  }\r\n\r\n  checkToken(regexp: string): boolean {\r\n    const s = this.checkNext();\r\n    const re = new RegExp(regexp);\r\n    debug(`comparing: |${s}|  to  |${regexp}|`);\r\n    return !!s.match(re);\r\n  }\r\n\r\n  getAndCheckToken(regexp: string): string {\r\n    const s = this.getNext();\r\n    const re = new RegExp(regexp);\r\n\r\n    if (!s.match(re)) {\r\n      throw Error(\r\n        `Unexpected next token for Parsing! Expected something matching: ${regexp} but got: ${s}`\r\n      );\r\n    }\r\n    debug(`matched: ${s}  to  ${regexp}`);\r\n    return s;\r\n  }\r\n\r\n  moreTokens(): boolean {\r\n    return this.currentToken < this.tokens.length;\r\n  }\r\n\r\n  static makeTokenizer(content: string, literals: Array<string>): void {\r\n    this.theTokenizer = new Tokenizer(content, literals);\r\n  }\r\n\r\n  static getTokenizer(): Tokenizer {\r\n    return this.theTokenizer;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n","import Tokenizer from \"../lib/tokenizer\";\n\nexport default class NODE {\n  tokenizer = Tokenizer.getTokenizer();\n  parse() {\n    throw new Error(\"parse not implemented\");\n  }\n  evaluate() {\n    throw new Error(\"evaluate not implemented\");\n  }\n}\n","import NODE from \"./NODE\";\n\nexport default class CARD extends NODE {\n  cardNumber: number = 0;\n  front: string = \"\";\n  back: string = \"\";\n  parse() {\n    this.tokenizer.getAndCheckToken(\"\\\\(\");\n    const isIntString = this.tokenizer.checkToken(\"^[1-9]+[0-9]*$\");\n    if (isIntString) {\n      this.cardNumber = parseInt(this.tokenizer.getNext());\n      this.tokenizer.getAndCheckToken(\"\\\\)\");\n      this.front = this.tokenizer.getNext();\n      this.tokenizer.getAndCheckToken(\":\");\n      this.back = this.tokenizer.getNext();\n    } else {\n      throw new Error(\"Card number incorrect in Card\");\n    }\n  }\n}\n","import NODE from \"./NODE\";\r\nimport CARD from \"./CARD\";\r\n\r\nexport default class DECK extends NODE {\r\n  cards: CARD[] = [];\r\n  parse() {\r\n    while (\r\n      this.tokenizer.moreTokens() &&\r\n      !this.tokenizer.checkToken(\"add color\") &&\r\n      !this.tokenizer.checkToken(\"add direction\") &&\r\n      !this.tokenizer.checkToken(\"add alignment\") &&\r\n      !this.tokenizer.checkToken(\"add tags\") &&\r\n      !this.tokenizer.checkToken(\"create deck\")\r\n    ) {\r\n      let card = new CARD();\r\n      card.parse();\r\n      this.cards.push(card);\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\n\nexport default class TAG extends NODE {\n  tagName: string = \"\";\n  parse() {\n    this.tagName = this.tokenizer.getNext();\n  }\n}\n","import NODE from \"./NODE\";\r\nimport TAG from \"./TAG\";\r\n\r\nexport default class TAGS extends NODE {\r\n  tags: TAG[] = [];\r\n  type = \"tags\";\r\n\r\n  parseInteractivePrompt() {\r\n    this.tokenizer.getAndCheckToken(\"tags:\");\r\n    while (this.tokenizer.moreTokens()) {\r\n      let tag = new TAG();\r\n      tag.parse();\r\n      this.tags.push(tag);\r\n      if (this.tokenizer.checkNext() === \",\") {\r\n        this.tokenizer.getNext();\r\n      }\r\n    }\r\n  }\r\n\r\n  parse() {\r\n    const nextToken = this.tokenizer.checkNext().toLowerCase();\r\n    if (nextToken === \"add tags\") {\r\n      this.tokenizer.getNext();\r\n    }\r\n    this.tokenizer.getAndCheckToken(\":\");\r\n    while (\r\n      this.tokenizer.moreTokens() &&\r\n      !this.tokenizer.checkToken(\"add color\") &&\r\n      !this.tokenizer.checkToken(\"add direction\") &&\r\n      !this.tokenizer.checkToken(\"add alignment\") &&\r\n      !this.tokenizer.checkToken(\"\\\\(\")\r\n    ) {\r\n      if (this.tokenizer.checkNext() === \",\") {\r\n        this.tokenizer.getNext();\r\n      }\r\n      let tag = new TAG();\r\n      tag.parse();\r\n      this.tags.push(tag);\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\ninterface AttributeObj {\r\n  attributeType: string;\r\n  value: string;\r\n}\r\n\r\nexport default class ATTRIBUTE extends NODE {\r\n  attribute: AttributeObj = { attributeType: \"\", value: \"\" };\r\n\r\n  parse() {\r\n    const currentAttribute = this.tokenizer.getNext();\r\n    this.tokenizer.getAndCheckToken(\":\");\r\n    switch (currentAttribute) {\r\n      case \"add Alignment\":\r\n        this.attribute.attributeType = \"alignment\";\r\n        if (this.tokenizer.checkToken(\"center|right|left\")) {\r\n          this.attribute.value = this.tokenizer.getNext();\r\n        } else {\r\n          throw new Error(\"Alignment Attribute is not valid\");\r\n        }\r\n        break;\r\n      case \"add Direction\":\r\n        this.attribute.attributeType = \"direction\";\r\n        if (this.tokenizer.checkToken(\"horizontal|vertical\")) {\r\n          this.attribute.value = this.tokenizer.getNext();\r\n        } else {\r\n          throw new Error(\"Direction Attribute is not valid\");\r\n        }\r\n        break;\r\n      case \"add Color\":\r\n        this.attribute.attributeType = \"color\";\r\n        if (\r\n          this.tokenizer.checkToken(\"red|blue|yellow|purple|green|grey|brown\")\r\n        ) {\r\n          this.attribute.value = this.tokenizer.getNext();\r\n        } else {\r\n          throw new Error(\"Color Attribute is not valid\");\r\n        }\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport ATTRIBUTE from \"./ATTRIBUTE\";\r\n\r\nexport default class ATTRIBUTES extends NODE {\r\n  attributes: ATTRIBUTE[] = [];\r\n  parse() {\r\n    const areAttributes = this.tokenizer.checkToken(\r\n      \"add color|add alignment|add direction\"\r\n    );\r\n    if (areAttributes) {\r\n      while (\r\n        this.tokenizer.moreTokens() &&\r\n        !this.tokenizer.checkToken(\"add tags\") &&\r\n        !this.tokenizer.checkToken(\"\\\\(\")\r\n      ) {\r\n        let attribute = new ATTRIBUTE();\r\n        attribute.parse();\r\n        this.attributes.push(attribute);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport DECK from \"./DECK\";\r\nimport TAGS from \"./TAGS\";\r\nimport ATTRIBUTES from \"./ATTRIBUTES\";\r\n\r\nconst invalidNameTokens = [\":\", \"(\", \")\", \",\", \"NULLTOKEN\"];\r\n\r\nexport default class CREATE_DECK extends NODE {\r\n  tags: TAGS | null = null;\r\n  attributes: ATTRIBUTES | null = null;\r\n  deck: DECK | null = null;\r\n  name: string = \"\";\r\n\r\n  checkForAndParseTags() {\r\n    const nextToken = this.tokenizer.checkNext().toLowerCase();\r\n    if (nextToken === \"add tags\") {\r\n      this.tags = new TAGS();\r\n      this.tags.parse();\r\n    }\r\n  }\r\n\r\n  checkForAndParseAttributes() {\r\n    if (this.tokenizer.checkToken(\"add color|add alignment|add direction\")) {\r\n      this.attributes = new ATTRIBUTES();\r\n      this.attributes.parse();\r\n    }\r\n  }\r\n\r\n  checkForAndParseDeck() {\r\n    if (this.tokenizer.checkToken(\"\\\\(\")) {\r\n      this.deck = new DECK();\r\n      this.deck.parse();\r\n    }\r\n  }\r\n\r\n  parse() {\r\n    //parse deck\r\n    this.tokenizer.getAndCheckToken(\"create deck\");\r\n    const name = this.tokenizer.getNext();\r\n    if (invalidNameTokens.includes(name)) {\r\n      throw new Error(\"invalid deck name\");\r\n    }\r\n    this.name = name;\r\n    this.tokenizer.getAndCheckToken(\":\");\r\n    while (this.tokenizer.moreTokens()) {\r\n      this.checkForAndParseTags();\r\n      this.checkForAndParseAttributes();\r\n      this.checkForAndParseDeck();\r\n      break;\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport CREATE_DECK from \"./CREATE_DECK\";\r\n\r\nexport default class PROGRAM extends NODE {\r\n  create_decks: CREATE_DECK[] = [];\r\n  parse() {\r\n    while (this.tokenizer.moreTokens()) {\r\n      if (this.tokenizer.checkToken(\"create deck\")) {\r\n        let create_deck = new CREATE_DECK();\r\n        create_deck.parse();\r\n        this.create_decks.push(create_deck);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n","export const keywords = [\r\n  \"show stats for\",\r\n  \"start session from\",\r\n  \"help\",\r\n  \"list\",\r\n  \"export decks\",\r\n  \"load decks\",\r\n  \"quit\",\r\n  \"back to home\",\r\n  \",\",\r\n  \"cards from\",\r\n];\r\nexport const validCardFilter = [\"best\", \"worst\", \"random\", \"oldest\", \"newest\"];\r\nexport const subjectKeywords = [\"decks:\", \"tags:\", \"past sessions\"];\r\n\r\nexport const allTokens = [...validCardFilter, ...keywords, ...subjectKeywords];\r\n\r\nexport const deckCreationLiterals = [\"create deck\", \":\", \"\\\\(\", \"\\\\)\", \",\"];\r\n","export type Range = { lineNumber: number; charStart: number; charEnd: number };\r\n\r\n/**\r\n * Applies syntax highlighting to a CodeMirror editor\r\n * Should be called onChange\r\n *\r\n * @param editor The CodeMirror Editor instance\r\n * @param literals lower case strings for exact matching\r\n * @param className CSS classname (optional)\r\n */\r\nexport function highlight(\r\n  editor: CodeMirror.Editor,\r\n  literals: string[],\r\n  className?: string\r\n) {\r\n  const doc = editor.getDoc();\r\n  const value = doc.getValue();\r\n  const highlights = getHighlights(value, literals);\r\n  highlights.forEach((highlight) => {\r\n    doc.markText(\r\n      { line: highlight.lineNumber, ch: highlight.charStart },\r\n      { line: highlight.lineNumber, ch: highlight.charEnd },\r\n      { className: className || \"syntax-highlight\" }\r\n    );\r\n  });\r\n}\r\n\r\nfunction getHighlights(program: string, literals: string[]): Range[] {\r\n  program = program.toLowerCase();\r\n  const lines = program.split(\"\\n\");\r\n  const ranges: Range[] = [];\r\n  lines.forEach((line, lineNumber) => {\r\n    literals.forEach((literal) => {\r\n      const idx = line.indexOf(literal);\r\n      if (idx !== -1) {\r\n        ranges.push({\r\n          lineNumber,\r\n          charStart: idx,\r\n          charEnd: idx + literal.length,\r\n        });\r\n      }\r\n    });\r\n  });\r\n  return ranges;\r\n}\r\n","import PROGRAM from \"../ast/PROGRAM\";\r\nimport CREATE_DECK from \"../ast/CREATE_DECK\";\r\nimport CARD from \"../ast/CARD\";\r\n\r\nexport enum GuessType {\r\n  CreateDeck = \"create deck\",\r\n  CreateCard = \"create card\",\r\n  UpdateDeckName = \"update deck name\",\r\n  UpdateCardFront = \"update card front\",\r\n  UpdateCardBack = \"update card back\",\r\n  CopyPasteMultiDecks = \"copy paste multi decks\",\r\n  CopyPasteSingleDeck = \"copy paste single deck\",\r\n  Delete = \"deleted something\",\r\n  Nothing = \"nothing\",\r\n}\r\n\r\nexport type Guess =\r\n  | {\r\n      type: GuessType.CreateDeck;\r\n      deckName: string;\r\n    }\r\n  | {\r\n      type: GuessType.UpdateDeckName;\r\n      oldDeckName: string;\r\n      newDeckName: string;\r\n    }\r\n  | {\r\n      type: GuessType.CreateCard;\r\n      deckName: string;\r\n      front: string;\r\n      back: string;\r\n    }\r\n  | {\r\n      type: GuessType.UpdateCardFront;\r\n      deckName: string;\r\n      oldFront: string;\r\n      newFront: string;\r\n      back: string;\r\n    }\r\n  | {\r\n      type: GuessType.UpdateCardBack;\r\n      deckName: string;\r\n      front: string;\r\n      oldBack: string;\r\n      newBack: string;\r\n    }\r\n  | {\r\n      type:\r\n        | GuessType.CopyPasteMultiDecks // Massively create if doesn't exist\r\n        | GuessType.Nothing\r\n        | GuessType.Delete; // Do nothing\r\n    }\r\n  | {\r\n      type: GuessType.CopyPasteSingleDeck;\r\n      deckName: string;\r\n    };\r\n\r\nfunction guessNewDeck(oldDecks: CREATE_DECK[], newDecks: CREATE_DECK[]): Guess {\r\n  // we have more new decks than old decks\r\n  const oldDeckNames = {};\r\n  oldDecks.forEach((od) => {\r\n    oldDeckNames[od.name] = true;\r\n  });\r\n  const newDecksFound = [];\r\n  newDecks.forEach((nd, idx) => {\r\n    if (!oldDeckNames[nd.name]) {\r\n      newDecksFound.push({ name: nd.name, idx });\r\n    }\r\n  });\r\n  if (newDecksFound.length === 1) {\r\n    const { name, idx } = newDecksFound[0];\r\n    const hasCards = newDecks[idx].deck.cards?.length > 1;\r\n    if (!hasCards) {\r\n      return {\r\n        type: GuessType.CreateDeck,\r\n        deckName: name,\r\n      };\r\n    } else {\r\n      return {\r\n        // Gained some cards along with a new deck, so user must have copy pasted\r\n        type: GuessType.CopyPasteSingleDeck,\r\n        deckName: name,\r\n      };\r\n    }\r\n  }\r\n  // More than 1 new deck found\r\n\r\n  return {\r\n    type: GuessType.CopyPasteMultiDecks,\r\n  };\r\n}\r\n\r\n// list1 and list2 have the same number of elements\r\nfunction numberOfDifferingNames(\r\n  list1: CREATE_DECK[],\r\n  list2: CREATE_DECK[]\r\n): number {\r\n  return list1.reduce(\r\n    (acc, deck1, i) => (deck1.name !== list2[i].name ? acc + 1 : acc),\r\n    0\r\n  );\r\n}\r\n\r\nfunction haveSameCards(deck1: CREATE_DECK, deck2: CREATE_DECK): boolean {\r\n  if (deck1.deck?.cards?.length !== deck2.deck?.cards?.length) {\r\n    return false;\r\n  }\r\n  if (deck1.deck?.cards == null || deck2.deck?.cards == null) {\r\n    // only one is null or undefined so they are not the same deck\r\n    return false;\r\n  }\r\n\r\n  // same length and neither is null undefined, so check the cards\r\n  const cards1 = deck1.deck.cards;\r\n  const cards2 = deck2.deck.cards;\r\n  // attempt to find a difference\r\n  return !cards1.find((c1, idx) => {\r\n    const c2 = cards2[idx];\r\n    return (\r\n      c1.cardNumber !== c2.cardNumber ||\r\n      c1.front !== c2.front ||\r\n      c1.back !== c2.back\r\n    );\r\n  });\r\n}\r\n\r\nfunction guessPossiblyRenamedDeck(\r\n  oldDecks: CREATE_DECK[],\r\n  newDecks: CREATE_DECK[]\r\n): Guess {\r\n  // find index of deck with different name\r\n  let idx = 0;\r\n  while (idx < oldDecks.length) {\r\n    if (oldDecks[idx].name !== newDecks[idx].name) {\r\n      break;\r\n    }\r\n    ++idx;\r\n  }\r\n\r\n  // check if they have card differences\r\n  const od = oldDecks[idx];\r\n  const nd = newDecks[idx];\r\n\r\n  if (haveSameCards(od, nd)) {\r\n    return {\r\n      type: GuessType.UpdateDeckName,\r\n      oldDeckName: od.name,\r\n      newDeckName: nd.name,\r\n    };\r\n  } else {\r\n    return {\r\n      // A new deck was copypasted and an old one was deleted but we don't care about deletion\r\n      type: GuessType.CopyPasteSingleDeck,\r\n      deckName: nd.name,\r\n    };\r\n  }\r\n}\r\n\r\nfunction compareDeckLengths(oldDecks: CREATE_DECK[], newDecks: CREATE_DECK[]) {\r\n  let numDifferences = 0;\r\n  let firstDifference = undefined;\r\n  oldDecks.forEach((od, idx) => {\r\n    const nd = newDecks[idx];\r\n    if (od.deck?.cards?.length !== nd.deck?.cards?.length) {\r\n      ++numDifferences;\r\n      if (numDifferences === 1) {\r\n        firstDifference = idx;\r\n      }\r\n    }\r\n  });\r\n  return { numDifferences, firstDifference };\r\n}\r\n\r\nfunction guessNewCard(\r\n  oldCards: CARD[],\r\n  updatedCards: CARD[],\r\n  deckName: string\r\n): Guess {\r\n  const newCards: CARD[] = [];\r\n  for (let i = 0; i < oldCards.length; ++i) {\r\n    const { front, back } = oldCards[i];\r\n    const uc = updatedCards[i];\r\n    if (uc.front !== front || uc.back !== back) {\r\n      newCards.push(uc);\r\n    }\r\n  }\r\n\r\n  if (newCards.length === 0) {\r\n    const { front, back } = updatedCards[updatedCards.length - 1];\r\n    // the last card is the new card\r\n    return {\r\n      type: GuessType.CreateCard,\r\n      deckName,\r\n      front,\r\n      back,\r\n    };\r\n  }\r\n\r\n  if (newCards.length === 1) {\r\n    const { front, back } = newCards[0];\r\n    return {\r\n      type: GuessType.CreateCard,\r\n      deckName,\r\n      front,\r\n      back,\r\n    };\r\n  }\r\n\r\n  // More than 1\r\n  return {\r\n    type: GuessType.CopyPasteSingleDeck,\r\n    deckName,\r\n  };\r\n}\r\n\r\n// oldDeckCards and newDeckCards don't have the same length but may individually be null or undefined\r\nfunction guessCardActionInDeck(\r\n  oldDeck: CREATE_DECK,\r\n  newDeck: CREATE_DECK\r\n): Guess {\r\n  const oldDeckCards = oldDeck.deck?.cards;\r\n  const newDeckCards = newDeck.deck?.cards;\r\n  if (oldDeckCards == null) {\r\n    return {\r\n      type: GuessType.CopyPasteSingleDeck,\r\n      deckName: newDeck.name,\r\n    };\r\n  }\r\n  if (newDeckCards == null) {\r\n    return {\r\n      type: GuessType.Delete,\r\n    };\r\n  }\r\n  // both exist\r\n  if (oldDeckCards.length > newDeckCards.length) {\r\n    // Unhandled edge case: random copy paste, can change this to type: CopyPasteSingleDeck\r\n    return {\r\n      type: GuessType.Delete,\r\n    };\r\n  } else {\r\n    // newDeck has more cards\r\n    if (newDeckCards.length === oldDeckCards.length + 1) {\r\n      // exactly 1 new card. So compare the cards\r\n      return guessNewCard(oldDeckCards, newDeckCards, oldDeck.name);\r\n    } else {\r\n      // More than 1 card added, so it was a copy paste\r\n      return {\r\n        type: GuessType.CopyPasteSingleDeck,\r\n        deckName: newDeck.name,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nfunction guessCardUpdate(\r\n  oldDecks: CREATE_DECK[],\r\n  newDecks: CREATE_DECK[]\r\n): Guess {\r\n  let singleDifference: Guess = undefined; // stores the necessary information for a CRUD action\r\n  for (let i = 0; i < oldDecks.length; ++i) {\r\n    const oldCards = oldDecks[i].deck?.cards;\r\n    const newCards = newDecks[i].deck?.cards;\r\n    if (oldCards && newCards) {\r\n      for (let j = 0; j < oldCards.length; ++j) {\r\n        if (\r\n          oldCards[j].front === newCards[j].front &&\r\n          oldCards[j].back === newCards[j].back\r\n        ) {\r\n          continue;\r\n        }\r\n        if (\r\n          oldCards[j].front === newCards[j].front &&\r\n          oldCards[j].back !== newCards[j].back\r\n        ) {\r\n          if (singleDifference) {\r\n            // Found 2 differences -- guess a copy paste\r\n            return {\r\n              type: GuessType.CopyPasteMultiDecks,\r\n            };\r\n          }\r\n\r\n          singleDifference = {\r\n            type: GuessType.UpdateCardBack,\r\n            deckName: oldDecks[i].name,\r\n            front: oldCards[j].front,\r\n            oldBack: oldCards[j].back,\r\n            newBack: newCards[j].back,\r\n          };\r\n        } else if (\r\n          oldCards[j].front !== newCards[j].front &&\r\n          oldCards[j].back === newCards[j].back\r\n        ) {\r\n          if (singleDifference) {\r\n            // Found 2 differences -- guess a copy paste\r\n            return {\r\n              type: GuessType.CopyPasteMultiDecks,\r\n            };\r\n          }\r\n\r\n          singleDifference = {\r\n            type: GuessType.UpdateCardFront,\r\n            deckName: oldDecks[i].name,\r\n            oldFront: oldCards[j].front,\r\n            newFront: newCards[j].front,\r\n            back: oldCards[j].back,\r\n          };\r\n        } else {\r\n          // guess copy paste\r\n          return {\r\n            type: GuessType.CopyPasteMultiDecks,\r\n          };\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!singleDifference) {\r\n    // User did nothing special, the ASTs are the same\r\n    return {\r\n      type: GuessType.Nothing,\r\n    };\r\n  }\r\n\r\n  return singleDifference;\r\n}\r\n\r\nfunction guessCardAction(\r\n  oldDecks: CREATE_DECK[],\r\n  newDecks: CREATE_DECK[]\r\n): Guess {\r\n  const { numDifferences, firstDifference } = compareDeckLengths(\r\n    oldDecks,\r\n    newDecks\r\n  );\r\n  if (numDifferences > 1) {\r\n    return {\r\n      type: GuessType.CopyPasteMultiDecks,\r\n    };\r\n  }\r\n  if (numDifferences === 1) {\r\n    // Possible creation of new card\r\n    const oldDeck = oldDecks[firstDifference];\r\n    const newDeck = newDecks[firstDifference];\r\n    return guessCardActionInDeck(oldDeck, newDeck);\r\n  }\r\n\r\n  // The decks have same length, so find the single difference if there is one\r\n  return guessCardUpdate(oldDecks, newDecks);\r\n}\r\n\r\n/** Guess the user's CRUD action by comparing previous and current ASTs (`PROGRAM`)\r\n * - Allows DB to respond appropriately upon certain user actions in the editor such as a change in deck name,\r\n * which cannot be determined without analyzing the AST changes\r\n * - Worst case `O(c)` where `c` is the total number of cards\r\n * - `O(d)` where `d` is the total number of decks for cases where a deck has been renamed\r\n *\r\n * @param prev the previous `PROGRAM`\r\n * @param curr the newly parsed `PROGRAM` to reconcile against the previous\r\n * @returns a guess at what the user just did (change deck name, update card front, copy paste a chunk, etc),\r\n * containing enough information to appropriate CRUD commands (such as renaming deck rather than add all the\r\n * cards as new cards when no cards have changed)\r\n */\r\nexport default function guess(prev: PROGRAM, curr: PROGRAM): Guess {\r\n  const oldDecks = prev.create_decks;\r\n  const newDecks = curr.create_decks;\r\n  if (oldDecks.length > newDecks.length) {\r\n    return {\r\n      type: GuessType.Delete,\r\n    };\r\n  }\r\n  if (oldDecks.length < newDecks.length) {\r\n    if (oldDecks.length === newDecks.length - 1) {\r\n      return guessNewDeck(oldDecks, newDecks);\r\n    } else {\r\n      // More than 1 new deck\r\n      return {\r\n        type: GuessType.CopyPasteMultiDecks,\r\n      };\r\n    }\r\n  }\r\n\r\n  // equal deck counts\r\n  const differingNames = numberOfDifferingNames(oldDecks, newDecks);\r\n  if (differingNames > 1) {\r\n    return {\r\n      type: GuessType.CopyPasteMultiDecks,\r\n    };\r\n  }\r\n  if (differingNames === 1) {\r\n    return guessPossiblyRenamedDeck(oldDecks, newDecks);\r\n  }\r\n\r\n  // No difference in deck names, possibly CRUD on single card\r\n  return guessCardAction(oldDecks, newDecks);\r\n}\r\n","export enum TableName {\r\n  DECKS = \"decks\",\r\n  CARDS = \"cards\",\r\n  SESSIONS = \"sessions\",\r\n  SESSIONS_CARDS = \"sessions_cards\",\r\n  TAGS = \"tags\",\r\n  TAGS_CARDS = \"tags_cards\",\r\n}\r\n","import PROGRAM from \"../ast/PROGRAM\";\r\nimport guess, { GuessType, Guess } from \"./guesser\";\r\nimport { Database, Q } from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"../model/constants\";\r\nimport Deck from \"../model/Deck\";\r\nimport { debugDB } from \"./utils\";\r\nimport Card from \"../model/Card\";\r\nimport CREATE_DECK from \"../ast/CREATE_DECK\";\r\n\r\nasync function updateDeckName(oldName: string, newName: string, db: Database) {\r\n  debugDB(`Attempting to update deck name ${oldName} -> ${newName}`);\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n    await db.action(async () => {\r\n      const foundDecks = (await decks\r\n        .query(Q.where(\"name\", Q.eq(oldName)))\r\n        .fetch()) as Deck[];\r\n      if (foundDecks.length === 1) {\r\n        const oldDeck = foundDecks[0];\r\n        await oldDeck.update((deck) => {\r\n          deck.name = newName;\r\n        });\r\n        debugDB(`Success! Updated deck name ${oldName} -> ${newName}`);\r\n      } else {\r\n        throw new Error(\r\n          `reconciler::updateDeckName -- found ${foundDecks.length} decks with the name ${oldName}!`\r\n        );\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debugDB(err);\r\n  }\r\n}\r\n\r\nasync function createOrUpdateCard(guess: Guess, db: Database): Promise<void> {\r\n  if (\r\n    guess.type !== GuessType.UpdateCardFront &&\r\n    guess.type !== GuessType.UpdateCardBack &&\r\n    guess.type !== GuessType.CreateCard\r\n  ) {\r\n    debugDB(\"Unexpected input to reconciler::createOrUpdateCard\");\r\n    return;\r\n  }\r\n  debugDB(`Attempting to create or update card in deck ${guess.deckName}`);\r\n\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n\r\n    await db.action(async () => {\r\n      const foundDecks = (await decks\r\n        .query(Q.where(\"name\", Q.eq(guess.deckName)))\r\n        .fetch()) as Deck[];\r\n      if (foundDecks.length === 1) {\r\n        debugDB(`Corresponding deck found!`);\r\n        const deck = foundDecks[0];\r\n        if (guess.type === GuessType.CreateCard) {\r\n          debugDB(\r\n            `Attempting to add new card. Front: ${guess.front} | Back: ${guess.back}`\r\n          );\r\n          // https://nozbe.github.io/WatermelonDB/Actions.html#calling-actions-from-actions\r\n          await deck.subAction(() => deck.addCard(guess.front, guess.back));\r\n          debugDB(\r\n            `Successfully added card! Front: ${guess.front} | Back: ${guess.back}`\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Update card front or back\r\n        const cards = db.collections.get(TableName.CARDS);\r\n\r\n        if (guess.type === GuessType.UpdateCardFront) {\r\n          const cardsQ = cards.query(\r\n            Q.where(\"back\", Q.eq(guess.back)),\r\n            Q.where(\"front\", Q.eq(guess.oldFront)),\r\n            Q.where(\"deck_id\", Q.eq(deck.id))\r\n          );\r\n          const foundCards = (await cardsQ.fetch()) as Card[];\r\n          if (foundCards.length === 1) {\r\n            debugDB(`Corresponding card found!`);\r\n            const card = foundCards[0];\r\n            await card.update((card) => {\r\n              card.front = guess.newFront;\r\n            });\r\n            debugDB(`Successfully updated card front!`);\r\n          } else {\r\n            throw new Error(\r\n              `reconciler::createOrUpdateCard -- found ${foundCards.length} cards with the same deck, front and back when attempting to update card!`\r\n            );\r\n          }\r\n        } else if (guess.type === GuessType.UpdateCardBack) {\r\n          const cardsQ = cards.query(\r\n            Q.where(\"back\", Q.eq(guess.oldBack)),\r\n            Q.where(\"front\", Q.eq(guess.front)),\r\n            Q.where(\"deck_id\", Q.eq(deck.id))\r\n          );\r\n          const foundCards = (await cardsQ.fetch()) as Card[];\r\n          if (foundCards.length === 1) {\r\n            debugDB(`Corresponding card found!`);\r\n            const card = foundCards[0];\r\n            await card.update((card) => {\r\n              card.back = guess.newBack;\r\n            });\r\n            debugDB(`Successfully updated card back!`);\r\n          } else {\r\n            throw new Error(\r\n              `reconciler::createOrUpdateCard -- found ${foundCards.length} cards with the same deck, front and back when attempting to update card!`\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `reconciler::createOrUpdateCard -- found ${foundDecks.length} decks with the name ${guess.deckName}!`\r\n        );\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debugDB(\"createOrUpdateCard\", err);\r\n  }\r\n}\r\n\r\n// Note: handling GuessType.CreateDeck with createOrUpdateDeck instead\r\nasync function createDeck(deckName: string, db: Database): Promise<void> {\r\n  debugDB(`Attempting to create new deck: ${deckName}`);\r\n  debugDB(`Searching for existence of ${deckName}`);\r\n  // Check if there is a deck with this name\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n    await db.action(async () => {\r\n      const count = await decks\r\n        .query(Q.where(\"name\", Q.eq(deckName)))\r\n        .fetchCount();\r\n      if (count === 1) {\r\n        debugDB(`DB already has this deck, so not going to add it`);\r\n        return;\r\n      }\r\n      if (count > 1) {\r\n        debugDB(`DB has ${count} decks with this name already`);\r\n        return;\r\n      }\r\n      debugDB(`Found 0 decks with this name.`);\r\n      await decks.create((deck: Deck) => {\r\n        deck.name = deckName;\r\n      });\r\n      debugDB(`Successfully created new deck: ${deckName}!`);\r\n    });\r\n  } catch (err) {\r\n    debugDB(\"createDeck\", err);\r\n  }\r\n}\r\n\r\nasync function createOrUpdateEntireDeck(createDeck: CREATE_DECK, db: Database) {\r\n  const name = createDeck.name;\r\n  const cards = createDeck.deck?.cards;\r\n  debugDB(`Reconciling entire deck ${name} with DB...`);\r\n  try {\r\n    const decks = db.collections.get(TableName.DECKS);\r\n    await db.action(async () => {\r\n      const foundDecks = (await decks\r\n        .query(Q.where(\"name\", Q.eq(name)))\r\n        .fetch()) as Deck[];\r\n      if (foundDecks.length === 0) {\r\n        debugDB(`DB has no deck with this name. Creating...`);\r\n        const newDeck = (await decks.create((deck: Deck) => {\r\n          deck.name = name;\r\n        })) as Deck;\r\n        debugDB(`Created!`);\r\n        if (cards) {\r\n          for (const card of cards) {\r\n            debugDB(\r\n              `Creating new card (Front: ${card.front}, Back: ${card.back})`\r\n            );\r\n            // https://nozbe.github.io/WatermelonDB/Actions.html#calling-actions-from-actions\r\n            await newDeck.subAction(() =>\r\n              newDeck.addCard(card.front, card.back)\r\n            );\r\n          }\r\n          debugDB(`Finished adding its cards to the DB!`);\r\n        }\r\n        debugDB(`Done adding deck ${name} to the DB!`);\r\n        return;\r\n      }\r\n      if (foundDecks.length === 1) {\r\n        debugDB(\r\n          `Found 1 deck with this name already in the DB. Reconciling its cards now...`\r\n        );\r\n        const deck = foundDecks[0];\r\n        if (cards) {\r\n          const cardsCollection = db.collections.get(TableName.CARDS);\r\n          for (const card of cards) {\r\n            // Look for an identical card in the deck\r\n            debugDB(\r\n              `Looking for card in deck (Front: ${card.front}, Back: ${card.back})`\r\n            );\r\n            const cardsQ = cardsCollection.query(\r\n              Q.where(\"deck_id\", Q.eq(deck.id)),\r\n              Q.where(\"front\", Q.eq(card.front)),\r\n              Q.where(\"back\", Q.eq(card.back))\r\n            );\r\n            const count = await cardsQ.fetchCount();\r\n            if (count === 1) {\r\n              debugDB(\r\n                `Card already exists in deck (Front: ${card.front}, Back: ${card.back})`\r\n              );\r\n              continue;\r\n            }\r\n            if (count > 1) {\r\n              debugDB(\r\n                `Unexpected: ${count} copies of card exists in deck (Front: ${card.front}, Back: ${card.back})`\r\n              );\r\n              continue;\r\n            }\r\n            // Look for a card in deck with the same front\r\n            debugDB(`Not found. Looking for card with just same front...`);\r\n            const cardFrontQ = cardsCollection.query(\r\n              Q.where(\"deck_id\", Q.eq(deck.id)),\r\n              Q.where(\"front\", Q.eq(card.front))\r\n            );\r\n            const cardsWithSameFront = await cardFrontQ.fetch();\r\n            if (cardsWithSameFront.length === 0) {\r\n              // Look for a card in deck with the same back\r\n              debugDB(`Not found. Looking for card with same back...`);\r\n              const cardBackQ = cardsCollection.query(\r\n                Q.where(\"deck_id\", Q.eq(deck.id)),\r\n                Q.where(\"back\", Q.eq(card.back))\r\n              );\r\n              const cardsWithSameBack = await cardBackQ.fetch();\r\n              if (cardsWithSameBack.length === 0) {\r\n                // Create a new card\r\n                debugDB(\r\n                  `Creating new card (Front: ${card.front}, Back: ${card.back})`\r\n                );\r\n                await deck.subAction(() => deck.addCard(card.front, card.back));\r\n                debugDB(`Done creating new card.`);\r\n                continue;\r\n              }\r\n              if (cardsWithSameBack.length === 1) {\r\n                // Update its front\r\n                const cardToUpdate = cardsWithSameBack[0];\r\n                debugDB(\r\n                  `Found a single card with matching back, so updating front.`\r\n                );\r\n                await cardToUpdate.update((c: Card) => {\r\n                  c.front = card.front;\r\n                });\r\n                debugDB(`Done updating front of card.`);\r\n                continue;\r\n              }\r\n              if (cardsWithSameBack.length > 1) {\r\n                debugDB(\r\n                  `Unexpected: found ${cardsWithSameBack.length} cards in deck have the same back (${card.back})`\r\n                );\r\n                continue;\r\n              }\r\n            }\r\n            if (cardsWithSameFront.length === 1) {\r\n              // Update its back\r\n              const cardToUpdate = cardsWithSameFront[0];\r\n              debugDB(\r\n                `Found a single card with matching front, so updating back.`\r\n              );\r\n              await cardToUpdate.update((c: Card) => {\r\n                c.back = card.back;\r\n              });\r\n              debugDB(`Done updating back of card.`);\r\n              continue;\r\n            }\r\n            if (cardsWithSameFront.length > 1) {\r\n              debugDB(\r\n                `Unexpected: found ${cardsWithSameFront.length} cards in deck have the same front (${card.front})`\r\n              );\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error(`Found ${foundDecks.length} decks with the same name,`);\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debugDB(\"createOrUpdateEntireDeck Error: \", err);\r\n  }\r\n}\r\n\r\nexport async function createOrUpdateAllDecks(program: PROGRAM, db: Database) {\r\n  debugDB(\"Beginning to process what is guessed to be a multi-deck copy paste\");\r\n  try {\r\n    for (const cd of program.create_decks) {\r\n      await createOrUpdateEntireDeck(cd, db);\r\n    }\r\n    debugDB(\r\n      \"Finished processing what is guessed to be a multi-deck copy paste!\"\r\n    );\r\n  } catch (err) {\r\n    debugDB(\"createOrUpdateAllDecks Error: \", err);\r\n  }\r\n}\r\n\r\n/** Reconciles the newly parsed AST with the DB\r\n * - Takes the previous and current AST and issues background CRUD actions\r\n * - Enables preservation of stats during minor card or deck modifications\r\n *\r\n * @param prev the old AST, which should already be in the DB\r\n * @param curr the newly parsed AST\r\n * @param db WatermelonDB instance\r\n */\r\nexport default async function reconcile(\r\n  prev: PROGRAM,\r\n  curr: PROGRAM,\r\n  db: Database\r\n): Promise<void> {\r\n  const guessedAction = guess(prev, curr);\r\n  debugDB(\"Guessed action:\", guessedAction);\r\n\r\n  switch (guessedAction.type) {\r\n    case GuessType.Nothing:\r\n    case GuessType.Delete:\r\n      return;\r\n    case GuessType.UpdateDeckName:\r\n      const { oldDeckName, newDeckName } = guessedAction;\r\n      await updateDeckName(oldDeckName, newDeckName, db);\r\n      return;\r\n    case GuessType.UpdateCardFront:\r\n    case GuessType.UpdateCardBack:\r\n    case GuessType.CreateCard:\r\n      await createOrUpdateCard(guessedAction, db);\r\n      return;\r\n    case GuessType.CopyPasteSingleDeck:\r\n    case GuessType.CreateDeck:\r\n      const { deckName } = guessedAction;\r\n      const deck = curr.create_decks.find((cd) => cd.name === deckName);\r\n      await createOrUpdateEntireDeck(deck, db);\r\n      return;\r\n    case GuessType.CopyPasteMultiDecks:\r\n      await createOrUpdateAllDecks(curr, db);\r\n      return;\r\n  }\r\n}\r\n","import Tokenizer from \"./tokenizer\";\r\nimport { deckCreationLiterals } from \"./constants\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\n\r\n// Local storage keys\r\nexport const astStrKey = \"programAST\";\r\nexport const cardEditorStrKey = \"cardEditorStrKey\";\r\n\r\n// Change here to\r\nconst defaultText = `Create Deck Practice Final:\r\n(1) Foo : Bar\r\n(2) Bill : Gates\r\n(3) Steve : Jobs\r\n(4) Justin : Trudeau \r\n(5) Evan : You\r\n`;\r\n\r\ntype InitialData = {\r\n  isFirstTimeUser: boolean;\r\n  initialText: string;\r\n  initialProgram: PROGRAM;\r\n};\r\n\r\n/**\r\n * @returns initial data for the card editor\r\n */\r\nexport function getInitialData(): InitialData {\r\n  const savedText = localStorage.getItem(cardEditorStrKey);\r\n  const lastAstJsonStr = localStorage.getItem(astStrKey);\r\n  if (savedText) {\r\n    return {\r\n      isFirstTimeUser: false,\r\n      initialText: savedText,\r\n      initialProgram: JSON.parse(lastAstJsonStr),\r\n    };\r\n  } else {\r\n    // Parse the example into an AST\r\n    Tokenizer.makeTokenizer(defaultText, deckCreationLiterals);\r\n    const program = new PROGRAM();\r\n    program.parse();\r\n    localStorage.setItem(cardEditorStrKey, defaultText);\r\n    localStorage.setItem(astStrKey, JSON.stringify(program));\r\n    return {\r\n      isFirstTimeUser: true,\r\n      initialText: defaultText,\r\n      initialProgram: program,\r\n    };\r\n  }\r\n}\r\n","import React, { useEffect, useState, useRef } from \"react\";\r\nimport \"codemirror/lib/codemirror.css\";\r\nimport \"codemirror/theme/ayu-mirage.css\";\r\nimport \"codemirror/mode/xml/xml\";\r\nimport { UnControlled as CodeMirror } from \"react-codemirror2\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\nimport Tokenizer from \"../lib/tokenizer\";\r\nimport { deckCreationLiterals } from \"../lib/constants\";\r\nimport { highlight } from \"../lib/highlighter\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\nimport reconcile from \"../lib/reconciler\";\r\nimport { debug, debugDB } from \"../lib/utils\";\r\nimport { astStrKey, cardEditorStrKey } from \"../lib/getIintialData\";\r\nimport { Action, ActionType } from \"../App\";\r\n\r\n// for syntax highlighting\r\nconst literals = [\"create deck\", \"(\", \":\", \")\"];\r\ntype Props = {\r\n  dispatch: React.Dispatch<Action>;\r\n  initialText: string;\r\n  isInSession: boolean;\r\n  program: PROGRAM;\r\n};\r\n\r\nexport default function CardEditor(props: Props) {\r\n  const db = useDatabase();\r\n\r\n  const { initialText, isInSession } = props;\r\n\r\n  const handleChange = (editor: CodeMirror.Editor, data, value) => {\r\n    highlight(editor, literals);\r\n\r\n    localStorage.setItem(cardEditorStrKey, value);\r\n    // Parse it\r\n    try {\r\n      Tokenizer.makeTokenizer(value, deckCreationLiterals);\r\n      const program = new PROGRAM();\r\n      program.parse();\r\n      // Check if the last deck in the program is null\r\n      if (\r\n        program.create_decks.length !== 0 &&\r\n        program.create_decks[program.create_decks.length - 1].deck === null\r\n      ) {\r\n        debug(\"last deck is null, not sending dispatch\");\r\n      } else {\r\n        localStorage.setItem(astStrKey, JSON.stringify(program));\r\n        // Trigger background reconciliation with DB\r\n        reconcile(props.program, program, db)\r\n          .then(() => debugDB(\"Background DB update complete!\"))\r\n          .catch((err) => debugDB(\"Error during reconciliation!\", err));\r\n        props.dispatch({ type: ActionType.CardEditorParseSuccess, program });\r\n      }\r\n    } catch (err) {\r\n      debug(err);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"card-editor\">\r\n        {isInSession ? (\r\n          <div className=\"card-editor-codemirror card-hider\">{initialText}</div>\r\n        ) : (\r\n          <CodeMirror\r\n            value={initialText}\r\n            options={{\r\n              mode: \"xml\",\r\n              theme: \"ayu-mirage\",\r\n              lineNumbers: true,\r\n            }}\r\n            editorDidMount={(editor, value) => {\r\n              highlight(editor, literals);\r\n              props.dispatch({\r\n                type: ActionType.SetCardEditor,\r\n                cardEditor: editor,\r\n              });\r\n            }}\r\n            onChange={handleChange}\r\n            className=\"card-editor-codemirror\"\r\n          />\r\n        )}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import NODE from \"./NODE\";\r\nimport TAGS from \"./TAGS\";\r\nimport DECKS from \"./DECKS\";\r\nimport SESSIONS from \"./SESSIONS\";\r\n\r\nexport enum SubjectType {\r\n  Decks = \"decks\",\r\n  Sessions = \"sessions\",\r\n  Tags = \"tags\", // not supported yet\r\n  Undefined = \"undefined\",\r\n}\r\n\r\nexport default class SUBJECT extends NODE {\r\n  subject: TAGS | DECKS | SESSIONS | null = null;\r\n  subjectType: SubjectType = SubjectType.Undefined;\r\n\r\n  parse() {\r\n    const nextToken = this.tokenizer.checkNext();\r\n    if (nextToken === \"past sessions\") {\r\n      this.subject = new SESSIONS();\r\n      this.subjectType = SubjectType.Sessions;\r\n    } else if (nextToken === \"decks:\") {\r\n      this.subject = new DECKS();\r\n      this.subjectType = SubjectType.Decks;\r\n    } else if (nextToken === \"tags:\") {\r\n      this.subject = new TAGS();\r\n      this.subjectType = SubjectType.Tags;\r\n    } else {\r\n      throw new Error(\r\n        \"Invalid Subject, must be 'Decks:', 'Tags:', or 'Past Sessions'\"\r\n      );\r\n    }\r\n    this.subject.parseInteractivePrompt();\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class DECKS extends NODE {\r\n  decks: string[] = [];\r\n  type = \"decks\";\r\n\r\n  parseInteractivePrompt() {\r\n    this.tokenizer.getAndCheckToken(\"decks:\");\r\n    while (this.tokenizer.moreTokens()) {\r\n      this.decks.push(this.tokenizer.getNext());\r\n      if (this.tokenizer.checkNext() === \",\") {\r\n        this.tokenizer.getNext();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class SESSIONS extends NODE {\r\n  type = \"sessions\";\r\n  parseInteractivePrompt() {\r\n    this.tokenizer.getAndCheckToken(\"past sessions\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport * as constants from \"../lib/constants\";\r\n\r\nexport default class SUBJECT_MODIFIER extends NODE {\r\n  type: string = \"\";\r\n  filter: string = \"newest\";\r\n  limit: number = 100;\r\n  selectCards: boolean = false;\r\n\r\n  parse() {\r\n    const actionToken = this.tokenizer.getNext();\r\n    if (actionToken === \"show stats for\") {\r\n      this.type = \"show stats\";\r\n    } else if (actionToken === \"start session from\") {\r\n      this.type = \"start session\";\r\n    } else {\r\n      throw new Error(\r\n        \"Command must either start with 'Show stats for' or 'Start Session from'\"\r\n      );\r\n    }\r\n    let nextToken = this.tokenizer.checkNext();\r\n    if (!isNaN(Number(nextToken))) {\r\n      this.limit = Math.round(Number(this.tokenizer.getNext()));\r\n      nextToken = this.tokenizer.checkNext();\r\n    }\r\n    if (constants.validCardFilter.includes(nextToken)) {\r\n      this.filter = this.tokenizer.getNext();\r\n      nextToken = this.tokenizer.checkNext();\r\n    }\r\n    if (nextToken === \"cards from\") {\r\n      this.selectCards = true;\r\n      this.tokenizer.getNext();\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\nimport SUBJECT from \"./SUBJECT\";\nimport SUBJECT_MODIFIER from \"./SUBJECT_MODIFIER\";\n\nexport default class COMPLEX_COMMAND extends NODE {\n  subjectModfier: SUBJECT_MODIFIER | null = null;\n  subject: SUBJECT | null = null;\n  parse() {\n    this.subjectModfier = new SUBJECT_MODIFIER();\n    this.subjectModfier.parse();\n\n    this.subject = new SUBJECT();\n    this.subject.parse();\n  }\n}\n","import NODE from \"./NODE\";\r\n\r\nexport default class HELP extends NODE {\r\n  type: string = \"\";\r\n  parse() {\r\n    this.type = \"help\";\r\n    this.tokenizer.getAndCheckToken(\"help\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class LIST extends NODE {\r\n  option: string = \"\";\r\n\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"list\");\r\n    this.option = this.tokenizer.getNext();\r\n    if (this.option !== \"tags\" && this.option !== \"decks\") {\r\n      throw new Error(\"Invalid list option\");\r\n    }\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class EXPORT_DECKS extends NODE {\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"export decks\");\r\n  }\r\n\r\n  evaluate() {\r\n    const dataString = localStorage.getItem(\"cardEditorStrKey\");\r\n    let fakeAnchor = document.createElement(\"a\");\r\n    fakeAnchor.href =\r\n      \"data:text/plain;charset=utf-8,\" + encodeURIComponent(dataString);\r\n    fakeAnchor.download = `${new Date().toISOString()}.txt`;\r\n    fakeAnchor.click();\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class LOAD_DECKS extends NODE {\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"load decks\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\n\r\nexport default class QUIT_TO_HOME extends NODE {\r\n  parse() {\r\n    this.tokenizer.getAndCheckToken(\"^quit$|^back to home$\");\r\n  }\r\n}\r\n","import NODE from \"./NODE\";\r\nimport COMPLEX_COMMAND from \"./COMPLEX_COMMAND\";\r\nimport HELP from \"./HELP\";\r\nimport LIST from \"./LIST\";\r\nimport EXPORT_DECKS from \"./EXPORT_DECKS\";\r\nimport LOAD_DECKS from \"./LOAD_DECKS\";\r\nimport QUIT_TO_HOME from \"./QUIT_TO_HOME\";\r\n\r\nexport default class COMMAND extends NODE {\r\n  type: string = \"\";\r\n  command:\r\n    | COMPLEX_COMMAND\r\n    | HELP\r\n    | LIST\r\n    | EXPORT_DECKS\r\n    | LOAD_DECKS\r\n    | QUIT_TO_HOME\r\n    | null = null;\r\n\r\n  parse() {\r\n    const nextToken = this.tokenizer.checkNext();\r\n    if (nextToken === \"help\") {\r\n      this.command = new HELP();\r\n      this.type = \"help\";\r\n    } else if (nextToken === \"list\") {\r\n      this.command = new LIST();\r\n      this.type = \"list\";\r\n    } else if (nextToken === \"export decks\") {\r\n      this.command = new EXPORT_DECKS();\r\n      this.type = \"export decks\";\r\n    } else if (nextToken === \"load decks\") {\r\n      this.command = new LOAD_DECKS();\r\n      this.type = \"load decks\";\r\n    } else if (nextToken === \"quit\" || nextToken === \"back to home\") {\r\n      this.command = new QUIT_TO_HOME();\r\n      this.type = \"quit to home\";\r\n    } else {\r\n      this.command = new COMPLEX_COMMAND();\r\n      this.type = \"complex command\";\r\n    }\r\n    if (this.command === null) {\r\n      throw new Error(\"Invalid command specified\");\r\n    }\r\n    this.command.parse();\r\n  }\r\n\r\n  evaluate() {\r\n    this.command.evaluate();\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { highlight } from \"../lib/highlighter\";\r\nimport \"codemirror/lib/codemirror.css\";\r\nimport \"codemirror/theme/yonce.css\";\r\nimport { UnControlled as CodeMirror } from \"react-codemirror2\";\r\nimport Tokenizer from \"../lib/tokenizer\";\r\nimport { allTokens as literals } from \"../lib/constants\";\r\nimport COMMAND from \"../ast/COMMAND\";\r\nimport COMPLEX_COMMAND from \"../ast/COMPLEX_COMMAND\";\r\nimport { Snackbar, IconButton } from \"@material-ui/core\";\r\nimport CloseIcon from \"@material-ui/icons/Close\";\r\nimport SUBJECT_MODIFIER from \"../ast/SUBJECT_MODIFIER\";\r\nimport DECKS from \"../ast/DECKS\";\r\nimport { Action, ActionType } from \"../App\";\r\nimport { SubjectType as Subject } from \"../ast/SUBJECT\";\r\nimport LIST from \"../ast/LIST\";\r\nimport { Filter } from \"../model/query\";\r\nimport TAGS from \"../ast/TAGS\";\r\n\r\nconst helpMsg = (\r\n  <div\r\n    style={{\r\n      fontSize: \"14px\",\r\n      lineHeight: \"9px\",\r\n    }}\r\n  >\r\n    <h4>To start a session from decks:</h4>\r\n    Start Session from [choose random card, ect ] from Decks: [choose 1 or\r\n    more deck names]\r\n    <h4>To start a session from tags:</h4>\r\n    Start Session from [choose random card, ect ] from Tags: [choose 1 or more\r\n    tag names]\r\n    <h4>To show stats:</h4> Show stats for [choose one or more best scores\r\n    for, average time spent on, worst scores for] Decks: [choose 1 or more\r\n    deck names]\r\n    <h4>To download your decks:</h4> Enter 'export decks'\r\n    <h4>To load decks from your computer:</h4> Enter 'load decks'\r\n    <h4>To go back to Home:</h4> Enter 'quit' or 'back to home'\r\n  </div>\r\n);\r\n\r\ntype Props = { dispatch: React.Dispatch<Action> };\r\n\r\nlet startSessionOrStats: string = \"\";\r\nfunction isStartSessionOrShowStats(command: COMMAND): boolean {\r\n  if (\r\n    ((command.command as COMPLEX_COMMAND).subjectModfier as SUBJECT_MODIFIER)\r\n      .type === \"start session\"\r\n  ) {\r\n    startSessionOrStats = \"start session\";\r\n    return true;\r\n  } else if (\r\n    ((command.command as COMPLEX_COMMAND).subjectModfier as SUBJECT_MODIFIER)\r\n      .type === \"show stats\"\r\n  ) {\r\n    startSessionOrStats = \"show stats\";\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default function CommandEditor(props: Props) {\r\n  const [openHelp, setOpenHelp] = React.useState(false);\r\n\r\n  const handleCloseHelp = (\r\n    event: React.SyntheticEvent | React.MouseEvent,\r\n    reason?: string\r\n  ) => {\r\n    if (reason === \"clickaway\") {\r\n      return;\r\n    }\r\n\r\n    setOpenHelp(false);\r\n  };\r\n\r\n  const handleCommandChange = (editor: CodeMirror.Editor, data, value) => {\r\n    highlight(editor, literals);\r\n    if (!value.startsWith(\"> \")) {\r\n      //reset the cursor if user tries to delete\r\n      editor.getDoc().setValue(\"> \");\r\n      editor.getDoc().setCursor(2);\r\n    }\r\n\r\n    if (value.includes(\"\\n\")) {\r\n      let isHelpCommand = false;\r\n      //after user hits enter, reset the cursor\r\n      // Parse the value\r\n      try {\r\n        Tokenizer.makeTokenizer(value, literals);\r\n        const command = new COMMAND();\r\n        command.parse(); //commands = COMPLEX_COMMAND | HELP | LIST\r\n        console.log(command.command);\r\n        if (command.type === \"list\") {\r\n          const listNode = command.command as LIST;\r\n          if (listNode.option === \"decks\") {\r\n            props.dispatch({ type: ActionType.List, listOption: \"decks\" });\r\n          } else if (listNode.option === \"tags\") {\r\n            props.dispatch({ type: ActionType.List, listOption: \"tags\" }); // not implemented\r\n          } else {\r\n            console.log(\"Unexpected list option: \", listNode.option);\r\n          }\r\n        } else if (command.type === \"help\") {\r\n          isHelpCommand = true;\r\n        } else if (command.type === \"export decks\") {\r\n          command.evaluate();\r\n        } else if (command.type === \"quit to home\") {\r\n          props.dispatch({ type: ActionType.QuitToHome });\r\n        } else if (command.type === \"load decks\") {\r\n          const fakeInput = document.createElement(\"input\");\r\n          fakeInput.type = \"file\";\r\n\r\n          fakeInput.onchange = (e: any) => {\r\n            const file = e.target.files[0];\r\n            const fileReader = new FileReader();\r\n            fileReader.readAsText(file, \"UTF-8\");\r\n\r\n            fileReader.onload = (e) => {\r\n              const deckCreationDSL = e.target.result as string;\r\n              props.dispatch({\r\n                type: ActionType.LoadDecks,\r\n                createDSLValue: deckCreationDSL,\r\n              });\r\n            };\r\n          };\r\n          fakeInput.click();\r\n        } else if (isStartSessionOrShowStats(command)) {\r\n          const modifier = (command.command as COMPLEX_COMMAND)\r\n            .subjectModfier as SUBJECT_MODIFIER;\r\n          if (modifier) {\r\n            const isTagsSubject =\r\n              (command.command as COMPLEX_COMMAND).subject.subjectType ===\r\n              \"tags\";\r\n            props.dispatch({\r\n              type:\r\n                startSessionOrStats === \"start session\"\r\n                  ? ActionType.StartSession\r\n                  : ActionType.ShowStats,\r\n              limit: modifier.limit,\r\n              filter: modifier.filter as Filter,\r\n              isLimitAppliedToCards: modifier.selectCards,\r\n              deckNames:\r\n                !isTagsSubject &&\r\n                ((command.command as COMPLEX_COMMAND).subject.subject as DECKS)\r\n                  .decks,\r\n              subject: (command.command as COMPLEX_COMMAND).subject.subjectType,\r\n              tagNames:\r\n                isTagsSubject &&\r\n                ((command.command as COMPLEX_COMMAND).subject\r\n                  .subject as TAGS).tags.map((t) => t.tagName),\r\n            });\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.log(err);\r\n        props.dispatch({\r\n          type: ActionType.CommandNotFound,\r\n        });\r\n      }\r\n      if (isHelpCommand) {\r\n        setOpenHelp(true);\r\n      }\r\n      editor.getDoc().setValue(\"> \");\r\n      editor.getDoc().setCursor(2);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"command-editor\">\r\n        <CodeMirror\r\n          value={\"> Show stats for cards from Decks: Practice Final\"}\r\n          options={{\r\n            mode: \"xml\",\r\n            theme: \"yonce\",\r\n            lineNumbers: true,\r\n          }}\r\n          editorDidMount={(editor, value) => {\r\n            highlight(editor, literals);\r\n          }}\r\n          onChange={handleCommandChange}\r\n        />\r\n      </div>\r\n      <Snackbar\r\n        anchorOrigin={{\r\n          vertical: \"bottom\",\r\n          horizontal: \"left\",\r\n        }}\r\n        open={openHelp}\r\n        autoHideDuration={180000}\r\n        onClose={handleCloseHelp}\r\n        message={helpMsg}\r\n        action={\r\n          <React.Fragment>\r\n            <IconButton\r\n              size=\"small\"\r\n              aria-label=\"close\"\r\n              color=\"inherit\"\r\n              onClick={handleCloseHelp}\r\n            >\r\n              <CloseIcon fontSize=\"small\" />\r\n            </IconButton>\r\n          </React.Fragment>\r\n        }\r\n      />\r\n    </>\r\n  );\r\n}\r\n","import React, { useState } from \"react\";\r\nimport { makeStyles, useTheme } from \"@material-ui/core/styles\";\r\nimport MobileStepper from \"@material-ui/core/MobileStepper\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport KeyboardArrowLeft from \"@material-ui/icons/KeyboardArrowLeft\";\r\nimport KeyboardArrowRight from \"@material-ui/icons/KeyboardArrowRight\";\r\nimport PostSessionSummary from \"./PostSessionSummary\";\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    width: \"100%\",\r\n  },\r\n});\r\n\r\nexport default function ProgressBar({\r\n  cards,\r\n  dispatch,\r\n  setNextCard,\r\n  addCardDataToLocalStorage,\r\n  currentCard,\r\n  currentResult,\r\n  setResult,\r\n}) {\r\n  const classes = useStyles();\r\n  const theme = useTheme();\r\n  const [activeStep, setActiveStep] = React.useState(0);\r\n\r\n  const handleNext = () => {\r\n    setActiveStep((prevActiveStep) => prevActiveStep + 1);\r\n    setNextCard(activeStep + 1);\r\n    if (activeStep == cards.length - 1) {\r\n      dispatch(true);\r\n    }\r\n    if (!currentResult) {\r\n      addCardDataToLocalStorage(currentCard, activeStep, undefined);\r\n    } else {\r\n      setResult(\"\");\r\n    }\r\n  };\r\n\r\n  const handleBack = () => {\r\n    setActiveStep((prevActiveStep) => prevActiveStep - 1);\r\n    setNextCard(activeStep - 1);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <MobileStepper\r\n        variant=\"text\"\r\n        steps={cards.length}\r\n        position=\"static\"\r\n        activeStep={activeStep}\r\n        className={classes.root}\r\n        nextButton={\r\n          <Button\r\n            size=\"small\"\r\n            onClick={handleNext}\r\n            disabled={activeStep === cards.length}\r\n          >\r\n            Next\r\n            {theme.direction === \"rtl\" ? (\r\n              <KeyboardArrowLeft />\r\n            ) : (\r\n              <KeyboardArrowRight />\r\n            )}\r\n          </Button>\r\n        }\r\n        backButton={\r\n          <Button size=\"small\" onClick={handleBack} disabled={activeStep === 0}>\r\n            {theme.direction === \"rtl\" ? (\r\n              <KeyboardArrowRight />\r\n            ) : (\r\n              <KeyboardArrowLeft />\r\n            )}\r\n            Back\r\n          </Button>\r\n        }\r\n      />\r\n      <MobileStepper\r\n        variant=\"progress\"\r\n        steps={cards.length}\r\n        position=\"static\"\r\n        activeStep={activeStep}\r\n        className={classes.root}\r\n        nextButton={null}\r\n        backButton={null}\r\n      />\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport Card from \"@material-ui/core/Card\";\r\nimport CardActions from \"@material-ui/core/CardActions\";\r\nimport CardContent from \"@material-ui/core/CardContent\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\n\r\nexport default function SingleCard(props) {\r\n  return (\r\n    <Card style={{ width: \"25em\", height: \"15em\" }}>\r\n      <CardContent style={{ paddingTop: \"6.5em\" }}>\r\n        <Typography color=\"textSecondary\" gutterBottom>\r\n          {props.content}\r\n        </Typography>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n","import ReactCardFlip from \"react-card-flip\";\r\nimport React, { useState } from \"react\";\r\nimport { Paper, makeStyles } from \"@material-ui/core\";\r\nimport SingleCard from \"./SingleCard\";\r\nimport { AutoComplete } from \"material-ui\";\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    marginTop: \"1em\",\r\n    textAlign: \"center\",\r\n    margin: \"0 auto\",\r\n    // paddingTop: \"3.5em\",\r\n  },\r\n});\r\n\r\nexport default function CardFlip({ front, back }) {\r\n  const [isFlipped, setIsFlipped] = useState(false);\r\n  const classes = useStyles();\r\n  const handleClick = (e) => {\r\n    e.preventDefault();\r\n    setIsFlipped((curState) => {\r\n      return !curState;\r\n    });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className={classes.root}>\r\n        <ReactCardFlip isFlipped={isFlipped} flipDirection=\"vertical\">\r\n          <div onClick={handleClick}>\r\n            <SingleCard content={front}></SingleCard>\r\n          </div>\r\n\r\n          <div onClick={handleClick}>\r\n            <SingleCard content={back} onClick={handleClick}></SingleCard>\r\n          </div>\r\n        </ReactCardFlip>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import { Database, Q } from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"./constants\";\r\nimport Session from \"./Session\";\r\nimport Deck from \"./Deck\";\r\nimport Card from \"./Card\";\r\nimport Tag from \"./Tag\";\r\nimport { shuffle } from \"../lib/utils\";\r\nimport SessionCard from \"./SessionCard\";\r\n\r\nexport enum Filter {\r\n  BEST = \"best\",\r\n  WORST = \"worst\",\r\n  RANDOM = \"random\",\r\n  OLDEST = \"oldest\",\r\n  NEWEST = \"newest\",\r\n}\r\n\r\nexport async function getAllDecks(db: Database): Promise<Array<Deck>> {\r\n  const decksCollection = db.collections.get(TableName.DECKS);\r\n  return (await decksCollection.query().fetch()) as Array<Deck>;\r\n}\r\n\r\nexport async function getSelectedDecks(\r\n  db: Database,\r\n  deckNames: Array<string>\r\n): Promise<Array<Deck>> {\r\n  const decksCollection = db.collections.get(TableName.DECKS);\r\n  return (await decksCollection\r\n    .query(Q.where(\"name\", Q.oneOf(deckNames)))\r\n    .fetch()) as Array<Deck>;\r\n}\r\n\r\nexport async function getDeckNameFromID(\r\n  db: Database,\r\n  id: number\r\n): Promise<string> {\r\n  // TODO: Add caching\r\n  const decksCollection = db.collections.get(TableName.DECKS);\r\n  const decks = (await decksCollection\r\n    .query(Q.where(\"id\", id))\r\n    .fetch()) as Array<Deck>;\r\n  if (decks.length < 1) {\r\n    throw new Error(`Unable to retrieve deck name for ID ${id}`);\r\n  }\r\n  return decks[0].name;\r\n}\r\n\r\nexport async function getUniqueDeckNamesFromSessions(\r\n  db: Database,\r\n  session: Session\r\n): Promise<Array<string>> {\r\n  let deckIds = [];\r\n  const cardsCollection = db.collections.get(TableName.CARDS);\r\n  const sessionCards: Array<SessionCard> = (await session.cards) as Array<\r\n    SessionCard\r\n  >;\r\n  for (let sessionCard of sessionCards) {\r\n    const foundDeckIds = {}; // set\r\n    let card = ((await cardsCollection\r\n      .query(Q.where(\"id\", sessionCard.card_id))\r\n      .fetch()) as Array<Card>)[0];\r\n    if (!foundDeckIds[card.deck_id]) {\r\n      foundDeckIds[card.deck_id] = true;\r\n      deckIds.push(card.deck_id);\r\n    }\r\n  }\r\n  let deckNames: Array<string> = [];\r\n  for (let deckId of deckIds) {\r\n    deckNames.push(await getDeckNameFromID(db, deckId));\r\n  }\r\n  return deckNames;\r\n}\r\n\r\nexport async function getCardsFromSelectedDecks(\r\n  db: Database,\r\n  deckNames: Array<string>\r\n): Promise<Array<Card>> {\r\n  let result = [];\r\n  const decks = await getSelectedDecks(db, deckNames);\r\n  for (let deckId of decks) {\r\n    result = result.concat(await deckId.cards.fetch());\r\n  }\r\n  return result;\r\n}\r\n\r\nexport async function getAllTags(db: Database): Promise<Array<Tag>> {\r\n  const tagsCollection = db.collections.get(TableName.TAGS);\r\n  return (await tagsCollection.query().fetch()) as Array<Tag>;\r\n}\r\n\r\nexport async function getSelectedTags(\r\n  db: Database,\r\n  tagNames: Array<string>\r\n): Promise<Array<Tag>> {\r\n  const tagsCollection = db.collections.get(TableName.TAGS);\r\n  return (await tagsCollection\r\n    .query(Q.where(\"name\", Q.oneOf(tagNames)))\r\n    .fetch()) as Array<Tag>;\r\n}\r\n\r\nexport async function getCardsFromSelectedTags(\r\n  db: Database,\r\n  tagNames: Array<string>\r\n): Promise<Array<Card>> {\r\n  let allCards: Array<Card> = [];\r\n  const cardIds = new Set();\r\n  const tags = await getSelectedTags(db, tagNames);\r\n\r\n  for (const tag of tags) {\r\n    const cards = await tag.cards;\r\n    allCards.concat(cards as Array<Card>);\r\n  }\r\n\r\n  return uniqueCards(allCards);\r\n}\r\n\r\nexport async function getAllSessions(db: Database): Promise<Array<Session>> {\r\n  const sessionsCollection = db.collections.get(TableName.SESSIONS);\r\n  return (await sessionsCollection.query().fetch()) as Array<Session>;\r\n}\r\n\r\nexport async function getPastSessions(\r\n  db: Database,\r\n  n: number = 5\r\n): Promise<Array<Session>> {\r\n  const allSessions = await getAllSessions(db);\r\n  return allSessions.sort((a, b) => b.started_at - a.started_at).slice(0, n);\r\n}\r\n\r\nexport async function getCardsFromSelectedSessions(\r\n  db: Database,\r\n  n: number = 5\r\n): Promise<Array<Card>> {\r\n  let allCards: Array<Card> = [];\r\n  const sessions = await getPastSessions(db, n);\r\n\r\n  for (const session of sessions) {\r\n    const cards = await session.cards;\r\n    allCards.concat(cards as Array<Card>);\r\n  }\r\n\r\n  return uniqueCards(allCards);\r\n}\r\n\r\nexport function cardFilter(\r\n  cards: Array<Card>,\r\n  filter: Filter,\r\n  n: number = 1\r\n): Array<Card> {\r\n  let result = [];\r\n\r\n  switch (filter) {\r\n    case Filter.BEST:\r\n      result = cards\r\n        .sort((a, b) => b.right - b.wrong - (a.right - a.wrong))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.WORST:\r\n      result = cards\r\n        .sort((a, b) => a.right - a.wrong - (b.right - b.wrong))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.NEWEST:\r\n      result = cards.sort((a, b) => a.created_at - b.created_at).slice(0, n);\r\n      break;\r\n    case Filter.OLDEST:\r\n      result = cards.sort((a, b) => b.created_at - a.created_at).slice(0, n);\r\n      break;\r\n    case Filter.RANDOM:\r\n      result = shuffle(cards).slice(0, n);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown CARD_MODIFIER: ${filter}`);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport async function deckFilter(\r\n  decks: Array<Deck>,\r\n  filter: Filter,\r\n  n: number = 1\r\n): Promise<Array<Deck>> {\r\n  let result = [];\r\n  let deckScoreMap = new Map();\r\n  for (let deck of decks) {\r\n    const cards = await deck.cards.fetch();\r\n    const score = calculateDeckScore(cards);\r\n    deckScoreMap.set(deck.id, score);\r\n  }\r\n\r\n  switch (filter) {\r\n    case Filter.BEST:\r\n      result = decks\r\n        .sort((a, b) => deckScoreMap.get(b.id) - deckScoreMap.get(a.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.WORST:\r\n      result = decks\r\n        .sort((a, b) => deckScoreMap.get(a.id) - deckScoreMap.get(b.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.NEWEST:\r\n      result = decks.sort((a, b) => a.created_at - b.created_at).slice(0, n);\r\n      break;\r\n    case Filter.OLDEST:\r\n      result = decks.sort((a, b) => b.created_at - a.created_at).slice(0, n);\r\n      break;\r\n    case Filter.RANDOM:\r\n      result = shuffle(decks).slice(0, n);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown CARD_MODIFIER: ${filter}`);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport async function sessionFilter(\r\n  db: Database,\r\n  sessions: Array<Session>,\r\n  filter: Filter,\r\n  n: number = 1\r\n): Promise<Array<Session>> {\r\n  let result = [];\r\n  let sessionsScoreMap = new Map();\r\n\r\n  for (const session of sessions) {\r\n    const score = await getSessionScore(db, session);\r\n    sessionsScoreMap.set(session.id, score);\r\n  }\r\n\r\n  switch (filter) {\r\n    case Filter.BEST:\r\n      result.sort(\r\n        (a, b) =>\r\n          sessionsScoreMap.get(b.id) - sessionsScoreMap.get(a.id).slice(0, n)\r\n      );\r\n      break;\r\n    case Filter.WORST:\r\n      result\r\n        .sort((a, b) => sessionsScoreMap.get(a.id) - sessionsScoreMap.get(b.id))\r\n        .slice(0, n);\r\n      break;\r\n    case Filter.NEWEST:\r\n      result = sessions.sort((a, b) => a.started_at - b.started_at).slice(0, n);\r\n      break;\r\n    case Filter.OLDEST:\r\n      result = sessions.sort((a, b) => b.started_at - a.started_at).slice(0, n);\r\n      break;\r\n    case Filter.RANDOM:\r\n      result = shuffle(sessions).slice(0, n);\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown CARD_MODIFIER: ${filter}`);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function calculateDeckScore(cards: Array<Card>): number {\r\n  let rightCount = 0;\r\n  let wrongCount = 0;\r\n  cards.forEach((card) => {\r\n    rightCount += card.right;\r\n    wrongCount += card.wrong;\r\n  });\r\n  return rightCount / (rightCount + wrongCount);\r\n}\r\n\r\nexport async function getSessionScore(\r\n  db: Database,\r\n  session: Session\r\n): Promise<number> {\r\n  const sessionCardsCollection = db.collections.get(TableName.SESSIONS_CARDS);\r\n  const sessionCards = (await sessionCardsCollection\r\n    .query(Q.where(\"session_id\", session.id))\r\n    .fetch()) as Array<SessionCard>;\r\n  const totalCards = sessionCards.length;\r\n  return sessionCards.map((sc) => sc.is_correct).length / totalCards;\r\n}\r\n\r\nexport function uniqueCards(cards: Array<Card>): Array<Card> {\r\n  let result = [];\r\n  const cardIds = new Set();\r\n  for (const card of cards) {\r\n    if (!cardIds.has(card.id)) {\r\n      result.push(card);\r\n      cardIds.add(card.id);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n","import PROGRAM from \"../ast/PROGRAM\";\r\nimport { ComplexCommandParams } from \"../App\";\r\nimport {\r\n  Filter,\r\n  getSelectedDecks,\r\n  deckFilter,\r\n  getPastSessions,\r\n  getAllSessions,\r\n  sessionFilter,\r\n  getCardsFromSelectedSessions,\r\n  uniqueCards,\r\n  cardFilter,\r\n} from \"../model/query\";\r\nimport { Database, Collection } from \"@nozbe/watermelondb\";\r\nimport {\r\n  SessionMaterials,\r\n  FlashCard,\r\n  SessionMaterialsWithTags,\r\n  FlashCardWithTags,\r\n} from \"../components/Session\";\r\nimport { randomize, shuffle } from \"./utils\";\r\nimport FILTER from \"../ast/FILTER\";\r\nimport CREATE_DECK from \"../ast/CREATE_DECK\";\r\nimport CARD from \"../ast/CARD\";\r\nimport { TableName } from \"../model/constants\";\r\nimport Session from \"../model/Session\";\r\nimport Card from \"../model/Card\";\r\nimport Deck from \"../model/Deck\";\r\nimport { Q } from \"@nozbe/watermelondb\";\r\n\r\ntype SessionCommandError = {\r\n  message: string;\r\n};\r\n\r\nconst deckSelectionErrorMessage =\r\n  \"Please select one or more of the decks on the card editor\";\r\n\r\nconst tagSelectionErrorMessage =\r\n  \"Please select one or more of the tags on the card editor\";\r\n\r\n/**\r\n * Checks whether the user's complex command makes sense (currently checks the deck names), add more logic here\r\n *\r\n * @returns either false if there's no error, or an error message\r\n */\r\nexport function checkSessionCommandError(\r\n  program: PROGRAM,\r\n  complexCommandParams: ComplexCommandParams\r\n): SessionCommandError | false {\r\n  const {\r\n    subject,\r\n    deckNames: requestedDeckNames,\r\n    tagNames,\r\n  } = complexCommandParams;\r\n\r\n  if (subject === \"decks\") {\r\n    if (!requestedDeckNames) {\r\n      return {\r\n        message: deckSelectionErrorMessage,\r\n      };\r\n    }\r\n    const activeDeckNames = program.create_decks.map((cd) => cd.name);\r\n    const matchedDeckNames = new Set<string>();\r\n    requestedDeckNames.forEach((name) => {\r\n      if (\r\n        activeDeckNames.findIndex(\r\n          (deckName) => name.toLowerCase() === deckName.toLowerCase()\r\n        ) !== -1\r\n      ) {\r\n        matchedDeckNames.add(name);\r\n      }\r\n    });\r\n    if (matchedDeckNames.size === 0) {\r\n      return {\r\n        message: deckSelectionErrorMessage,\r\n      };\r\n    }\r\n  } else if (subject === \"tags\") {\r\n    if (tagNames.length === 0) {\r\n      return {\r\n        message: tagSelectionErrorMessage,\r\n      };\r\n    }\r\n    let possibleTags = [];\r\n    program.create_decks.forEach((cd) => {\r\n      cd.tags && cd.tags.tags.forEach((t) => possibleTags.push(t.tagName));\r\n    });\r\n    let giveError = false;\r\n    tagNames.forEach((t) => {\r\n      if (!possibleTags.includes(t)) {\r\n        giveError = true;\r\n      }\r\n    });\r\n    if (giveError) {\r\n      return {\r\n        message: tagSelectionErrorMessage,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Add more checks here as we add features, for instance, of tags\r\n  return false;\r\n}\r\n\r\n/*\r\n * Returns a list of case sensitive deck names matching the requested deck names, removing duplicates\r\n */\r\n\r\nfunction getValidDeckNames(\r\n  program: PROGRAM,\r\n  requestedDeckNames: string[]\r\n): string[] {\r\n  const validDeckNames = {}; // mapping of actual (case sensitive) deck name -> boolean (i.e. a set of case sensitive deck names)\r\n  const deckNamesInProgram = {}; // mapping of lower case name -> case sensitive name\r\n  program.create_decks.forEach((cd) => {\r\n    if (cd.deck?.cards?.length > 0) {\r\n      deckNamesInProgram[cd.name.toLowerCase()] = cd.name;\r\n    }\r\n  });\r\n  requestedDeckNames.forEach((dn) => {\r\n    const actualDeckName = deckNamesInProgram[dn.toLowerCase()];\r\n    if (actualDeckName) {\r\n      validDeckNames[actualDeckName] = true;\r\n    }\r\n  });\r\n  return Object.keys(validDeckNames);\r\n}\r\n\r\nfunction getCardsFromSelectedDecks(selectedCreateDecks: CREATE_DECK[]) {\r\n  let selectedCards: FlashCard[] = [];\r\n  for (const cd of selectedCreateDecks) {\r\n    const deckName = cd.name;\r\n    for (const card of cd.deck.cards) {\r\n      const cardWithDeck = { front: card.front, back: card.back, deckName };\r\n      selectedCards.push(cardWithDeck);\r\n    }\r\n  }\r\n  return selectedCards;\r\n}\r\n\r\nasync function getCardsFromDecksNoFilter(\r\n  deckNames: string[],\r\n  selectedCreateDecks: CREATE_DECK[],\r\n  limit: number,\r\n  isLimitAppliedToCards?: boolean\r\n): Promise<SessionMaterials> {\r\n  if (!isLimitAppliedToCards) {\r\n    randomize(selectedCreateDecks);\r\n    if (limit < selectedCreateDecks.length) {\r\n      selectedCreateDecks.splice(limit);\r\n    }\r\n  }\r\n\r\n  let selectedCards = getCardsFromSelectedDecks(selectedCreateDecks);\r\n\r\n  selectedCards = randomize(selectedCards);\r\n  if (isLimitAppliedToCards) {\r\n    randomize(selectedCards);\r\n    if (limit < selectedCards.length) {\r\n      selectedCards.splice(limit);\r\n    }\r\n  }\r\n  return {\r\n    deckNames: deckNames,\r\n    cards: selectedCards,\r\n  };\r\n}\r\n\r\ntype CardWithStats = {\r\n  front: string;\r\n  back: string;\r\n  deckName: string;\r\n  right: number;\r\n  wrong: number;\r\n  createdAt: number; // UNIX timestamp\r\n};\r\n\r\nasync function getCardStatsFromDB(\r\n  db: Database,\r\n  deckNames: string[],\r\n  selectedCards: FlashCard[]\r\n): Promise<CardWithStats[]> {\r\n  const selectedCardsSet = {}; // selectedCards.deckName:front:back -> bool\r\n  selectedCards.forEach(({ deckName, front, back }) => {\r\n    selectedCardsSet[`${deckName}:${front}:${back}`] = true;\r\n  });\r\n\r\n  const cardsWithStats: CardWithStats[] = [];\r\n\r\n  const decks = await getSelectedDecks(db, deckNames);\r\n  for (const deck of decks) {\r\n    const cardsFromDB = await deck.cards.fetch();\r\n    cardsFromDB.forEach(\r\n      ({ front, back, right, wrong, created_at: createdAt }) => {\r\n        if (selectedCardsSet[`${deck.name}:${front}:${back}`]) {\r\n          // take its stats\r\n          cardsWithStats.push({\r\n            deckName: deck.name,\r\n            front,\r\n            back,\r\n            right,\r\n            wrong,\r\n            createdAt,\r\n          });\r\n        }\r\n      }\r\n    );\r\n  }\r\n  return cardsWithStats;\r\n}\r\n\r\nasync function getCardsFromDecksWithFilter(\r\n  db: Database,\r\n  validDeckNames: string[],\r\n  selectedCreateDecks: CREATE_DECK[],\r\n  filter: Filter,\r\n  limit: number,\r\n  isLimitAppliedToCards?: boolean\r\n): Promise<SessionMaterials> {\r\n  // if limit is not less than what's available in selectedCreateDecks, directly return it without DB trip\r\n  let selectedCards = getCardsFromSelectedDecks(selectedCreateDecks);\r\n  randomize(selectedCards);\r\n  if (!isLimitAppliedToCards) {\r\n    if (limit >= selectedCreateDecks.length) {\r\n      return {\r\n        deckNames: validDeckNames,\r\n        cards: selectedCards,\r\n      };\r\n    }\r\n  } else {\r\n    if (limit >= selectedCards.length) {\r\n      return {\r\n        deckNames: validDeckNames,\r\n        cards: selectedCards,\r\n      };\r\n    }\r\n  }\r\n  //if  limit is less than what's available\r\n  if (isLimitAppliedToCards) {\r\n    const cardsWithStats = await getCardStatsFromDB(\r\n      db,\r\n      validDeckNames,\r\n      selectedCards\r\n    );\r\n    switch (filter) {\r\n      case Filter.BEST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return -(card1.right - card1.wrong - (card2.right - card2.wrong));\r\n        });\r\n      }\r\n      case Filter.WORST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return card1.right - card1.wrong - (card2.right - card2.wrong);\r\n        });\r\n      }\r\n      case Filter.OLDEST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return card1.createdAt - card2.createdAt;\r\n        });\r\n      }\r\n      case Filter.NEWEST: {\r\n        cardsWithStats.sort((card1, card2) => {\r\n          return -(card1.createdAt - card2.createdAt);\r\n        });\r\n      }\r\n    }\r\n    cardsWithStats.splice(limit);\r\n    randomize(cardsWithStats);\r\n    return {\r\n      deckNames: validDeckNames,\r\n      cards: cardsWithStats,\r\n    };\r\n  } else {\r\n    // e.g. best 5 decks\r\n    const decksFromDB = await getSelectedDecks(db, validDeckNames);\r\n    const filteredDecks = await deckFilter(decksFromDB, filter, limit);\r\n    const filteredDecksSet = {}; // deckName -> boolean\r\n    filteredDecks.forEach((deck) => {\r\n      filteredDecksSet[deck.name] = true;\r\n    });\r\n    const filteredCreateDecks = selectedCreateDecks.filter(\r\n      (cd) => filteredDecksSet[cd.name]\r\n    );\r\n    const cards = getCardsFromSelectedDecks(filteredCreateDecks);\r\n    randomize(cards);\r\n    return {\r\n      deckNames: validDeckNames,\r\n      cards: cards,\r\n    };\r\n  }\r\n}\r\n\r\nasync function getCardsFromDecks(\r\n  db: Database,\r\n  program: PROGRAM,\r\n  requestedDeckNames: string[],\r\n  filter?: Filter,\r\n  isLimitAppliedToCards?: boolean,\r\n  limit: number = 5\r\n): Promise<SessionMaterials> {\r\n  const validDeckNames = getValidDeckNames(program, requestedDeckNames);\r\n  const selectedCreateDecks = program.create_decks.filter((cd) => {\r\n    return validDeckNames.includes(cd.name);\r\n  });\r\n\r\n  if (!filter || filter === Filter.RANDOM) {\r\n    return getCardsFromDecksNoFilter(\r\n      validDeckNames,\r\n      selectedCreateDecks,\r\n      limit,\r\n      isLimitAppliedToCards\r\n    );\r\n  } else {\r\n    return await getCardsFromDecksWithFilter(\r\n      db,\r\n      validDeckNames,\r\n      selectedCreateDecks,\r\n      filter,\r\n      limit,\r\n      isLimitAppliedToCards\r\n    );\r\n  }\r\n}\r\n\r\nasync function getCardsFromTags(\r\n  db: Database,\r\n  program: PROGRAM,\r\n  tagNames: string[],\r\n  filter?: Filter,\r\n  isLimitAppliedToCards?: boolean,\r\n  limit?: number\r\n): Promise<SessionMaterials> {\r\n  const selectedCreateDecks = program.create_decks.filter((cd) => {\r\n    const createDeckTags = cd.tags && cd.tags.tags.map((t) => t.tagName);\r\n    let hasASelectedTag = false;\r\n    if (createDeckTags) {\r\n      createDeckTags.forEach((t) => {\r\n        if (tagNames.includes(t)) {\r\n          hasASelectedTag = true;\r\n        }\r\n      });\r\n    }\r\n    return hasASelectedTag;\r\n  });\r\n  // TODO implement filtering for tags\r\n  const deckNames = selectedCreateDecks.map((cd) => cd.name);\r\n  return await getCardsFromDecksNoFilter(\r\n    deckNames,\r\n    selectedCreateDecks,\r\n    limit,\r\n    isLimitAppliedToCards\r\n  );\r\n}\r\n\r\nasync function getCardsFromSessions(\r\n  db: Database,\r\n  filter?: Filter,\r\n  isLimitAppliedToCards?: boolean,\r\n  limit: number = 5\r\n): Promise<SessionMaterials> {\r\n  let sessions: Session[];\r\n\r\n  if (isLimitAppliedToCards) {\r\n    sessions = await getAllSessions(db);\r\n  } else {\r\n    if (filter) {\r\n      sessions = await getAllSessions(db);\r\n      sessions = await sessionFilter(db, sessions, filter, limit);\r\n    } else {\r\n      sessions = await getPastSessions(db, limit);\r\n    }\r\n  }\r\n\r\n  let cards: Array<Card> = [];\r\n  for (const session of sessions) {\r\n    const cards = await session.cards;\r\n    cards.concat(cards as Array<Card>);\r\n  }\r\n\r\n  cards = uniqueCards(cards);\r\n\r\n  if (isLimitAppliedToCards && cards.length > limit) {\r\n    if (filter) {\r\n      cards = cardFilter(cards, filter, limit);\r\n    } else {\r\n      cards = shuffle(cards).splice(limit);\r\n    }\r\n  }\r\n\r\n  shuffle(cards);\r\n\r\n  const decks: Collection<Deck> = db.collections.get(TableName.DECKS);\r\n  const deckIdToDeckName = {}; // deck id -> deck name\r\n  const flashCards: FlashCard[] = [];\r\n  for (const card of cards) {\r\n    if (!deckIdToDeckName[card.deck_id]) {\r\n      deckIdToDeckName[card.deck_id] = (\r\n        await decks.query(Q.where(\"id\", Q.eq(card.deck_id))).fetch()\r\n      )[0].name;\r\n    }\r\n    const deckName = deckIdToDeckName[card.deck_id];\r\n    flashCards.push({\r\n      deckName,\r\n      front: card.front,\r\n      back: card.back,\r\n    });\r\n  }\r\n\r\n  return { cards: flashCards };\r\n}\r\n\r\nfunction addTagsToFlashCard(program: PROGRAM, card: FlashCard) {\r\n  const cd: CREATE_DECK = program.create_decks.find(\r\n    (cd) => cd.name === card.deckName\r\n  );\r\n  card.tags = cd.tags && cd.tags.tags.map((t) => t && t.tagName);\r\n}\r\n\r\nexport async function getSessionMaterialsWithTags(\r\n  program: PROGRAM,\r\n  complexCommandParams: ComplexCommandParams,\r\n  db: Database\r\n): Promise<SessionMaterialsWithTags> {\r\n  const sessionMaterials = await getSessionMaterials(\r\n    program,\r\n    complexCommandParams,\r\n    db\r\n  );\r\n  sessionMaterials.cards.forEach((flashCard) => {\r\n    return addTagsToFlashCard(program, flashCard);\r\n  });\r\n\r\n  return sessionMaterials as SessionMaterialsWithTags;\r\n}\r\n\r\n/**\r\n * Returns the cards chosen by the user for their \"Start session\" command (in a promise)\r\n *\r\n * @returns a list of cards with front, back and deckName, maybe requiring an asynchronous stats fetch from the DB first\r\n */\r\nexport async function getSessionMaterials(\r\n  program: PROGRAM,\r\n  complexCommandParams: ComplexCommandParams,\r\n  db: Database\r\n): Promise<SessionMaterials> {\r\n  const {\r\n    subject,\r\n    filter,\r\n    isLimitAppliedToCards,\r\n    limit,\r\n    deckNames: requestedDeckNames,\r\n    tagNames,\r\n  } = complexCommandParams;\r\n\r\n  if (subject === \"decks\") {\r\n    return await getCardsFromDecks(\r\n      db,\r\n      program,\r\n      requestedDeckNames,\r\n      filter,\r\n      isLimitAppliedToCards,\r\n      limit\r\n    );\r\n  } else if (subject === \"tags\") {\r\n    return await getCardsFromTags(\r\n      db,\r\n      program,\r\n      tagNames,\r\n      filter,\r\n      isLimitAppliedToCards,\r\n      limit\r\n    );\r\n  } else if (subject === \"sessions\") {\r\n    return await getCardsFromSessions(db, filter, isLimitAppliedToCards, limit);\r\n  } else {\r\n    throw new Error(\"Not supported!\");\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport Snackbar, { SnackbarOrigin } from \"@material-ui/core/Snackbar\";\r\nimport MuiAlert, { AlertProps } from \"@material-ui/lab/Alert\";\r\nimport { makeStyles, Theme } from \"@material-ui/core/styles\";\r\n\r\nfunction Alert(props: AlertProps) {\r\n  return <MuiAlert elevation={6} variant=\"filled\" {...props} />;\r\n}\r\nexport interface State extends SnackbarOrigin {\r\n  open: boolean;\r\n}\r\n\r\nconst useStyles = makeStyles((theme: Theme) => ({\r\n  root: {\r\n    width: \"100%\",\r\n    \"& > * + *\": {\r\n      marginTop: theme.spacing(2),\r\n    },\r\n  },\r\n}));\r\n\r\nexport default function ErrorMessage({ message }) {\r\n  const classes = useStyles();\r\n  const [state, setState] = React.useState<State>({\r\n    open: true,\r\n    vertical: \"top\",\r\n    horizontal: \"center\",\r\n  });\r\n  const { vertical, horizontal, open } = state;\r\n  const handleClose = () => {\r\n    setState({ ...state, open: false });\r\n  };\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <Snackbar\r\n        anchorOrigin={{ vertical, horizontal }}\r\n        open={open}\r\n        onClose={handleClose}\r\n      >\r\n        <Alert onClose={handleClose} severity=\"error\">\r\n          {message}\r\n        </Alert>\r\n      </Snackbar>\r\n    </div>\r\n  );\r\n}\r\n","import React, { useState, useReducer, useEffect } from \"react\";\r\nimport ProgressBar from \"./ProgressBar\";\r\nimport CardFlip from \"./CardFlip\";\r\nimport WrongBtn from \"../assets/wrongBtn.svg\";\r\nimport CorrectBtn from \"../assets/correctBtn.svg\";\r\nimport Timer from \"react-compound-timer\";\r\nimport PostSessionSummary from \"./PostSessionSummary\";\r\nimport { Action, ActionType, ComplexCommandParams } from \"../App\";\r\nimport { SubjectType as Subject } from \"../ast/SUBJECT\";\r\nimport {\r\n  checkSessionCommandError,\r\n  getSessionMaterialsWithTags,\r\n} from \"../lib/sessionHelperFunctions\";\r\nimport PROGRAM from \"../ast/PROGRAM\";\r\nimport { CircularProgress } from \"@material-ui/core\";\r\nimport ErrorMessage from \"./ErrorMessage\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\nimport { Database, Collection } from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"../model/constants\";\r\nimport SessionModel from \"../model/Session\";\r\nimport CardModel from \"../model/Card\";\r\nimport DeckModel from \"../model/Deck\";\r\nimport { Q } from \"@nozbe/watermelondb\";\r\nimport SessionCard from \"../model/SessionCard\";\r\nimport { debug } from \"../lib/utils\";\r\n\r\ntype Props = {\r\n  complexCommandParams: ComplexCommandParams;\r\n  program: PROGRAM;\r\n  dispatch: React.Dispatch<Action>;\r\n};\r\n\r\nexport type FlashCard = {\r\n  front: string;\r\n  back: string;\r\n  deckName: string;\r\n  tags?: string[];\r\n};\r\n\r\nexport type FlashCardWithTags = {\r\n  front: string;\r\n  back: string;\r\n  deckName: string;\r\n  tags: string[];\r\n};\r\n\r\n/**\r\n * A list of cards, and optionally, a list of deck names\r\n */\r\nexport type SessionMaterials = {\r\n  deckNames?: string[];\r\n  cards: FlashCard[];\r\n};\r\n\r\nexport type SessionMaterialsWithTags = {\r\n  deckNames?: string[];\r\n  cards: FlashCardWithTags[];\r\n};\r\n\r\nfunction addCardDataToLocalStorage(\r\n  card: any,\r\n  nextCardIndex: number,\r\n  gotCorrect: boolean\r\n) {\r\n  const sessionData = localStorage.getItem(\"sessionData\");\r\n  let cardDataArray;\r\n  let sessionDataObject;\r\n  let newSessionDataObject;\r\n  if (sessionData) {\r\n    sessionDataObject = JSON.parse(sessionData);\r\n    cardDataArray = sessionDataObject[\"cardDataArray\"];\r\n    if (!cardDataArray) cardDataArray = [];\r\n    const currentCardID = `${card.deckName}_${card.front}_${card.back}`;\r\n    const cardData = {\r\n      card_id: currentCardID,\r\n      front: card.front,\r\n      back: card.back,\r\n      is_correct: gotCorrect,\r\n      card_index: nextCardIndex,\r\n      deck: card.deckName,\r\n      tags: card.tags,\r\n    };\r\n    const alreadyAdded = cardDataArray.filter(\r\n      (o) => o.card_id === currentCardID\r\n    )[0];\r\n    const alreadyAddedIndex = cardDataArray.indexOf(alreadyAdded);\r\n    if (alreadyAdded) {\r\n      cardDataArray[alreadyAddedIndex] = cardData;\r\n    } else {\r\n      cardDataArray.push(cardData);\r\n    }\r\n    newSessionDataObject = {\r\n      ...sessionDataObject,\r\n      cardDataArray: cardDataArray,\r\n    };\r\n    localStorage.setItem(\"sessionData\", JSON.stringify(newSessionDataObject));\r\n  }\r\n}\r\n\r\ntype SessionDataType = {\r\n  created_at: string;\r\n  sessionId: string;\r\n  cardDataArray: LocalCardFromSession[];\r\n  ended_at: string;\r\n};\r\n\r\ntype LocalCardFromSession = {\r\n  card_id: string;\r\n  deck: string;\r\n  front: string;\r\n  back: string;\r\n  is_correct?: boolean;\r\n};\r\nasync function saveSessionDataToDB(\r\n  data: SessionDataType,\r\n  db: Database\r\n): Promise<void> {\r\n  const sessionsTable: Collection<SessionModel> = db.collections.get(\r\n    TableName.SESSIONS\r\n  );\r\n\r\n  const cardTable: Collection<CardModel> = db.collections.get(TableName.CARDS);\r\n  const deckTable: Collection<DeckModel> = db.collections.get(TableName.DECKS);\r\n  const sessionCardTable: Collection<SessionCard> = db.collections.get(\r\n    TableName.SESSIONS_CARDS\r\n  );\r\n\r\n  //any db modification needs to be wrapped in action\r\n  await db.action(async () => {\r\n    //get cards in session from db\r\n    const deckNameToDeckModel = {}; // deck name -> deck Model\r\n    //put new session in db\r\n    const createdSession = await sessionsTable.create((session) => {\r\n      session.started_at = new Date(data.created_at);\r\n      session.ended_at = new Date(data.ended_at);\r\n    });\r\n    for (const c of data.cardDataArray) {\r\n      if (c.is_correct === true || c.is_correct === false) {\r\n        // if card was not skipped\r\n        //save deckId from deckname in session, used to find the cards\r\n        if (!deckNameToDeckModel[c.deck]) {\r\n          deckNameToDeckModel[c.deck] = (\r\n            await deckTable.query(Q.where(\"name\", Q.eq(c.deck))).fetch()\r\n          )[0];\r\n        }\r\n        const deckId = deckNameToDeckModel[c.deck].id;\r\n        //find card in db which matches session card\r\n        const matchedCards = await cardTable\r\n          .query(\r\n            Q.where(\"deck_id\", Q.eq(deckId)),\r\n            Q.where(\"front\", Q.eq(c.front)),\r\n            Q.where(\"back\", Q.eq(c.back))\r\n          )\r\n          .fetch();\r\n        //get matched cards from db\r\n        let cardModel: CardModel;\r\n        if (matchedCards.length === 0) {\r\n          //if cards were not saved properly, save it to cards\r\n          const deckModel: DeckModel = deckNameToDeckModel[c.deck];\r\n          //use subaction to run an action inside an action\r\n          await deckModel.subAction(async () => {\r\n            cardModel = (await deckModel.addCard(c.front, c.back)) as CardModel;\r\n          });\r\n        } else {\r\n          //if card is found in db, save in cardModel (should be a single card)\r\n          cardModel = matchedCards[0];\r\n        }\r\n        //update the card with its stat obtained from session\r\n        await cardModel.update((cm) => {\r\n          if (c.is_correct) {\r\n            cm.right++;\r\n          } else {\r\n            cm.wrong++;\r\n          }\r\n          cm.last_tested_at = new Date(data.ended_at);\r\n        });\r\n\r\n        //add card to join table of cards and sessions\r\n        await sessionCardTable.create((sessionCard) => {\r\n          sessionCard.card_id = cardModel.id;\r\n          sessionCard.session_id = createdSession.id;\r\n          sessionCard.is_correct = c.is_correct;\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction addEndTimeToSessionDataInLocalStorage(db: Database) {\r\n  const sessionData = localStorage.getItem(\"sessionData\");\r\n  let endedAt;\r\n  let currentSessionData;\r\n  if (sessionData) {\r\n    currentSessionData = JSON.parse(sessionData);\r\n    endedAt = currentSessionData[\"ended_at\"];\r\n  }\r\n  if (currentSessionData && !endedAt) {\r\n    const data = { ...currentSessionData, ended_at: new Date().toString() };\r\n    saveSessionDataToDB(data, db);\r\n    const dataString = JSON.stringify(data);\r\n    localStorage.setItem(\"sessionData\", dataString);\r\n  }\r\n}\r\n\r\nexport default function Session(props: Props) {\r\n  const db = useDatabase();\r\n  const [result, setResult] = useState(\"\");\r\n  const [isDone, setIsDone] = useState(false);\r\n  const [nextCardIndex, setNextCardIndex] = useState(0);\r\n  const [sessionMaterials, setSessionMaterials] = useState<SessionMaterials>(\r\n    null\r\n  );\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<Error>(null);\r\n\r\n  useEffect(() => {\r\n    const sessionCommandErr = checkSessionCommandError(\r\n      props.program,\r\n      props.complexCommandParams\r\n    );\r\n    if (sessionCommandErr) {\r\n      setError(new Error(sessionCommandErr.message));\r\n      return;\r\n    }\r\n\r\n    const _getSessionMaterials = async () => {\r\n      try {\r\n        const sessionMaterials = await getSessionMaterialsWithTags(\r\n          props.program,\r\n          props.complexCommandParams,\r\n          db\r\n        );\r\n        debug(sessionMaterials);\r\n        const nowString = new Date().toString();\r\n        const initialData = { created_at: nowString, session_id: nowString }; // redundant :/\r\n        const initialDataString = JSON.stringify(initialData);\r\n        localStorage.setItem(\"sessionData\", initialDataString);\r\n\r\n        setSessionMaterials(sessionMaterials);\r\n        setIsLoading(false);\r\n        setError(null);\r\n      } catch (err) {\r\n        debug(err);\r\n        setError(err);\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    _getSessionMaterials();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (isDone) {\r\n      addEndTimeToSessionDataInLocalStorage(db);\r\n      props.dispatch({ type: ActionType.PostSession });\r\n    }\r\n  }, [isDone]);\r\n\r\n  const showDecksOrPastSessionsHeader = () => {\r\n    if (\r\n      props.complexCommandParams.subject === Subject.Decks ||\r\n      props.complexCommandParams.subject === Subject.Tags\r\n    ) {\r\n      return (\r\n        <>\r\n          <h3 className=\"decks\">DECKS: </h3>\r\n          <br></br>\r\n          <p className=\"deckNames\">\r\n            {sessionMaterials.deckNames.map((deckname) => {\r\n              if (\r\n                deckname ===\r\n                sessionMaterials.deckNames[\r\n                  sessionMaterials.deckNames.length - 1\r\n                ]\r\n              ) {\r\n                return <span key={deckname}>{deckname} </span>;\r\n              }\r\n              return <span key={deckname}>{deckname}, </span>;\r\n            })}\r\n          </p>\r\n        </>\r\n      );\r\n    } else if (props.complexCommandParams.subject === Subject.Sessions) {\r\n      let numPastSessionsString = props.complexCommandParams.limit?.toString();\r\n      if (!numPastSessionsString) {\r\n        numPastSessionsString = \"5\"; // TODO use a global constant for default number\r\n      }\r\n      return (\r\n        <>\r\n          <h3 className=\"decks\">Past Sessions</h3>\r\n          <br></br>\r\n          <p className=\"deckNames\">{numPastSessionsString}</p>\r\n        </>\r\n      );\r\n    }\r\n  };\r\n\r\n  if (error) {\r\n    return <ErrorMessage message={error.message}></ErrorMessage>;\r\n  }\r\n\r\n  if (isDone) {\r\n    return <CircularProgress></CircularProgress>;\r\n  }\r\n  if (!isLoading) {\r\n    return (\r\n      <>\r\n        {!isDone && (\r\n          <div className=\"session-container\">\r\n            <h1>Session</h1>\r\n\r\n            <div className=\"session-duration\">\r\n              <h3 className=\"duration\">DURATION: </h3>\r\n              <br></br>\r\n              <Timer initialTime={1000}>\r\n                {() => (\r\n                  <React.Fragment>\r\n                    <div className=\"timer\">\r\n                      <Timer.Minutes /> mins <Timer.Seconds /> secs\r\n                    </div>\r\n                  </React.Fragment>\r\n                )}\r\n              </Timer>\r\n              {showDecksOrPastSessionsHeader()}\r\n            </div>\r\n            <ProgressBar\r\n              cards={sessionMaterials.cards}\r\n              dispatch={setIsDone}\r\n              setNextCard={setNextCardIndex}\r\n              addCardDataToLocalStorage={addCardDataToLocalStorage}\r\n              currentCard={sessionMaterials.cards[nextCardIndex]}\r\n              currentResult={result}\r\n              setResult={setResult}\r\n            ></ProgressBar>\r\n            <CardFlip\r\n              front={sessionMaterials.cards[nextCardIndex].front}\r\n              back={sessionMaterials.cards[nextCardIndex].back}\r\n            ></CardFlip>\r\n            <div style={{ textAlign: \"center\", marginTop: \"3em\" }}>\r\n              <input\r\n                alt=\"correct\"\r\n                type=\"image\"\r\n                src={CorrectBtn}\r\n                style={{ width: \"3em\", marginRight: \"4em\" }}\r\n                onClick={() => {\r\n                  setResult(\"Correct!\");\r\n                  addCardDataToLocalStorage(\r\n                    { ...sessionMaterials.cards[nextCardIndex], nextCardIndex },\r\n                    nextCardIndex,\r\n                    true\r\n                  );\r\n                }}\r\n              />\r\n              <input\r\n                alt=\"wrong\"\r\n                type=\"image\"\r\n                src={WrongBtn}\r\n                style={{ width: \"3em\" }}\r\n                onClick={() => {\r\n                  setResult(\"Try again!\");\r\n                  debug(result);\r\n                  addCardDataToLocalStorage(\r\n                    { ...sessionMaterials.cards[nextCardIndex], nextCardIndex },\r\n                    nextCardIndex,\r\n                    false\r\n                  );\r\n                }}\r\n              />\r\n            </div>\r\n            <h2>{result}</h2>\r\n          </div>\r\n        )}\r\n      </>\r\n    );\r\n  } else {\r\n    return <CircularProgress></CircularProgress>;\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport Paper from \"@material-ui/core/Paper\";\r\nimport Table from \"@material-ui/core/Table\";\r\nimport TableBody from \"@material-ui/core/TableBody\";\r\nimport TableCell from \"@material-ui/core/TableCell\";\r\nimport TableContainer from \"@material-ui/core/TableContainer\";\r\nimport TableHead from \"@material-ui/core/TableHead\";\r\nimport TablePagination from \"@material-ui/core/TablePagination\";\r\nimport TableRow from \"@material-ui/core/TableRow\";\r\n\r\nexport enum ColumnType {\r\n  CARD_COLUMNS,\r\n  SUMMARY_COLUMNS,\r\n  DECK_COLUMNS,\r\n  SESSION_COLUMNS,\r\n}\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    width: \"100%\",\r\n  },\r\n  container: {\r\n    maxHeight: 520,\r\n  },\r\n});\r\n\r\nconst cardColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"front\", label: \"Front\", minWidth: 80, align: \"center\" },\r\n  { id: \"back\", label: \"Back\", minWidth: 80, align: \"center\" },\r\n  { id: \"score\", label: \"Score\", minWidth: 80, align: \"center\" },\r\n  { id: \"deck\", label: \"Deck\", minWidth: 80, align: \"center\" },\r\n];\r\n\r\nconst summaryColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"front\", label: \"Front\", minWidth: 80, align: \"center\" },\r\n  { id: \"back\", label: \"Back\", minWidth: 80, align: \"center\" },\r\n  { id: \"results\", label: \"Results\", minWidth: 80, align: \"center\" },\r\n  { id: \"deck\", label: \"Deck\", minWidth: 80, align: \"center\" },\r\n  { id: \"tagsString\", label: \"Tags\", minWidth: 80, align: \"center\" }, // if we delete the tags column for stats, it would still be nice to leave it in for summary\r\n];\r\n\r\nconst deckColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"name\", label: \"Name\", minWidth: 20, align: \"center\" },\r\n  { id: \"count\", label: \"Card Count\", minWidth: 80, align: \"center\" },\r\n  { id: \"score\", label: \"Score\", minWidth: 80, align: \"center\" },\r\n];\r\n\r\nconst sessionColumns = [\r\n  { id: \"indexString\", label: \"\", minWidth: 20, align: \"center\" },\r\n  { id: \"dateString\", label: \"Date\", minWidth: 80, align: \"center\" },\r\n  { id: \"count\", label: \"Card Count\", minWidth: 80, align: \"center\" },\r\n  { id: \"score\", label: \"Score\", minWidth: 80, align: \"center\" },\r\n  { id: \"duration\", label: \"Time Spent\", minWidth: 80, align: \"center\" },\r\n  { id: \"decks\", label: \"Decks\", minWidth: 80, align: \"center\" },\r\n];\r\ntype Props = { rows: any[]; columnType: ColumnType };\r\n\r\nexport default function StatisticsTable(props: Props) {\r\n  const { rows, columnType } = props;\r\n  const classes = useStyles();\r\n  const [page, setPage] = React.useState(0);\r\n  const [rowsPerPage, setRowsPerPage] = React.useState(10);\r\n\r\n  let columns = null;\r\n  switch (columnType) {\r\n    case ColumnType.CARD_COLUMNS: {\r\n      columns = cardColumns;\r\n      break;\r\n    }\r\n    case ColumnType.SUMMARY_COLUMNS: {\r\n      columns = summaryColumns;\r\n      break;\r\n    }\r\n    case ColumnType.DECK_COLUMNS: {\r\n      columns = deckColumns;\r\n      break;\r\n    }\r\n    case ColumnType.SESSION_COLUMNS: {\r\n      columns = sessionColumns;\r\n      break;\r\n    }\r\n  }\r\n\r\n  const handleChangePage = (event: unknown, newPage: number) => {\r\n    setPage(newPage);\r\n  };\r\n\r\n  const handleChangeRowsPerPage = (\r\n    event: React.ChangeEvent<HTMLInputElement>\r\n  ) => {\r\n    setRowsPerPage(+event.target.value);\r\n    setPage(0);\r\n  };\r\n\r\n  return (\r\n    <Paper className={classes.root}>\r\n      <TableContainer className={classes.container}>\r\n        <Table stickyHeader aria-label=\"sticky table\">\r\n          <TableHead>\r\n            <TableRow>\r\n              {columns.map((column) => (\r\n                <TableCell\r\n                  key={column.id}\r\n                  align=\"center\"\r\n                  style={{ minWidth: column.minWidth }}\r\n                >\r\n                  {column.label}\r\n                </TableCell>\r\n              ))}\r\n            </TableRow>\r\n          </TableHead>\r\n          <TableBody>\r\n            {rows\r\n              .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)\r\n              .map((row) => {\r\n                return (\r\n                  <TableRow\r\n                    hover\r\n                    role=\"checkbox\"\r\n                    tabIndex={-1}\r\n                    key={`${row.indexString}_${row.front}`}\r\n                  >\r\n                    {columns.map((column) => {\r\n                      const value = row[column.id];\r\n                      return (\r\n                        <TableCell key={column.id} align=\"center\">\r\n                          {value}\r\n                        </TableCell>\r\n                      );\r\n                    })}\r\n                  </TableRow>\r\n                );\r\n              })}\r\n          </TableBody>\r\n        </Table>\r\n      </TableContainer>\r\n      <TablePagination\r\n        rowsPerPageOptions={[10, 25, 100]}\r\n        component=\"div\"\r\n        count={rows.length}\r\n        rowsPerPage={rowsPerPage}\r\n        page={page}\r\n        onChangePage={handleChangePage}\r\n        onChangeRowsPerPage={handleChangeRowsPerPage}\r\n      />\r\n    </Paper>\r\n  );\r\n}\r\n","import React from \"react\";\nimport \"./styles.css\";\n\nfunction renderHeaderRow(overview) {\n  return (\n    overview &&\n    Object.keys(overview.overview).map((overviewKey) => {\n      return (\n        <td key={overviewKey} className=\"overViewTable\">\n          {overviewKey}\n        </td>\n      );\n    })\n  );\n}\n\nfunction renderValueRow(overview) {\n  return (\n    overview &&\n    Object.values(overview.overview).map((overviewValue, index) => {\n      return (\n        <th\n          key={`${overviewValue.toString()}_${index}`}\n          className=\"overViewTable\"\n        >\n          {overviewValue}\n        </th>\n      );\n    })\n  );\n}\n\nfunction StatsOverview(overview) {\n  return (\n    <>\n      <table className=\"overViewTable\">\n        <tbody className=\"overViewTable\">\n          <tr key=\"statsOverviewHeading\" className=\"overViewTable\">\n            {renderHeaderRow(overview)}\n          </tr>\n          <tr key=\"statsOverviewValues\" className=\"overViewTable\">\n            {renderValueRow(overview)}\n          </tr>\n        </tbody>\n      </table>\n    </>\n  );\n}\n\nexport default StatsOverview;\n","import React, { useState, useEffect } from \"react\";\r\nimport StatisticsTable from \"./StatisticsTable\";\r\nimport StatisticsOverview from \"./StatisticsOverview\";\r\nimport { ColumnType } from \"./StatisticsTable\";\r\nimport {\r\n  createCardData,\r\n  createDeckData,\r\n  createSessionData,\r\n} from \"../lib/utils\";\r\nimport { ComplexCommandParams } from \"../App\";\r\nimport { SubjectType as Subject } from \"../ast/SUBJECT\";\r\nimport {\r\n  getSelectedDecks,\r\n  getCardsFromSelectedDecks,\r\n  cardFilter,\r\n  getCardsFromSelectedSessions,\r\n  deckFilter,\r\n  getDeckNameFromID,\r\n  calculateDeckScore,\r\n  getPastSessions,\r\n  sessionFilter,\r\n  getUniqueDeckNamesFromSessions,\r\n} from \"../model/query\";\r\nimport { CircularProgress } from \"@material-ui/core\";\r\nimport Card from \"../model/Card\";\r\nimport Deck from \"../model/Deck\";\r\nimport Session from \"../model/Session\";\r\nimport SessionCard from \"../model/SessionCard\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\n\r\ntype Props = { complexCommandParams: ComplexCommandParams };\r\n\r\nenum View {\r\n  LOADING,\r\n  READY,\r\n  ERROR,\r\n}\r\n\r\ntype StatsObject = any; // can add typing here\r\n\r\ntype StatsState =\r\n  | {\r\n      view: View.LOADING;\r\n    }\r\n  | {\r\n      view: View.READY;\r\n      statsObject: StatsObject;\r\n    }\r\n  | {\r\n      view: View.ERROR;\r\n      error: Error;\r\n    };\r\n\r\nexport default function Statistics(props: Props) {\r\n  // Initialize the view to be \"Loading\" since we need to do asynchronous operation before showing data\r\n  const initialState: StatsState = { view: View.LOADING };\r\n  const [state, setState] = useState<StatsState>(initialState);\r\n  const database = useDatabase();\r\n\r\n  const {\r\n    limit,\r\n    filter,\r\n    isLimitAppliedToCards,\r\n    deckNames,\r\n    subject,\r\n  } = props.complexCommandParams;\r\n\r\n  async function createStatsObject() {\r\n    const {\r\n      rows,\r\n      highestScore,\r\n      lowestScore,\r\n      averageScore,\r\n    } = await getDetails();\r\n    return {\r\n      overview: {\r\n        \"average score\": averageScore,\r\n        \"highest score\": highestScore,\r\n        \"lowest score\": lowestScore,\r\n      },\r\n      details: rows,\r\n      columnType: getColumnType(),\r\n    };\r\n  }\r\n\r\n  async function getDetails() {\r\n    let rows = [];\r\n    let highestScore: number = NaN;\r\n    let lowestScore: number = NaN;\r\n    let averageScore: number = NaN;\r\n    let index = 1;\r\n    if (isLimitAppliedToCards) {\r\n      let retrievedCards: Array<Card>;\r\n      if (subject === Subject.Decks) {\r\n        retrievedCards = await getCardsFromSelectedDecks(database, deckNames);\r\n      } else if (subject === Subject.Sessions) {\r\n        retrievedCards = await getCardsFromSelectedSessions(database, limit);\r\n      } else {\r\n        throw new Error(\r\n          `Retrieving stats for cards from ${subject} is not supported`\r\n        );\r\n      }\r\n      const filteredCards = cardFilter(retrievedCards, filter, limit);\r\n      for (let card of filteredCards) {\r\n        const score: number = card.right / (card.wrong + card.right);\r\n        highestScore =\r\n          isNaN(highestScore) || score > highestScore ? score : highestScore;\r\n        lowestScore =\r\n          isNaN(lowestScore) || score < lowestScore ? score : lowestScore;\r\n        rows = rows.concat(\r\n          createCardData(\r\n            index,\r\n            card.front,\r\n            card.back,\r\n            card.right,\r\n            card.wrong,\r\n            await getDeckNameFromID(database, card.deck_id)\r\n          )\r\n        );\r\n        index += 1;\r\n      }\r\n    } else if (subject === Subject.Decks) {\r\n      const retrievedDecks = await getSelectedDecks(database, deckNames);\r\n      let filteredDecks: Array<Deck> = await deckFilter(\r\n        retrievedDecks,\r\n        filter,\r\n        limit\r\n      );\r\n      for (let deck of filteredDecks) {\r\n        const cards = await deck.cards.fetch();\r\n        const score = calculateDeckScore(cards);\r\n        rows = rows.concat(\r\n          createDeckData(index, deck.name, cards.length, score)\r\n        );\r\n        highestScore =\r\n          isNaN(highestScore) || score > highestScore ? score : highestScore;\r\n        lowestScore =\r\n          isNaN(lowestScore) || score < lowestScore ? score : lowestScore;\r\n        index += 1;\r\n      }\r\n    } else if (subject === Subject.Sessions) {\r\n      const retrievedSessions = await getPastSessions(database, limit);\r\n      let filteredSessions: Array<Session> = await sessionFilter(\r\n        database,\r\n        retrievedSessions,\r\n        filter,\r\n        limit\r\n      );\r\n      for (let session of filteredSessions) {\r\n        const deckNames = await getUniqueDeckNamesFromSessions(\r\n          database,\r\n          session\r\n        );\r\n        const sessionCards: Array<SessionCard> = (await session.cards) as Array<\r\n          SessionCard\r\n        >;\r\n        const numberCorrect = sessionCards.map((sc) => sc.is_correct).length;\r\n        const score = numberCorrect / sessionCards.length;\r\n        highestScore =\r\n          isNaN(highestScore) || score > highestScore ? score : highestScore;\r\n        lowestScore =\r\n          isNaN(lowestScore) || score < lowestScore ? score : lowestScore;\r\n        rows = rows.concat(\r\n          createSessionData(\r\n            index,\r\n            sessionCards.length,\r\n            numberCorrect,\r\n            session.started_at,\r\n            session.ended_at,\r\n            deckNames\r\n          )\r\n        );\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        \"Command not currently supported: \" + props.complexCommandParams\r\n      );\r\n    }\r\n    averageScore =\r\n      rows.reduce(function (sum, a) {\r\n        return sum + a.score;\r\n      }, 0) / (rows.length || 1);\r\n    return { rows, highestScore, lowestScore, averageScore };\r\n  }\r\n\r\n  function getColumnType() {\r\n    if (isLimitAppliedToCards) {\r\n      return ColumnType.CARD_COLUMNS;\r\n    }\r\n    switch (subject) {\r\n      case Subject.Decks: {\r\n        return ColumnType.DECK_COLUMNS;\r\n      }\r\n      case Subject.Sessions: {\r\n        return ColumnType.SESSION_COLUMNS;\r\n      }\r\n      case Subject.Tags: {\r\n        return ColumnType.DECK_COLUMNS;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Asynchronously load the data and change the state when done\r\n  useEffect(() => {\r\n    const setStatsObject = async () => {\r\n      try {\r\n        const statsObject = await createStatsObject();\r\n        setState({ view: View.READY, statsObject });\r\n      } catch (err) {\r\n        setState({ view: View.ERROR, error: err });\r\n      }\r\n    };\r\n    setStatsObject();\r\n  }, [props.complexCommandParams]);\r\n\r\n  // Conditionally render loading screen, error message, or the actual data\r\n  // Feel free to change this however you'd like, this is just some placeholder\r\n  if (state.view === View.LOADING) {\r\n    return <CircularProgress style={{ margin: \"auto\" }}></CircularProgress>;\r\n  } else if (state.view === View.ERROR) {\r\n    console.log(state.error);\r\n    return (\r\n      <h1 style={{ margin: \"auto\" }}>\r\n        Something went wrong when trying to fetch the stats\r\n      </h1>\r\n    );\r\n  } else {\r\n    return (\r\n      <>\r\n        <div className=\"right-side-container\">\r\n          <h1> Statistics</h1>\r\n          <StatisticsOverview overview={state.statsObject.overview} />\r\n          <StatisticsTable\r\n            rows={state.statsObject.details}\r\n            columnType={state.statsObject.columnType}\r\n          />\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ProgressBar from \"./ProgressBar\";\r\nimport CardFlip from \"./CardFlip\";\r\nimport WrongBtn from \"../assets/wrongBtn.svg\";\r\nimport CorrectBtn from \"../assets/correctBtn.svg\";\r\n\r\nexport default function DeckViewDetails(props) {\r\n  return (\r\n    <>\r\n      <div className=\"session-container\" style={{ textAlign: \"center\" }}>\r\n        <h1>Deck: {props.name}</h1>\r\n        {props.deck.deck.cards.map((c) => {\r\n          return <CardFlip front={c.front} back={c.back}></CardFlip>;\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport StatisticsTable from \"./StatisticsTable\";\r\nimport { ColumnType } from \"./StatisticsTable\";\r\nimport ConfettiEmoji from \"../assets/confettiEmoji.png\";\r\nimport { createSummaryData } from \"../lib/utils\";\r\n\r\nfunction getSessionCards() {\r\n  const sessionDataString = localStorage.getItem(\"sessionData\");\r\n  const sessionData = sessionDataString && JSON.parse(sessionDataString);\r\n  const endedAt = sessionData[\"ended_at\"];\r\n  const createdAt = sessionData[\"created_at\"];\r\n  const endedAtObj = new Date(endedAt);\r\n  const createdAtObj = new Date(createdAt);\r\n  const totalTimeInMS = endedAtObj.getTime() - createdAtObj.getTime();\r\n  const totalMinutes = Math.floor(totalTimeInMS / 60000);\r\n  const totalSeconds = ((totalTimeInMS % 60000) / 1000).toFixed(0);\r\n  const totalTime = `${totalMinutes} min ${totalSeconds} sec`;\r\n  const cardDataArray = sessionData[\"cardDataArray\"];\r\n  const cardSummaryDataArray =\r\n    cardDataArray &&\r\n    sessionData[\"cardDataArray\"].map((c) => {\r\n      return createSummaryData(\r\n        c[\"card_index\"] + 1,\r\n        c[\"front\"],\r\n        c[\"back\"],\r\n        c[\"is_correct\"],\r\n        c[\"deck\"],\r\n        c[\"tags\"]\r\n      );\r\n    });\r\n  return {\r\n    overview: { \"total time\": totalTime },\r\n    details: cardSummaryDataArray || [],\r\n  };\r\n}\r\n\r\nfunction getSessionScore(cardArray: any[]): [string, boolean] {\r\n  const reducer = (accumulator, currentValue) => {\r\n    const cardNumerator =\r\n      currentValue && currentValue.results === \"correct\" ? 1 : 0;\r\n    return accumulator + cardNumerator;\r\n  };\r\n  const numerator = cardArray.reduce(reducer, 0);\r\n  const denominator = cardArray.length;\r\n\r\n  const numeratorString = numerator && numerator.toString();\r\n  const denominatorString = denominator && denominator.toString();\r\n\r\n  const sessionScore = [numeratorString, denominatorString].join(\"/\");\r\n  const isAllCorrect = numerator === denominator && denominator !== 0;\r\n\r\n  return [sessionScore, isAllCorrect];\r\n}\r\n\r\nexport default function PostSessionSummary() {\r\n  const sessionCards = getSessionCards();\r\n  const [score, isAllCorrect]: [string, boolean] = getSessionScore(\r\n    sessionCards.details\r\n  );\r\n\r\n  return (\r\n    <div className=\"right-side-container\">\r\n      <h1>Summary</h1>\r\n      <br />\r\n      <h2>You got: {score} cards correct</h2>\r\n      {isAllCorrect && <h2>Good job!!</h2>}\r\n      {isAllCorrect && (\r\n        <img className=\"confetti\" src={ConfettiEmoji} alt={\"Confetti\"} />\r\n      )}\r\n      <br />\r\n      <h3>Time spent: {sessionCards.overview[\"total time\"]}</h3>\r\n      <br />\r\n      <StatisticsTable\r\n        rows={sessionCards.details}\r\n        columnType={ColumnType.SUMMARY_COLUMNS}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","import React, { useReducer } from \"react\";\r\nimport \"./App.css\";\r\nimport NavBar from \"./components/NavBar\";\r\nimport DeckView from \"./components/DeckView\";\r\nimport CardEditor from \"./components/CardEditor\";\r\nimport CommandEditor from \"./components/CommandEditor\";\r\nimport Session from \"./components/Session\";\r\nimport Statistics from \"./components/Statistics\";\r\nimport ListView from \"./components/ListView\";\r\nimport PROGRAM from \"./ast/PROGRAM\";\r\nimport { getInitialData } from \"./lib/getIintialData\";\r\nimport { createOrUpdateAllDecks } from \"./lib/reconciler\";\r\nimport { SubjectType as Subject } from \"./ast/SUBJECT\";\r\n\r\nimport DeckViewDetails from \"./components/DeckViewDetails\";\r\nimport ErrorMessage from \"./components/ErrorMessage\";\r\nimport { useDatabase } from \"@nozbe/watermelondb/hooks\";\r\n\r\nimport PostSessionSummary from \"./components/PostSessionSummary\";\r\nimport { CircularProgress } from \"@material-ui/core\";\r\nimport {\r\n  getSelectedDecks,\r\n  deckFilter,\r\n  Filter,\r\n  getCardsFromSelectedDecks,\r\n} from \"./model/query\";\r\n\r\nimport { debug, randomize } from \"./lib/utils\";\r\n\r\nimport CREATE_DECK from \"./ast/CREATE_DECK\";\r\nimport { checkSessionCommandError } from \"./lib/sessionHelperFunctions\";\r\n\r\nconst CustomListView = ({ program, dispatch }) => {\r\n  return (\r\n    <div className=\"card-view-container\">\r\n      <div className=\"card-view\">\r\n        <div\r\n          style={{\r\n            display: \"grid\",\r\n            gridTemplateColumns: \"1fr 1fr\",\r\n            justifyItems: \"center\",\r\n          }}\r\n        >\r\n          <ListView\r\n            deckNames={program.create_decks.map((deck) => {\r\n              return deck.name;\r\n            })}\r\n            dispatch={dispatch}\r\n          ></ListView>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// What screen the UI should be showing\r\nexport enum View {\r\n  DECK,\r\n  STATS,\r\n  SESSION,\r\n  POST_SESSION,\r\n  LIST,\r\n  DECK_DETAIL,\r\n  ERROR,\r\n  LOADING,\r\n}\r\n\r\nexport type ComplexCommandParams = {\r\n  limit?: number;\r\n  filter?: Filter;\r\n  isLimitAppliedToCards?: boolean;\r\n  deckNames?: string[];\r\n  subject: Subject;\r\n  tagNames?: string[];\r\n};\r\n\r\ntype State = {\r\n  view: View;\r\n  program: PROGRAM;\r\n  cardEditor?: CodeMirror.Editor;\r\n  subjectToList: Subject;\r\n  deckToViewDetail?: string;\r\n  complexCommandParams?: ComplexCommandParams;\r\n};\r\n\r\nexport enum ActionType {\r\n  SetCardEditor = \"set card editor\",\r\n  CardEditorParseSuccess = \"card editor parse success\",\r\n  StartSession = \"start session\",\r\n  PostSession = \"post session\",\r\n  List = \"list\",\r\n  ViewDeckDetail = \"view deck detail\",\r\n  ShowStats = \"show stats\",\r\n  LoadDecks = \"load decks\",\r\n  CommandNotFound = \"command not found\",\r\n  QuitToHome = \"quit to home\",\r\n}\r\n\r\nexport type Action =\r\n  | {\r\n      type: ActionType.SetCardEditor; // Enables \"Load decks\" to work\r\n      cardEditor: CodeMirror.Editor;\r\n    }\r\n  | {\r\n      type: ActionType.CardEditorParseSuccess;\r\n      program: PROGRAM;\r\n    }\r\n  | {\r\n      type: ActionType.StartSession;\r\n      limit?: number;\r\n      filter?: Filter;\r\n      isLimitAppliedToCards?: boolean;\r\n      deckNames?: string[];\r\n      subject: Subject;\r\n      tagNames?: string[];\r\n    }\r\n  | {\r\n      type: ActionType.List;\r\n      listOption: \"decks\" | \"tags\";\r\n      // tags not implemented\r\n    }\r\n  | {\r\n      type: ActionType.ViewDeckDetail;\r\n      deckName: string;\r\n    }\r\n  | {\r\n      type: ActionType.ShowStats;\r\n      limit: number;\r\n      filter?: Filter;\r\n      isLimitAppliedToCards?: boolean;\r\n      deckNames?: string[];\r\n      subject: Subject;\r\n    }\r\n  | {\r\n      type: ActionType.LoadDecks;\r\n      createDSLValue: string;\r\n    }\r\n  | {\r\n      type: ActionType.QuitToHome;\r\n    }\r\n  | {\r\n      type: ActionType.CommandNotFound;\r\n    }\r\n  | {\r\n      type: ActionType.PostSession;\r\n    }; // Add actions here\r\n\r\nconst reducer = (state: State, action: Action): State => {\r\n  debug(\"Dispatched to App: \", action);\r\n  switch (action.type) {\r\n    // Add action handlers here\r\n    case \"set card editor\": {\r\n      return {\r\n        ...state,\r\n        cardEditor: action.cardEditor,\r\n      };\r\n    }\r\n    case \"card editor parse success\": {\r\n      return {\r\n        ...state,\r\n        program: action.program,\r\n        view: View.DECK,\r\n      };\r\n    }\r\n    case \"start session\": {\r\n      console.log(\"Start session action received\");\r\n      return {\r\n        ...state,\r\n        complexCommandParams: {\r\n          limit: action.limit,\r\n          filter: action.filter,\r\n          isLimitAppliedToCards: action.isLimitAppliedToCards,\r\n          deckNames: action.deckNames,\r\n          subject: action.subject,\r\n          tagNames: action.tagNames,\r\n        },\r\n        view: View.SESSION,\r\n      };\r\n    }\r\n    case \"show stats\": {\r\n      return {\r\n        ...state,\r\n        view: View.STATS,\r\n        complexCommandParams: {\r\n          limit: action.limit,\r\n          filter: action.filter,\r\n          isLimitAppliedToCards: action.isLimitAppliedToCards,\r\n          deckNames: action.deckNames,\r\n          subject: action.subject, // if deckNames is null then it is from past sessions\r\n        },\r\n      };\r\n    }\r\n    case \"list\": {\r\n      return {\r\n        ...state,\r\n        view: View.LIST,\r\n      };\r\n    }\r\n    case \"post session\": {\r\n      return {\r\n        ...state,\r\n        view: View.POST_SESSION,\r\n      };\r\n    }\r\n    case \"quit to home\": {\r\n      return {\r\n        ...state,\r\n        view: View.DECK,\r\n      };\r\n    }\r\n    case \"view deck detail\": {\r\n      return {\r\n        ...state,\r\n        view: View.DECK_DETAIL,\r\n        deckToViewDetail: action.deckName,\r\n      };\r\n    }\r\n    case \"load decks\": {\r\n      state.cardEditor.getDoc().setValue(action.createDSLValue);\r\n      return state;\r\n    }\r\n    case \"command not found\": {\r\n      return {\r\n        ...state,\r\n        view: View.ERROR,\r\n      };\r\n    }\r\n    default:\r\n      break;\r\n  }\r\n  debug(\"Unexpected end of reducer dispatch!\");\r\n  return state;\r\n};\r\n\r\nexport default function App() {\r\n  // Get initial data once from localStorage\r\n  const { isFirstTimeUser, initialText, initialProgram } = getInitialData(); // TODO: Also find session information from localStorage\r\n\r\n  const db = useDatabase();\r\n\r\n  if (isFirstTimeUser) {\r\n    createOrUpdateAllDecks(initialProgram, db);\r\n  }\r\n\r\n  const initialState: State = {\r\n    view: View.DECK,\r\n    program: initialProgram, // The \"source of truth\" until Goi gives user more card management\r\n\r\n    cardEditor: undefined,\r\n    deckToViewDetail: undefined,\r\n    subjectToList: undefined,\r\n    complexCommandParams: {\r\n      limit: undefined,\r\n      filter: undefined,\r\n      isLimitAppliedToCards: undefined, // SUBJECT_MODIFIER::selectedCards boolean attribute\r\n      deckNames: undefined,\r\n      subject: Subject.Undefined, // if deckNames is null then it is from past sessions\r\n    },\r\n  };\r\n\r\n  const [\r\n    { view, program, deckToViewDetail, complexCommandParams },\r\n    dispatch,\r\n  ] = useReducer(reducer, initialState);\r\n\r\n  const showView = (view: View) => {\r\n    if (view !== View.SESSION && view !== View.POST_SESSION) {\r\n      localStorage.removeItem(\"sessionData\");\r\n    }\r\n    switch (view) {\r\n      case View.DECK: {\r\n        return <DeckView program={program} dispatch={dispatch}></DeckView>;\r\n      }\r\n      case View.POST_SESSION: {\r\n        return <PostSessionSummary />;\r\n      }\r\n      case View.LIST: {\r\n        return (\r\n          <>\r\n            <CustomListView\r\n              program={program}\r\n              dispatch={dispatch}\r\n            ></CustomListView>\r\n          </>\r\n        );\r\n      }\r\n      case View.SESSION: {\r\n        return (\r\n          <Session\r\n            dispatch={dispatch}\r\n            complexCommandParams={complexCommandParams}\r\n            program={program}\r\n          ></Session>\r\n        );\r\n      }\r\n      case View.STATS: {\r\n        return (\r\n          <Statistics complexCommandParams={complexCommandParams}></Statistics>\r\n        );\r\n      }\r\n      case View.DECK_DETAIL: {\r\n        console.log(deckToViewDetail);\r\n        return (\r\n          <DeckViewDetails\r\n            name={deckToViewDetail}\r\n            deck={\r\n              program.create_decks.filter((d) => {\r\n                return d.name === deckToViewDetail;\r\n              })[0]\r\n            }\r\n          ></DeckViewDetails>\r\n        );\r\n      }\r\n      case View.ERROR: {\r\n        return (\r\n          <ErrorMessage message=\"Command not found. Type 'Help'\"></ErrorMessage>\r\n        );\r\n      }\r\n      case View.LOADING: {\r\n        return <CircularProgress style={{ margin: \"auto\" }} />;\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"navbar\">\r\n        <NavBar></NavBar>\r\n      </div>\r\n      <div className=\"container\" style={{ backgroundColor: \"#FAFAFA\" }}>\r\n        {/*gives CardEditor the ability to change Deck view */}\r\n        <CardEditor\r\n          dispatch={dispatch}\r\n          program={program}\r\n          initialText={initialText}\r\n          isInSession={view === View.SESSION}\r\n        ></CardEditor>\r\n        <CommandEditor dispatch={dispatch}></CommandEditor>\r\n        {showView(view)}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import {\r\n  appSchema,\r\n  tableSchema,\r\n  ColumnType,\r\n  ColumnSchema,\r\n} from \"@nozbe/watermelondb\";\r\nimport { TableName } from \"./constants\";\r\n\r\nfunction columnSchema(\r\n  name: string,\r\n  type: ColumnType,\r\n  isIndexed?: boolean\r\n): ColumnSchema {\r\n  return {\r\n    name,\r\n    type,\r\n    isIndexed,\r\n  };\r\n}\r\n\r\n// ERD: https://drive.google.com/file/d/1lpoQcutNxBkVubtkJHgOVcD3UjohvQpm/view\r\n\r\n// Following suggested naming convention: plural snake case\r\n// https://nozbe.github.io/WatermelonDB/Schema.html\r\n\r\n// All tables automatically have a string column id to uniquely identify records\r\nexport default appSchema({\r\n  version: 1,\r\n  tables: [\r\n    tableSchema({\r\n      name: TableName.DECKS,\r\n      columns: [\r\n        columnSchema(\"name\", \"string\"),\r\n        columnSchema(\"created_at\", \"number\"), // automatic https://nozbe.github.io/WatermelonDB/Advanced/CreateUpdateTracking.html\r\n      ],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.CARDS,\r\n      columns: [\r\n        columnSchema(\"created_at\", \"number\"), // automatic\r\n        columnSchema(\"updated_at\", \"number\"), // automatic\r\n        columnSchema(\"last_tested_at\", \"number\"),\r\n        columnSchema(\"deck_id\", \"string\", true),\r\n        columnSchema(\"front\", \"string\", true),\r\n        columnSchema(\"back\", \"string\", true),\r\n        columnSchema(\"wrong\", \"number\"),\r\n        columnSchema(\"right\", \"number\"),\r\n      ],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.SESSIONS,\r\n      columns: [\r\n        columnSchema(\"started_at\", \"number\"), // manual\r\n        columnSchema(\"ended_at\", \"number\"), // manual\r\n      ],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.SESSIONS_CARDS,\r\n      columns: [\r\n        columnSchema(\"session_id\", \"string\", true),\r\n        columnSchema(\"card_id\", \"string\", true),\r\n        columnSchema(\"is_correct\", \"boolean\"),\r\n      ],\r\n    }),\r\n\r\n    // To have card tags we need to change EBNF, however it would be a huge improvement over deck tags\r\n    tableSchema({\r\n      name: TableName.TAGS,\r\n      columns: [columnSchema(\"name\", \"string\", true)],\r\n    }),\r\n    tableSchema({\r\n      name: TableName.TAGS_CARDS,\r\n      columns: [\r\n        columnSchema(\"tag_id\", \"string\", true),\r\n        columnSchema(\"card_id\", \"string\", true),\r\n      ],\r\n    }),\r\n  ],\r\n});\r\n","import { Model } from \"@nozbe/watermelondb\";\r\nimport { date, field } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class Card extends Model {\r\n  static table = TableName.CARDS;\r\n  static associations: Associations = {\r\n    [TableName.DECKS]: { type: \"belongs_to\", key: \"deck_id\" },\r\n    [TableName.TAGS_CARDS]: { type: \"has_many\", foreignKey: \"card_id\" },\r\n    [TableName.SESSIONS_CARDS]: { type: \"has_many\", foreignKey: \"card_id\" },\r\n  };\r\n\r\n  @date(\"created_at\") created_at;\r\n  @date(\"updated_at\") updated_at;\r\n  @date(\"last_tested_at\") last_tested_at;\r\n  @field(\"deck_id\") deck_id;\r\n  @field(\"front\") front;\r\n  @field(\"back\") back;\r\n  @field(\"wrong\") wrong;\r\n  @field(\"right\") right;\r\n}\r\n","import { Model, Query } from \"@nozbe/watermelondb\";\r\nimport { children, date, field, action } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\nimport Card from \"./Card\";\r\n\r\nexport default class Deck extends Model {\r\n  static table = TableName.DECKS;\r\n  static associations: Associations = {\r\n    [TableName.CARDS]: { type: \"has_many\", foreignKey: \"deck_id\" },\r\n  };\r\n\r\n  @field(\"name\") name;\r\n  @date(\"created_at\") created_at;\r\n  @children(TableName.CARDS) cards: Query<Card>;\r\n\r\n  @action async addCard(front: string, back: string) {\r\n    return await this.collections.get(TableName.CARDS).create((card: Card) => {\r\n      card.deck_id = this.id;\r\n      card.front = front;\r\n      card.back = back;\r\n    });\r\n  }\r\n}\r\n","import { Model, Q } from \"@nozbe/watermelondb\";\r\nimport { date, lazy } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class Session extends Model {\r\n  static table = TableName.SESSIONS;\r\n  static associations: Associations = {\r\n    [TableName.SESSIONS_CARDS]: { type: \"has_many\", foreignKey: \"session_id\" },\r\n  };\r\n\r\n  @date(\"started_at\") started_at;\r\n  @date(\"ended_at\") ended_at;\r\n\r\n  @lazy cards = this.collections\r\n    .get(TableName.CARDS)\r\n    .query(Q.on(TableName.SESSIONS_CARDS, \"session_id\", this.id))\r\n    .fetch();\r\n}\r\n","import { Model } from \"@nozbe/watermelondb\";\r\nimport { field } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class SessionCard extends Model {\r\n  static table = TableName.SESSIONS_CARDS;\r\n  static associations: Associations = {\r\n    [TableName.SESSIONS]: { type: \"belongs_to\", key: \"session_id\" },\r\n    [TableName.CARDS]: { type: \"belongs_to\", key: \"card_id\" },\r\n  };\r\n\r\n  @field(\"session_id\") session_id;\r\n  @field(\"card_id\") card_id;\r\n  @field(\"is_correct\") is_correct;\r\n}\r\n","import { Model, Q } from \"@nozbe/watermelondb\";\nimport { field, lazy } from \"@nozbe/watermelondb/decorators\";\nimport { Associations } from \"@nozbe/watermelondb/Model\";\nimport { TableName } from \"./constants\";\n\nexport default class Tag extends Model {\n  static table = TableName.TAGS;\n  static associations: Associations = {\n    [TableName.TAGS_CARDS]: { type: \"has_many\", foreignKey: \"tag_id\" },\n  };\n\n  @field(\"name\") name;\n\n  @lazy cards = this.collections\n    .get(TableName.CARDS)\n    .query(Q.on(TableName.TAGS_CARDS, \"tag_id\", this.id))\n    .fetch();\n}\n","import { Model } from \"@nozbe/watermelondb\";\r\nimport { field } from \"@nozbe/watermelondb/decorators\";\r\nimport { Associations } from \"@nozbe/watermelondb/Model\";\r\nimport { TableName } from \"./constants\";\r\n\r\nexport default class TagCard extends Model {\r\n  static table = TableName.TAGS_CARDS;\r\n  static associations: Associations = {\r\n    [TableName.TAGS]: { type: \"belongs_to\", key: \"tag_id\" },\r\n    [TableName.CARDS]: { type: \"belongs_to\", key: \"card_id\" },\r\n  };\r\n\r\n  @field(\"tag_id\") tag_id;\r\n  @field(\"card_id\") card_id;\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nimport { Database } from \"@nozbe/watermelondb\";\r\nimport LokiJSAdapter from \"@nozbe/watermelondb/adapters/lokijs\";\r\nimport DatabaseProvider from \"@nozbe/watermelondb/DatabaseProvider\";\r\nimport schema from \"./model/schema\";\r\nimport Card from \"./model/Card\";\r\nimport Deck from \"./model/Deck\";\r\nimport Session from \"./model/Session\";\r\nimport SessionCard from \"./model/SessionCard\";\r\nimport Tag from \"./model/Tag\";\r\nimport TagCard from \"./model/TagCard\";\r\n\r\nconst adapter = new LokiJSAdapter({\r\n  schema,\r\n  useWebWorker: false,\r\n  useIncrementalIndexedDB: true,\r\n});\r\n\r\nconst database = new Database({\r\n  adapter,\r\n  modelClasses: [Card, Deck, Session, SessionCard, Tag, TagCard],\r\n  actionsEnabled: true,\r\n});\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <DatabaseProvider database={database}>\r\n      <App />\r\n    </DatabaseProvider>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}